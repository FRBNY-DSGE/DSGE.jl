function lag(X::Matrix{S}, lags::Int; pad::Bool = false, T_by_n::Bool = true,
             drop_obs::Int = 0) where {S<:Real}
    if pad
        keep_lags = max(lags - drop_obs, 0)
        start = 1 + max(drop_obs - lags, 0)
        if T_by_n
            out = fill!(Matrix{S}(undef, size(X, 1) - drop_obs, size(X, 2)), NaN)
            out[1 + keep_lags:end, :] = X[start:size(X, 1) - lags, :]
        else
            out = fill!(Matrix{S}(undef, size(X, 1), size(X, 2) - drop_obs), NaN)
            out[:, 1 + keep_lags:end] = X[:, start:size(X, 2) - lags]
        end
    else
        out = T_by_n ? X[1 + drop_obs:size(X, 1) - lags, :] :
            X[:, 1 + drop_obs:size(X, 2) - lags]
    end
    return out
end

function lag_data(data::Matrix{S}, lags::Int; use_intercept::Bool = true,
                  pad::Bool = false, padding::Matrix{S} = Matrix{S}(undef, 0, 0)) where {S<:Real}
    # Assumes data is nobs x T
    nobs, T = size(data)
    data = Matrix(data')

    # Construct XX matrix of covariates
    add_constant = use_intercept ? 1 : 0
    XX = fill!(Matrix{S}(undef, pad ? T : T - lags, lags * nobs + add_constant), NaN)
    if use_intercept
        XX[:, 1] .= one(S) # XX is T x n_regressors
    end

    for i = 1:lags
        XX[:, add_constant + (i - 1) * nobs + 1:add_constant + i * nobs] =
            lag(data, i; pad = pad, T_by_n = true, drop_obs = pad ? 0 : lags - i)
    end

    if pad && !isempty(padding)
        XX[1:lags, :] = padding
    end

    return XX
end

function compute_var_population_moments(data::Matrix{S}, lags::Int;
                                 use_intercept::Bool = false) where {S<:Real}
    # Compute population moments of sample data
    YY = convert(Matrix{S}, data[:, 1 + lags:end]')
    XX = lag_data(data, lags; use_intercept = use_intercept) # Construct XX matrix of covariates
    YYYY = YY' * YY
    XXYY = XX' * YY
    XXXX = XX' * XX

    return YYYY, XXYY, XXXX
end

"""
```
draw_stationary_VAR(YYYYC, XXYYC, XXXXC, TÌ„, n_obs, lags; testing = false,
                    test_Î£_draw = [], test_Î²_draw = [])
draw_stationary_VAR(YYYYC, XXYYC, XXXXC, TÌ„; testing = false,
                    test_Î£_draw = [], test_Î²_draw = [])
```
draws Î² and Î£ from the distribution p(Î², Î£ | Y, Î¸) implied by the
population moments (or covariances) YYYYC, XXYYC, and XXXXC for a
VAR with parameters Î¸.

For example, if these population moments are generated by
a DSGE-VAR, then Î¸ are the structural parameters of the DSGE
and the weight Î» placed on the cross-restrictions implied
by the DSGE. The population moments would represent the
moments of the sample data and dummy observables generated
to implement the DSGE prior.

Given these moments, we compute the maximum-likelihood
estimates of Î² and Î£ using OLS. Denote these estimates
by Î’ and S. Then we generate draws from p(Î², Î£ | Y, Î¸)
using the fact that
```
Î£ | Y, Î¸ âˆ¼ â„ð’² (TÌ„ Ã— S, TÌ„ - (1 + lags * n_obs), n_obs),
Î² | Y, Î£,Î¸ âˆ¼ ð’© (B, Î£ âŠ— XXXXCâ»Â¹).
```
Finally, we check that these draws generate a stationary
state space system. If they do not, then we keep drawing
until we obtain a pair of draws (Î², Î£) that are stationary.

### Inputs
* `YYYYC::Matrix{<:Real}`: covariance of observables
* `XXYYC::Matrix{<:Real}`: covariance of observables with their lags
* `XXXXC::Matrix{<:Real}`: covariance of the lags of the observables
* `TÌ„::Int`: total number of time periods of observations, including sample observables
    from actual data and any dummy observables generated to implement priors.
* `n_obs::Int`: number of distint observables
* `lags::Int`: number of lags in the VAR

### Keywords
* All keywords are used for testing purposes.
"""
function draw_stationary_VAR(YYYYC::Matrix{S}, XXYYC::Matrix{S}, XXXXC::Matrix{S},
                             TÌ„::Int, n_obs::Int, lags::Int; standard_orientation::Bool = true,
                             testing::Bool = false,
                             test_Î£_draw::Matrix{S} = Matrix{S}(undef, 0, 0),
                             test_Î²_draw::Vector{S} = Vector{S}(undef, 0)) where {S<:Real}

    # Set up
    k = 1 + lags * n_obs
    inv_XXXXC = inv(XXXXC)
    Î² = inv_XXXXC * XXYYC
    inv_Î£_mul_TÌ„ = inv(YYYYC - XXYYC' * Î²)
    inv_Î£_mul_TÌ„ += inv_Î£_mul_TÌ„' # force to be positive definite
    inv_Î£_mul_TÌ„ ./= 2.
    cholmat = cholesky(inv_Î£_mul_TÌ„).L

    Î² = vec(Î²)
    Î²_draw = similar(Î²)
    Î£_draw = similar(inv_Î£_mul_TÌ„)
    if testing # just do one draw each
        # Draw from marginal posterior of Î£ (based on DSGE-VAR)
        z = cholmat * test_Î£_draw
        Î£_draw = inv(z * z')

        # Draw from the conditional posterior of Î² (based on DSGE-VAR)
        vc       = kron(Î£_draw, inv_XXXXC)
        vc       += vc'
        vc       ./= 2.
        Î²_draw   = convert(Matrix{S}, reshape(Î² + cholesky(vc).L * test_Î²_draw, k, n_obs)')
    else
        stationary = false
        while !stationary
            # Draw from marginal posterior of Î£ (based on DSGE-VAR)
            z = cholmat * randn(n_obs, TÌ„ - k)
            Î£_draw = inv(z * z')

            # Draw from the conditional posterior of Î² (based on DSGE-VAR)
            vc       = kron(Î£_draw, inv_XXXXC)
            vc       += vc'
            vc       ./= 2.
            Î²_draw   = convert(Matrix{S}, reshape(Î² + cholesky(vc).L * randn(n_obs * k), k, n_obs)') # change this to avoid transposition, don't need it if change rotation irfs
            Î²_to_TTT = vcat(Î²_draw[:, (1+1):k],
                            hcat(Matrix{S}(I, n_obs * (lags - 1), n_obs * (lags - 1)),
                                 zeros(S, n_obs * (lags - 1), n_obs)))
            if maximum(abs.(eigen(Î²_to_TTT).values)) < 1
                stationary = true
            end
        end
    end

    if standard_orientation
        Î²_draw = convert(Matrix{S}, Î²_draw')
    end

    return Î²_draw, Î£_draw
end

function draw_stationary_VAR(YYYYC::Matrix{S}, XXYYC::Matrix{S}, XXXXC::Matrix{S},
                             TÌ„::Int; standard_orientation::Bool = true, testing::Bool = false,
                             test_Î£_draw::Matrix{S} = Matrix{S}(undef, 0, 0),
                             test_Î²_draw::Vector{S} = Vector{S}(undef, 0)) where {S<:Real}
    # Infer n_obs and lags from population moments
    n_obs = size(YYYYC, 1)
    lags = (size(XXXXC, 1) - 1) / n_obs

    return draw_stationary_VAR(YYYYC, XXYYC, XXXXC, TÌ„, n_obs, lags;
                               standard_orientation = standard_orientation, testing = testing,
                               test_Î£_draw = test_Î£_draw, test_Î²_draw = test_Î²_draw)
end
