<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimation · DSGE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DSGE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DSGE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../learning_how_to_use_dsgejl/">Learning How to Use DSGE.jl</a></li><li><a class="tocitem" href="../model_design/">Model Design</a></li><li><a class="tocitem" href="../special_model_types/">Special Model Types</a></li><li><a class="tocitem" href="../model_implementation_details/">Model Implementation Details</a></li><li><a class="tocitem" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="tocitem" href="../input_data/">Input Data</a></li><li><a class="tocitem" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="tocitem" href="../solving/">Solving the Model</a></li><li class="is-active"><a class="tocitem" href>Estimation</a><ul class="internal"><li><a class="tocitem" href="#Procedure-1"><span>Procedure</span></a></li><li><a class="tocitem" href="#Metropolis-Hastings-Sampler-1"><span>Metropolis-Hastings Sampler</span></a></li><li><a class="tocitem" href="#SMC-Sampler-1"><span>SMC Sampler</span></a></li></ul></li><li><a class="tocitem" href="../forecast/">Forecasting</a></li><li><a class="tocitem" href="../irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../means_bands/">Computing Means and Bands</a></li><li><a class="tocitem" href="../altpolicy/">Alternative Policies</a></li><li><a class="tocitem" href="../scenarios/">Alternative Scenarios</a></li><li><a class="tocitem" href="../forecast_decomposition/">Forecast Decomposition</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="tocitem" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="tocitem" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/docs/src/estimation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="estimation-step-1"><a class="docs-heading-anchor" href="#estimation-step-1">Estimation</a><a class="docs-heading-anchor-permalink" href="#estimation-step-1" title="Permalink"></a></h1><h2 id="Procedure-1"><a class="docs-heading-anchor" href="#Procedure-1">Procedure</a><a class="docs-heading-anchor-permalink" href="#Procedure-1" title="Permalink"></a></h2><p>The goal of the estimation step is to sample from the posterior distribution of the model parameters. DSGE.jl provides two estimation routines. The default is a Metropolis-Hastings sampler to do this, which requires as a proposal covariance matrix and the Hessian matrix corresponding to the posterior mode. The second routine is a Sequential Monte Carlo sampler, which is called from the <a href="https://github.com/FRBNY-DSGE/SMC.jl">SMC.jl</a> package. Both routines implement adaptive proposal densities and parameter blocking.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>The function <code>estimate</code> implements the entire procedure for either routine. Below, we explain the MH algorithm. For documentation of the SMC algorithm, see <a href="https://frbny-dsge.github.io/SMC.jl/latest/">here</a>.</p><p><strong>Main Steps</strong>:</p><ul><li><p><em>Initialization</em>: Read in and transform raw data from <code>save/input_data/</code>. See <a href="../input_data/#input-data-step-1">Input Data</a> for more details.</p></li><li><p><em>Reoptimize parameter vector</em>: The main program will call the <code>csminwel</code> optimization routine (located in <code>csminwel.jl</code>) to find modal parameter estimates.</p></li><li><p><em>Compute Hessian matrix</em>: Computing the Hessian matrix to scale the proposal distribution in the Metropolis-Hastings algorithm.</p></li><li><p><em>Sample from Posterior</em>: Posterior sampling is performed using the Metropolis-Hastings algorithm. A proposal distribution is constructed centered at the posterior mode and with proposal covariance scaled by the inverse of the Hessian matrix. Settings for the number of sampling blocks and the size of those blocks can be altered as described in <a href="../advanced_usage/#editing-extending-model-1">Editing or Extending a Model</a>.</p></li></ul><p><strong>Remark</strong>: For the MH sampler, in addition to saving each <code>mh_thin</code>-th draw of the parameter vector, the estimation program also saves the resulting posterior value and transition equation matrices implied by each draw of the parameter vector. This is to save time in the forecasting step since that code can avoid recomputing those matrices.</p><p>For the SMC sampler, we save a <code>jld2</code> file containing a <code>Cloud</code> object which holds any relevant information about the particles approximating the posterior, the normalized weights of the particles, and the unnormalized weights of particles. We also save a draw of parameters to an <code>h5</code> file.</p><p>To run the entire procedure, the user simply calls the <code>estimate</code> routine:</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.estimate" href="#DSGE.estimate"><code>DSGE.estimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate(m, data; verbose=:low, proposal_covariance=Matrix())</code></pre><p>Estimate the DSGE parameter posterior distribution.</p><p><strong>Arguments:</strong></p><ul><li><code>m::AbstractDSGEModel</code> or <code>m::AbstractVARModel</code>: model object</li></ul><p><strong>Estimation Settings</strong></p><p>Please see the section on &#39;Estimation Settings&#39; on the &#39;Advanced Usage&#39; page of the online documentation or src/defaults.jl for a full description of all the estimation settings for both the Metropolis-Hastings (MH) and Sequential Monte Carlo (SMC) algorithms. For the latter, also see <code>?DSGE.smc2</code>. Most of the optional and keyword arguments described below are not directly related to the behavior of the sampling algorithms (e.g. tuning, number of samples).</p><p><strong>Optional Arguments:</strong></p><ul><li><code>data</code>: well-formed data as <code>Matrix</code> or <code>DataFrame</code>. If this is not provided, the <code>load_data</code> routine will be executed.</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>verbose::Symbol</code>: The desired frequency of function progress messages printed to standard out.<ul><li><code>:none</code>: No status updates will be reported.</li><li><code>:low</code> (default): Status updates will be provided in csminwel and at each block in Metropolis-Hastings. For SMC&#39;s verbosity settings, see <code>?smc2</code>.</li><li><code>:high</code>: Status updates provided at each iteration in Metropolis-Hastings.</li></ul></li><li><code>proposal_covariance::Matrix = []</code>: Used to test the metropolis_hastings algorithm with a precomputed covariance matrix for the proposal distribution. When the Hessian is singular, eigenvectors corresponding to zero eigenvectors are not well defined, so eigenvalue decomposition can cause problems. Passing a precomputed matrix allows us to ensure that the rest of the routine has not broken.</li><li><code>method::Symbol</code>: The method to use when sampling from the posterior distribution. Can   be either <code>:MH</code> for standard Metropolis Hastings Markov Chain Monte Carlo, or <code>:SMC</code>   for Sequential Monte Carlo. This should be specified by the setting <code>sampling_method</code> in <code>m</code>.</li><li><code>mle = false</code>: Set to true if parameters should be estimated by maximum likelihood directly.   If this is set to true, this function will return after estimating parameters.</li><li><code>sampling = true</code>: Set to false to disable sampling from the posterior.</li><li><code>old_data::Matrix{Float64}</code> = []: A matrix containing the time series of observables of previous data   (with <code>data</code> being the new data) for the purposes of a time tempered estimation   (that is, using the posterior draws from a previous estimation as the initial set   of draws for an estimation with new data). Running a bridge estimation   requires both <code>old_data</code> and <code>old_cloud</code>.</li><li><code>old_cloud::Union{DSGE.ParticleCloud, DSGE.Cloud, SMC.Cloud} = DSGE.Cloud(m, 0)</code>: old Cloud object   used to describe particles from a previous estimation with old data. Running a bridge estimation   requires both <code>old_data</code> and <code>old_cloud</code>. If running a bridge estimation and   no <code>old_cloud</code> is provided, then it will be loaded using   the filepaths in <code>m</code>. If no <code>old_cloud</code> exists, then the bridge estimation will not run.</li><li><code>old_model::Union{AbstractDSGEModel, AbstractVARModel} = m</code>: model object from which we can build   the old log-likelihood function for a time tempered SMC estimation. It should be possible   to evaluate the old log-likelihood given <code>old_data</code> and the current draw of parameters.   This may be nontrivial if, for example, <em>new</em> parameters have been added to <code>m</code> since the old   estimation. In this case, <code>old_model</code> should include the <em>new</em> parameters but still return   the old log-likelihood as the original estimation if given the same <em>old</em> parameters.   By default, we assume the log-likelihood function has not changed   and therefore coincides with the current one.</li><li><code>filestring_addl::Vector{String} = []</code>: Additional strings to add to the file name   of estimation output as a way to distinguish output from each other.</li><li><code>continue_intermediate::Bool = false</code>: set to true if the estimation is starting   from an intermediate stage that has been previously saved.</li><li><code>intermediate_stage_start::Int = 0</code>: number of the stage from which the user wants   to continue the estimation (see <code>continue_intermediate</code>)</li><li><code>save_intermediate::Bool = true</code>: set to true to save intermediate stages when using SMC</li><li><code>intermediate_stage_increment::Int = 10</code>: number of stages that must pass before saving   another intermediate stage.</li><li><code>run_csminwel::Bool = true</code>: by default, csminwel is run after a SMC estimation finishes   to recover the true mode of the posterior. Set to false to avoid this step   (csminwel can take hours for medium-scale DSGE models).</li><li><code>toggle::Bool = true</code>: when regime-switching, several functions assume regimes   are toggled to regime 1. If the likelihood function is not   written to toggle to regime 1 when done, then regime-switching estimation   will not work properly. Set to <code>false</code> to reduce computation time if the   user is certain that the likelihood is written properly.</li><li><code>log_prob_old_data::Float64 = 0.0</code>:Log p(	ilde y) which is the log marginal data density   of the bridge estimation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/estimate/estimate.jl#L1-L79">source</a></section></article><h2 id="Metropolis-Hastings-Sampler-1"><a class="docs-heading-anchor" href="#Metropolis-Hastings-Sampler-1">Metropolis-Hastings Sampler</a><a class="docs-heading-anchor-permalink" href="#Metropolis-Hastings-Sampler-1" title="Permalink"></a></h2><h3 id="Computing-the-Posterior-1"><a class="docs-heading-anchor" href="#Computing-the-Posterior-1">Computing the Posterior</a><a class="docs-heading-anchor-permalink" href="#Computing-the-Posterior-1" title="Permalink"></a></h3><p>In DSGE.jl, the function <code>posterior</code> computes the value of the posterior distribution at a given parameter vector. It calls the <code>likelihood</code> function, which in turn calls the <code>filter</code> routine. See <a href="#Estimation-routines-1">Estimation routines</a> for more details on these functions.</p><p>We implement the Kalman Filter via the <code>filter</code> function to compute the log-likelihood, and add this to the log prior to obtain the log posterior. See <a href="https://github.com/FRBNY-DSGE/StateSpaceRoutines.jl">StateSpaceRoutines.jl</a> for a model-independent implementation of the Kalman filter.</p><h3 id="estimation-reoptimizing-1"><a class="docs-heading-anchor" href="#estimation-reoptimizing-1">Optimizing or Reoptimizing</a><a class="docs-heading-anchor-permalink" href="#estimation-reoptimizing-1" title="Permalink"></a></h3><p>Generally, the user will want to reoptimize the parameter vector (and consequently, calculate the Hessian at this new mode) every time they conduct posterior sampling; that is, when:</p><ul><li>the input data are updated with a new quarter of observations or revised</li><li>the model sub-specification is changed</li><li>the model is derived from an existing model with different equilibrium conditions or measurement equation.</li></ul><p>This behavior can be controlled more finely.</p><h4 id="Reoptimize-from-a-Specified-Starting-Vector-1"><a class="docs-heading-anchor" href="#Reoptimize-from-a-Specified-Starting-Vector-1">Reoptimize from a Specified Starting Vector</a><a class="docs-heading-anchor-permalink" href="#Reoptimize-from-a-Specified-Starting-Vector-1" title="Permalink"></a></h4><p>Reoptimize the model starting from the parameter values supplied in a specified file. Ensure that you supply an HDF5 file with a variable named <code>params</code> that is the correct dimension and data type.</p><pre><code class="language-julia">m = Model990()
params = load_parameters_from_file(m, &quot;path/to/parameter/file.h5&quot;)
update!(m, params)
estimate(m)</code></pre><h4 id="Skip-Reoptimization-Entirely-1"><a class="docs-heading-anchor" href="#Skip-Reoptimization-Entirely-1">Skip Reoptimization Entirely</a><a class="docs-heading-anchor-permalink" href="#Skip-Reoptimization-Entirely-1" title="Permalink"></a></h4><p>You can provide a modal parameter vector and optionally a Hessian matrix calculated at that mode to skip the reoptimization entirely. These values are usually computed by the user previously.</p><p>You can skip reoptimization of the parameter vector entirely.</p><pre><code class="language-julia">m = Model990()
specify_mode!(m, &quot;path/to/parameter/mode/file.h5&quot;)
estimate(m)</code></pre><p>The <code>specify_mode!</code> function will update the parameter vector to the mode and skip reoptimization by setting the <code>reoptimize</code> model setting. Ensure that you supply an HDF5 file with a variable named <code>params</code> that is the correct dimension and data type. (See also the utility function <code>load_parameters_from_file</code>.)</p><h4 id="Random-Walk-Metropolis-Hastings-1"><a class="docs-heading-anchor" href="#Random-Walk-Metropolis-Hastings-1">Random Walk Metropolis-Hastings</a><a class="docs-heading-anchor-permalink" href="#Random-Walk-Metropolis-Hastings-1" title="Permalink"></a></h4><p>For relatively simple problems, a random walk MH sampler is sufficient and avoids unnecessary computations like calculating the Hessian. Suppose we want to estimate all the parameters of a DSGE model <code>m</code>. The following code implements RWMH for <code>m</code>.</p><pre><code class="language-julia">m = Model990()
m &lt;= Setting(:hessian_path, &quot;path/to//matrix/with/right/dimensions/saved/as/mh_hessian.h5&quot;)
estimate(m; proposal_covariance = Matrix{Float64}(I,size(m.parameters)))</code></pre><p>The saved Hessian needs to have the same dimensions as the number of parameters. The simplest option is save an identity matrix. The proposal covariance also needs to have the same dimensions as the number of parameters. If the user does not want to estimate every parameter (i.e. some parameters are fixed), then the user needs to zero out the rows of the proposal covariance that correspond to fixed parameters.</p><h3 id="Calculating-the-Hessian-1"><a class="docs-heading-anchor" href="#Calculating-the-Hessian-1">Calculating the Hessian</a><a class="docs-heading-anchor-permalink" href="#Calculating-the-Hessian-1" title="Permalink"></a></h3><p>By default, <code>estimate</code> will recompute the Hessian matrix. You can skip calculation of the Hessian matrix entirely if you provide a file with a Hessian that has been pre-computed.</p><pre><code class="language-julia">m = Model990()
specify_mode!(m, &quot;path/to/parameter/mode/file.h5&quot;)
specify_hessian(m, &quot;path/to/Hessian/matrix/file.h5&quot;)
estimate(m)</code></pre><p>The <code>specify_hessian</code> function will cause <code>estimate</code> to read in the Hessian matrix rather than calculating it directly.  Ensure that you supply an HDF5 file with a variable named <code>hessian</code> that is the correct dimension and data type. Specifying the Hessian matrix but <em>not</em> the parameter mode results in undefined behavior.</p><p>See [Hessian Approximation] for more details on the Hessian computation.</p><h3 id="Estimation-routines-1"><a class="docs-heading-anchor" href="#Estimation-routines-1">Estimation routines</a><a class="docs-heading-anchor-permalink" href="#Estimation-routines-1" title="Permalink"></a></h3><h4 id="Prior,-Likelihood-and-Posterior-calculations-1"><a class="docs-heading-anchor" href="#Prior,-Likelihood-and-Posterior-calculations-1">Prior, Likelihood and Posterior calculations</a><a class="docs-heading-anchor-permalink" href="#Prior,-Likelihood-and-Posterior-calculations-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.prior" href="#ModelConstructors.prior"><code>ModelConstructors.prior</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>prior(m::AbstractDSGEModel{T})</code></p><p>Calculates log joint prior density of m.parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/estimate/posterior.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.likelihood" href="#DSGE.likelihood"><code>DSGE.likelihood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">likelihood(m::AbstractDSGEModel, data::Matrix{T};
           sampler::Bool = false, catch_errors::Bool = false) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate the DSGE log-likelihood function. Can handle two-part estimation where the observed sample contains both a normal stretch of time (in which interest rates are positive) and a stretch of time in which interest rates reach the zero lower bound. If there is a zero-lower-bound period, then we filter over the 2 periods separately. Otherwise, we filter over the main sample all at once.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The model object</li><li><code>data</code>: matrix of data for observables</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>sampler</code>: Whether metropolis_hastings or smc is the caller. If <code>sampler=true</code>, the   transition matrices for the zero-lower-bound period are returned in a dictionary.</li><li><code>catch_errors</code>: If <code>sampler = true</code>, <code>GensysErrors</code> should always be caught.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/estimate/posterior.jl#L96-L117">source</a></section><section><div><pre><code class="language-none">likelihood(m::AbstractVARModel, data::Matrix{T};
           sampler::Bool = false, catch_errors::Bool = false,
           verbose::Symbol = :high) where {T&lt;:AbstractFloat}</code></pre><p>Evaluate a VAR likelihood function.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The model object</li><li><code>data</code>: matrix of data for observables</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>sampler</code>: Whether metropolis_hastings or smc is the caller. If <code>sampler=true</code>, the   transition matrices for the zero-lower-bound period are returned in a dictionary.</li><li><code>catch_errors</code>: If <code>sampler = true</code>, <code>GensysErrors</code> should always be caught.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/estimate/posterior.jl#L203-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.posterior" href="#ModelConstructors.posterior"><code>ModelConstructors.posterior</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">posterior(m::Union{AbstractDSGEModel{T},AbstractVARModel{T}}, data::Matrix{T};
          sampler::Bool = false, catch_errors::Bool = false,
          φ_smc::Float64 = 1) where {T&lt;:AbstractFloat}</code></pre><p>Calculates and returns the log of the posterior distribution for <code>m.parameters</code>:</p><pre><code class="language-none">log posterior  = log likelihood + log prior + const
log Pr(Θ|data) = log Pr(data|Θ) + log Pr(Θ) + const</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: the model object</li><li><code>data</code>: matrix of data for observables</li></ul><p><strong>Optional Arguments</strong></p><p>-<code>sampler</code>: Whether metropolis<em>hastings or smc is the caller. If <code>sampler=true</code>,     the log likelihood and the transition matrices for the zero-lower-bound     period are also returned. -`catch</em>errors<code>: Whether to catch errors of type</code>GensysError<code>or</code>ParamBoundsError`</p><ul><li><code>φ_smc</code>: a tempering factor to change the relative weighting of the prior and    the likelihood when calculating the posterior. It is used primarily in SMC.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/estimate/posterior.jl#L10-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.posterior!" href="#ModelConstructors.posterior!"><code>ModelConstructors.posterior!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">posterior!(m::Union{AbstractDSGEModel{T},AbstractVARModel{T}},
           parameters::Vector{T}, data::Matrix{T};
           sampler::Bool = false, catch_errors::Bool = false,
           ϕ_smc::Float64 = 1., toggle::Bool = true) where {T&lt;:AbstractFloat}</code></pre><p>Evaluates the log posterior density at <code>parameters</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The model object</li><li><code>parameters</code>: New values for the model parameters</li><li><code>data</code>: Matrix of input data for observables</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>sampler</code>: Whether metropolis_hastings or smc is the caller. If <code>sampler=true</code>,    the log likelihood and the transition matrices for the zero-lower-bound    period are also returned.</li><li><code>catch_errors</code>: Whether to catch errors of type <code>GensysError</code> or <code>ParamBoundsError</code>    If <code>sampler = true</code>, both should always be caught.</li><li><code>ϕ_smc</code>: a tempering factor to change the relative weighting of the prior and    the likelihood when calculating the posterior. It is used primarily in SMC.</li><li><code>toggle</code>: if true, we call <code>ModelConstructors.toggle_regime!(values)</code> before   updating any values to ensure the <code>value</code> field of the parameters in <code>values</code>   correspond to regime 1 values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/estimate/posterior.jl#L47-L73">source</a></section></article><h4 id="Optimization-1"><a class="docs-heading-anchor" href="#Optimization-1">Optimization</a><a class="docs-heading-anchor-permalink" href="#Optimization-1" title="Permalink"></a></h4><p>See <a href="../algorithms/#algs-optimization-1">Optimization</a></p><h4 id="Full-Estimation-Routine-1"><a class="docs-heading-anchor" href="#Full-Estimation-Routine-1">Full Estimation Routine</a><a class="docs-heading-anchor-permalink" href="#Full-Estimation-Routine-1" title="Permalink"></a></h4><p>See <a href="#DSGE.estimate"><code>estimate</code></a></p><h4 id="Output-Analysis-1"><a class="docs-heading-anchor" href="#Output-Analysis-1">Output Analysis</a><a class="docs-heading-anchor-permalink" href="#Output-Analysis-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="DSGE.compute_Eλ-Union{Tuple{T}, Tuple{PoolModel{T},Int64,Array{T,1}}, Tuple{PoolModel{T},Int64,Array{T,1},Array{T,2}}, Tuple{PoolModel{T},Int64,Array{T,1},Array{T,2},Array{T,1}}} where T&lt;:AbstractFloat" href="#DSGE.compute_Eλ-Union{Tuple{T}, Tuple{PoolModel{T},Int64,Array{T,1}}, Tuple{PoolModel{T},Int64,Array{T,1},Array{T,2}}, Tuple{PoolModel{T},Int64,Array{T,1},Array{T,2},Array{T,1}}} where T&lt;:AbstractFloat"><code>DSGE.compute_Eλ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_Eλ(m, h, λvec, θmat = [], weights = [];
    current_period = true, parallel = true) where T&lt;:AbstractFloat</code></pre><p>Computes and samples from the conditional density p(λ<em>t|θ, I</em>t, P) for particle in <code>θs</code>, which represents the posterior distribution.</p><p><strong>Inputs</strong></p><ul><li><code>m::PoolModel{T}</code>: <code>PoolModel</code> object</li><li><code>h::Int64</code>: forecast horizon</li><li><code>λvec::Vector{T}</code>: vector of particles of λ samples from (θ,λ) joint distribution</li><li>`θmat::Matrix{T}&#39;: matrix of posterior parameter samples</li><li><code>weights::Vector{T}</code>: weights of λ particles, defaults to equal weights</li></ul><p><strong>Keyword Argument</strong></p><ul><li><code>current_period::Bool</code>: compute Eλ for current period t</li><li><code>parallel::Bool</code>: use parallel computing to compute and sample λ</li><li><code>get_dpp_pred_dens::Bool</code>: compute predictive densities according to dynamic prediction pools</li></ul><p><strong>Outputs</strong></p><ul><li><code>λhat_tplush::Float64</code>: E[λ<em>{t+h|t} | I</em>t^P, P]</li><li><code>λhat_t::Float64</code>: E[λ<em>{t|t} | I</em>t^P, P]</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L1063-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.find_density_bands-Union{Tuple{T}, Tuple{AbstractArray,Array{T,1}}} where T&lt;:AbstractFloat" href="#DSGE.find_density_bands-Union{Tuple{T}, Tuple{AbstractArray,Array{T,1}}} where T&lt;:AbstractFloat"><code>DSGE.find_density_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_density_bands(draws::Matrix, percents::Vector{T}; minimize::Bool=true) where T&lt;:AbstractFloat</code></pre><p>Returns a <code>2</code> x <code>cols(draws)</code> matrix <code>bands</code> such that <code>percent</code> of the mass of <code>draws[:,i]</code> is above <code>bands[1,i]</code> and below <code>bands[2,i]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>draws</code>: Matrix of parameter draws (from Metropolis-Hastings, for example)</li><li><code>percent</code>: percent of data within bands (e.g. .9 to get 90% of mass within bands)</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>minimize</code>: if <code>true</code>, choose shortest interval, otherwise just chop off lowest and highest (percent/2)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L883-L900">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.find_density_bands-Union{Tuple{T}, Tuple{AbstractArray,T}} where T&lt;:AbstractFloat" href="#DSGE.find_density_bands-Union{Tuple{T}, Tuple{AbstractArray,T}} where T&lt;:AbstractFloat"><code>DSGE.find_density_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_density_bands(draws::Matrix, percent::AbstractFloat; minimize::Bool=true)</code></pre><p>Returns a <code>2</code> x <code>cols(draws)</code> matrix <code>bands</code> such that <code>percent</code> of the mass of <code>draws[:,i]</code> is above <code>bands[1,i]</code> and below <code>bands[2,i]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>draws</code>: <code>ndraws</code> by <code>nperiods</code> matrix of parameter draws (from Metropolis-Hastings, for example)</li><li><code>percent</code>: percent of data within bands (e.g. .9 to get 90% of mass within bands)</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>minimize</code>: if <code>true</code>, choose shortest interval, otherwise just chop off lowest and highest (percent/2)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L800-L817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.load_posterior_moments-Tuple{AbstractDSGEModel}" href="#DSGE.load_posterior_moments-Tuple{AbstractDSGEModel}"><code>DSGE.load_posterior_moments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load_posterior_moments(m; load_bands = true, include_fixed = false)</code></pre><p>Load posterior moments (mean, std) of parameters for a particular sample, and optionally also load 5% and 95% lower and upper bands.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>cloud::ParticleCloud</code>: Optionally pass in a cloud that you want to load the sample from. If the cloud is non-empty then the model object will only be used to find fixed indices and parameter tex labels</li><li><code>load_bands::Bool</code>: Optionally include the 5% and 95% percentiles for the sample of parameters in the returned df</li><li><code>include_fixed::Bool</code>: Optionally include the fixed parameters in the returned df</li><li><code>excl_list::Vector{Symbol}</code>: List parameters by their key that you want to exclude from</li></ul><p>loading</p><p><strong>Outputs</strong></p><ul><li><code>df</code>: A dataframe containing the aforementioned moments/bands</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L22-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.moment_tables-Tuple{AbstractDSGEModel}" href="#DSGE.moment_tables-Tuple{AbstractDSGEModel}"><code>DSGE.moment_tables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">moment_tables(m; percent = 0.90, subset_inds = 1:0, subset_string = &quot;&quot;,
    groupings = Dict{String, Vector{Parameter}}(), use_mode = false,
    tables = [:prior_posterior_means, :moments, :prior, :posterior],
    caption = true, outdir = &quot;&quot;, verbose = :none)</code></pre><p>Computes prior and posterior parameter moments. Tabulates prior mean, posterior mean, and bands in various LaTeX tables. These tables will be saved in <code>outdir</code> if it is nonempty, or else in <code>tablespath(m, &quot;estimate&quot;)</code>.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code>: model object</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>percent::AbstractFloat</code>: the percentage of the mass of draws from Metropolis-Hastings included between the bands displayed in output tables.</li><li><code>subset_inds::AbstractRange{Int64}</code>: indices specifying the draws we want to use</li><li><code>subset_string::String</code>: short string identifying the subset to be appended to the output filenames. If <code>subset_inds</code> is nonempty but <code>subset_string</code> is empty, an error is thrown</li><li><code>groupings::Dict{String, Vector{Parameter}}</code>: see <code>?parameter_groupings</code></li><li><code>use_mode::Bool</code>: use the modal parameters instead of the mean in the prior<em>posterior</em>means table</li><li><code>tables::Vector{Symbol}</code>: which tables to produce</li><li><code>caption::Bool</code>: whether to include table captions</li><li><code>outdir::String</code>: where to save output tables</li><li><code>verbose::Symbol</code>: desired frequency of function progress messages printed to standard out. One of <code>:none</code>, <code>:low</code>, or <code>:high</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L170-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.sample_λ-Union{Tuple{S}, Tuple{PoolModel{S},Array{S,2},Array{S,2}}, Tuple{PoolModel{S},Array{S,2},Array{S,2},Int64}} where S&lt;:AbstractFloat" href="#DSGE.sample_λ-Union{Tuple{S}, Tuple{PoolModel{S},Array{S,2},Array{S,2}}, Tuple{PoolModel{S},Array{S,2},Array{S,2},Int64}} where S&lt;:AbstractFloat"><code>DSGE.sample_λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_λ(m, pred_dens, θs, T = -1; parallel = true) where S&lt;:AbstractFloat
sample_λ(m, pred_dens, T = -1; parallel = true) where S&lt;:AbstractFloat</code></pre><p>Computes and samples from the conditional density p(λ<em>t|θ, I</em>t, P) for particle in <code>θs</code>, which represents the posterior distribution. The sampled λ particles represent the posterior distribution p(λ<em>{t|t} | I</em>t, P).</p><p>If no posterior distribution is passed in, then the function computes the distribution of λ_{t|t} for a static pool.</p><p><strong>Inputs</strong></p><ul><li><code>m::PoolModel{S}</code>: <code>PoolModel</code> object</li><li><code>pred_dens::Matrix{S}</code>: matrix of predictive densities</li><li><code>θs::Matrix{S}</code>: matrix of particles representing posterior distribution of θ</li><li><code>T::Int64</code>: final period for tempered particle filter</li></ul><p>where <code>S&lt;:AbstractFloat</code>.</p><p><strong>Keyword Argument</strong></p><ul><li><code>parallel::Bool</code>: use parallel computing to compute and sample draws of λ</li></ul><p><strong>Outputs</strong></p><ul><li><code>λ_sample::Vector{Float64}</code>: sample of draws of λs; together with (θ,λ) represents a joint density</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L947-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.moments-Tuple{ModelConstructors.Parameter}" href="#DSGE.moments-Tuple{ModelConstructors.Parameter}"><code>DSGE.moments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">moments(θ::Parameter)</code></pre><p>If θ&#39;s prior is a <code>RootInverseGamma</code>, τ and ν. Otherwise, returns the mean and standard deviation of the prior. If θ is fixed, returns <code>(θ.value, 0.0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L293-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.posterior_table-Tuple{AbstractDSGEModel,Array{T,1} where T,Array{T,2} where T}" href="#DSGE.posterior_table-Tuple{AbstractDSGEModel,Array{T,1} where T,Array{T,2} where T}"><code>DSGE.posterior_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">posterior_table(m, post_means, post_bands; percent = 0.9, subset_string = &quot;&quot;,
    groupings = Dict{String, Vector{Parameter}}(), caption = true, outdir = &quot;&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L485-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.prior_posterior_moments_table-Tuple{AbstractDSGEModel,Array{T,1} where T,Array{T,2} where T}" href="#DSGE.prior_posterior_moments_table-Tuple{AbstractDSGEModel,Array{T,1} where T,Array{T,2} where T}"><code>DSGE.prior_posterior_moments_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prior_posterior_moments_table(m, post_means, post_bands; percent = 0.9,
    subset_string = &quot;&quot;, groupings = Dict{String, Vector{Parameter}}(),
    caption = true, outdir = &quot;&quot;)</code></pre><p>Produces a table of prior means, prior standard deviations, posterior means, and 90% bands for posterior draws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L610-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.prior_posterior_table-Tuple{AbstractDSGEModel,Array{T,1} where T}" href="#DSGE.prior_posterior_table-Tuple{AbstractDSGEModel,Array{T,1} where T}"><code>DSGE.prior_posterior_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prior_posterior_table(m, post_values; subset_string = &quot;&quot;,
    groupings = Dict{String, Vector{Parameter}}(), use_mode = false,
    caption = true, outdir = &quot;&quot;)</code></pre><p>Produce a table of prior means and posterior means or mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L716-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.prior_table-Tuple{AbstractDSGEModel}" href="#DSGE.prior_table-Tuple{AbstractDSGEModel}"><code>DSGE.prior_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prior_table(m; subset_string = &quot;&quot;, groupings = Dict{String, Vector{Parameter}}(),
    caption = true, outdir = &quot;&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L329-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.propagate_λ-Union{Tuple{T}, Tuple{T,Int64,PoolModel}, Tuple{T,Int64,PoolModel,Any}} where T&lt;:AbstractFloat" href="#DSGE.propagate_λ-Union{Tuple{T}, Tuple{T,Int64,PoolModel}, Tuple{T,Int64,PoolModel,Any}} where T&lt;:AbstractFloat"><code>DSGE.propagate_λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">propgate_λ(λvec, h, m, θvec) where T&lt;:AbstractFloat</code></pre><p>Propagates a λ particle h periods forward.</p><p><strong>Inputs</strong></p><ul><li><code>λ::T</code>: λ sample from (θ,λ) joint distribution</li><li><code>h::Int64</code>: forecast horizon</li><li><code>m::PoolModel</code>: PoolModel object</li><li><code>θvec::Vector{T}</code>: optional vector of parameters to update PoolModel</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/45c26624ec225d6d355219cde71638f6171694ad/src/analysis/moments.jl#L1145-L1160">source</a></section></article><h2 id="SMC-Sampler-1"><a class="docs-heading-anchor" href="#SMC-Sampler-1">SMC Sampler</a><a class="docs-heading-anchor-permalink" href="#SMC-Sampler-1" title="Permalink"></a></h2><p>See <a href="https://frbny-dsge.github.io/SMC.jl/latest/">here</a> for the settings adjusting the SMC algorithm. To use these with a DSGE model object, either add them after the definition of a model object as a <code>Setting</code> or add them directly in the definition of the model type. For example, the following code sets the sampler as SMC and the number of particles used by SMC as 10,000:</p><pre><code class="language-julia">m = Model990()
m &lt;= Setting(:sampling_method, :SMC)
m &lt;= Setting(:n_particles, 10000)</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>We document the details of implementing adaptive proposal densities and   parameter blocking in <a href="https://github.com/FRBNY-DSGE/SMC.jl">SMC.jl</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solving/">« Solving the Model</a><a class="docs-footer-nextpage" href="../forecast/">Forecasting »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 November 2021 22:20">Tuesday 23 November 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
