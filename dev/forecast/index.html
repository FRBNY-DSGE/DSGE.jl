<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Forecasting · DSGE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DSGE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DSGE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../learning_how_to_use_dsgejl/">Learning How to Use DSGE.jl</a></li><li><a class="tocitem" href="../model_design/">Model Design</a></li><li><a class="tocitem" href="../special_model_types/">Special Model Types</a></li><li><a class="tocitem" href="../model_implementation_details/">Model Implementation Details</a></li><li><a class="tocitem" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="tocitem" href="../input_data/">Input Data</a></li><li><a class="tocitem" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="tocitem" href="../solving/">Solving the Model</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li class="is-active"><a class="tocitem" href>Forecasting</a><ul class="internal"><li><a class="tocitem" href="#Procedure-1"><span>Procedure</span></a></li><li><a class="tocitem" href="#Forecast-Outputs-1"><span>Forecast Outputs</span></a></li><li><a class="tocitem" href="#Preparing-Forecast-Inputs-1"><span>Preparing Forecast Inputs</span></a></li><li><a class="tocitem" href="#Computing-Forecast-Outputs-1"><span>Computing Forecast Outputs</span></a></li><li><a class="tocitem" href="#Saving-Forecast-Outputs-1"><span>Saving Forecast Outputs</span></a></li><li><a class="tocitem" href="#Forecasting-Functions-1"><span>Forecasting Functions</span></a></li></ul></li><li><a class="tocitem" href="../irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../means_bands/">Computing Means and Bands</a></li><li><a class="tocitem" href="../altpolicy/">Alternative Policies</a></li><li><a class="tocitem" href="../scenarios/">Alternative Scenarios</a></li><li><a class="tocitem" href="../forecast_decomposition/">Forecast Decomposition</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="tocitem" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="tocitem" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Forecasting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Forecasting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/docs/src/forecast.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="forecast-step-1"><a class="docs-heading-anchor" href="#forecast-step-1">Forecasting</a><a class="docs-heading-anchor-permalink" href="#forecast-step-1" title="Permalink"></a></h1><p>This page describes forecasting without regime-switching. Click <a href="../advanced_usage/#regime-switch-forecast-1">here</a> to learn about forecasting with regime-switching.</p><h2 id="Procedure-1"><a class="docs-heading-anchor" href="#Procedure-1">Procedure</a><a class="docs-heading-anchor-permalink" href="#Procedure-1" title="Permalink"></a></h2><p>In the forecast step, we compute smoothed histories, forecast, compute shock decompositions, and compute impulse response functions (IRFs) for states, observables, shocks, and pseudo-observables. To run a forecast on one combination of input parameter type (e.g. modal parameters or full-distribution) and conditional type, call <code>forecast_one</code>. The forecast output is written to the saveroot specified by the model object and can be loaded with the function <code>read_forecast_output</code>.</p><p><strong>Main Steps:</strong></p><ul><li><p><em>Prepare forecast inputs:</em> Add required output types, load data, and load draws of parameter vectors saved from the estimation step.</p></li><li><p><em>Compute forecast outputs:</em> Carry out desired combination of smoothing, forecasting, computing shock decompositions, and computing IRFs. See <a href="#Forecast-Outputs-1">Forecast Outputs</a> for a list of possible forecast outputs.</p></li><li><p><em>Save forecast outputs:</em> Save each forecast output as an array to its own file, along with some metadata.</p></li></ul><article class="docstring"><header><a class="docstring-binding" id="DSGE.forecast_one" href="#DSGE.forecast_one"><code>DSGE.forecast_one</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">forecast_one(m, input_type, cond_type, output_vars; df = DataFrame(),
    subset_inds = 1:0, forecast_string = &quot;&quot;, verbose = :low, ...)</code></pre><p>Compute and save <code>output_vars</code> for input draws given by <code>input_type</code> and conditional data case given by <code>cond_type</code>.</p><p><strong>Inputs</strong></p><ul><li><p><code>m::AbstractDSGEModel</code>: model object</p></li><li><p><code>input_type::Symbol</code>: one of:</p></li></ul><pre><code class="language-none">  - `:mode`: forecast using the modal parameters only
  - `:mean`: forecast using the mean parameters only
  - `:init`: forecast using the initial parameter values only
  - `:full`: forecast using all parameters (full distribution)
  - `:subset`: forecast using a well-defined user-specified subset of draws</code></pre><ul><li><code>cond_type::Symbol</code>: one of:</li></ul><pre><code class="language-none">  - `:none`: no conditional data
  - `:semi`: use &quot;semiconditional data&quot; - average of quarter-to-date
    observations for high frequency series
  - `:full`: use &quot;conditional data&quot; - semiconditional plus nowcasts for
    desired observables</code></pre><ul><li><code>output_vars::Vector{Symbol}</code>: vector of desired output variables. See <code>?forecast_one_draw</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>df::DataFrame</code>: Historical data. If <code>cond_type in [:semi, :full]</code>, then the  final row of <code>df</code> should be the period containing conditional data. If not  provided, will be loaded using <code>load_data</code> with the appropriate <code>cond_type</code></p></li><li><p><code>subset_inds::AbstractRange{Int64}</code>: indices specifying the draws we want to use. If a more sophisticated selection criterion is desired, the user is responsible for determining the indices corresponding to that criterion. If <code>input_type</code> is not <code>subset</code>, <code>subset_inds</code> will be ignored</p></li><li><p><code>forecast_string::String</code>: short string identifying the subset to be appended to the output filenames. If <code>input_type = :subset</code> and <code>forecast_string</code> is empty, an error is thrown.</p></li><li><p><code>only_filter::Bool</code>: do not run the smoother and only run the filter. This limits the number of output variables which can be calculated.</p></li><li><p><code>verbose::Symbol</code>: desired frequency of function progress messages printed to standard out. One of <code>:none</code>, <code>:low</code>, or <code>:high</code>.</p></li><li><p><code>check_empty_columns::Bool = true</code>: check empty columns or not when loading data (if <code>df</code> is empty)</p></li><li><p><code>bdd_fcast::Bool = true</code>: are we computing the bounded forecasts or not?</p></li><li><p><code>params::AbstractArray{Float64} = Vector{Float64}(undef, 0)</code>: parameter draws for the forecast.    If empty, then we load draws from estimation files implied by the settings in <code>m</code>.</p></li><li><p><code>zlb_method::Symbol</code>: method for enforcing the zero lower bound. Defaults to <code>:shock</code>,   meaning we use a monetary policy shock to enforce the ZLB.</p><p>Other available methods:</p><ol><li><code>:temporary_altpolicy</code> -&gt; use a temporary alternative policy to enforce the ZLB.</li></ol></li><li><p><code>rerun_smoother::Bool = false</code>: if true, rerun the conditional forecast when automatically enforcing   the ZLB as a temporary alternative policy.</p></li><li><p><code>nan_endozlb_failures::Bool = false</code>: if true, failures of an endogenous ZLB (when implemented   as a temporary policy) will be handled by throwing NaNs instead of using   unanticipated monetary policy shocks.</p></li><li><p><code>set_regime_vals_altpolicy::Function</code>: <code>Function</code> that adds new regimes to parameters when   using temporary alternative policies (if needed). Defaults to identity (which does nothing)   This function should take as inputs the model object <code>m</code> and the total number of regimes   (after adding the required temporary regimes), i.e. <code>set_regime_vals_altpolicy(m, n)</code>. It should then   set up regime-switching parameters for these new additional regimes.</p></li><li><p><code>set_info_sets_altpolicy::Function = auto_temp_altpolicy_info_set</code>: <code>Function</code> that automatically updates   the <code>tvis_information_set</code>, e.g. when <code>zlb_method = :temporary_altpolicy</code>.</p></li><li><p><code>update_regime_eqcond_info!::Function = (x1, x2, x3, x4) -&gt;   default_update_regime_eqcond_info(x1, x2, x3, x4, alternative_policy(m)</code>: <code>Function</code> that automatically   updates the setting <code>:regime_eqcond_info</code>. The arguments of <code>update_regime_eqcond_info!</code> should be (in order)   <code>m::AbstractDSGEModel</code>, <code>eqcond_dict::AbstractDict{Int64, EqcondEntry}</code>, <code>zlb_start_regime::Int64</code>,   and <code>liftoff_regime::Int64</code>. The last two arguments are the regime numbers of the first regime for which   the ZLB applies and the regime after the ZLB ends, respectively.   The <code>eqcond_dict</code> argument should specify the <code>EqcondEntry</code> during the historical/conditional horizon regime   (if it is desired) but can otherwise be empty. This function should then update <code>eqcond_dict</code>   in place to implement a temporary ZLB and any other permanent alternative policies/regime-switching   in the forecast horizon (after the conditional horizon).   The user should also be careful and make sure <code>update_regime_eqcond_info!</code> handles imperfect awareness properly   if they want to implement an imperfectly credible ZLB. For an example, see <code>?default_update_regime_eqcond_info</code>.</p></li><li><p><code>show_failed_percent::Bool = false</code>: prints out the number of failed forecasts, which are returned as NaNs.   These may occur when the ZLB is not enforced, for example.</p></li><li><p><code>pegFFR::Bool = false</code>: peg the nominal FFR at the value specified by <code>FFRpeg</code></p></li><li><p><code>FFRpeg::Float64 = -0.25/4</code>: value of the FFR peg</p></li><li><p><code>H::Int = 4</code>: number of horizons for which the FFR is pegged</p></li><li><p><code>testing_carer_kohn::Bool = false</code>: whether to create a file storing some property of Σ in Carter Kohn</p></li></ul><p><strong>Outputs</strong></p><p>None. Output is saved to files returned by <code>get_forecast_output_files(m, input_type, cond_type, output_vars)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/drivers.jl#L411-L508">source</a></section></article><p>For example, to do an unconditional forecast of states and observables using the modal parameters, call:</p><pre><code class="language-julia">m = AnSchorfheide()
forecast_one(m, :mode, :none, [:forecaststates, forecastobs])</code></pre><p><strong>Full-Distribution Forecasts:</strong></p><p>Full-distribution forecasts are computed in blocks. The size of each block defaults to 5000 draws (before thinning by <code>get_setting(m, :forecast_jstep)</code>), but can be set using the <code>:forecast_block_size</code> <code>Setting</code>. For each block, draws are read in on the originator process, then computation proceeds in parallel using <code>pmap</code>. When all draws in the block are finished, the forecast outputs are reassembled on the originator process and appended to the HDF5 dataset in their respective output files.</p><p>To fully take advantage of the parallelization, the user is responsible for adding processes before calling <code>forecast_one</code>, either by calling <code>addprocs</code> or using one of the functions defined in <a href="https://github.com/JuliaParallel/ClusterManagers.jl">ClusterManagers.jl</a>. For example, to run a full-distribution unconditional forecast using 10 processes:</p><pre><code class="language-julia">my_procs = addprocs(10)
@everywhere using DSGE

m = AnSchorfheide()
forecast_one(m, :full, :none, [:forecaststates, forecastobs])

rmprocs(my_procs)</code></pre><p>Notice that it is necessary to load DSGE on all processes using <code>@everywhere using DSGE</code> before calling <code>forecast_one</code>. It is also sometimes necessary to load OrderedCollections on all processes using <code>@everywhere using OrderedCollections</code>.</p><p>By default, full-distribution forecasts start from the first block. However, if you want to start the forecast from a later block, you can also do so. For example:</p><pre><code class="language-julia">m &lt;= Setting(:forecast_start_block, 2,
    &quot;Block at which to resume forecasting (possibly null)&quot;)</code></pre><h2 id="Forecast-Outputs-1"><a class="docs-heading-anchor" href="#Forecast-Outputs-1">Forecast Outputs</a><a class="docs-heading-anchor-permalink" href="#Forecast-Outputs-1" title="Permalink"></a></h2><p>A forecast output (i.e. an <code>output_var</code>) is a combination of what we call a &quot;product&quot; and a &quot;class&quot;. The possible classes are states (<code>:states</code>), observables (<code>:obs</code>), pseudo-observables (<code>:pseudo</code>), and standardized (<code>:stdshocks</code>) and unstandardized shocks (<code>:shocks</code>). The possible forecast products are:</p><ul><li><p>Smoothed histories (<code>:hist</code>): use the smoother specified by <code>forecast_smoother(m)</code> to get smoothed histories of each class.</p></li><li><p>Forecasts (<code>:forecast</code>): iterate the state space forward from the last filtered state, either using a specified set of shock innovations or by drawing these from a distribution. Forecasts in which we enforce the zero lower bound are denoted as <code>:bddforecast</code>.</p></li><li><p>Shock decompositions (<code>:shockdec</code>): decompose a forecast into the contributions from each individual shock (e.g. TFP or monetary policy) or from groups of shocks by exploiting the linearity of the state space system. Starting from an initial state of zero, iterate the state space forward from the first historical period up through the last forecast horizon. To infer the contributions of shocks, use the smoothed historical shocks for one shock at a time during the historical periods. If a modal shock decomposition is computed, then we assume no shocks occur during the forecast periods. If a full-distribution shock decomposition is computed, then we allow shocks to occur during the forecast periods.</p></li><li><p>Deterministic trends (<code>:dettrend</code>): iterate the state space forward from the first historical state up through the last forecast horizon without any shocks.</p></li><li><p>Trends (<code>:trend</code>): for each class, just the constant term in that class&#39;s equation, i.e. the <code>CCC</code> vector from the transition equation for states, the <code>DD</code> vector from the measurement equation for observables, and the <code>DD_pseudo</code> vector from the pseuodo-measurement equation for pseudo-observables.</p></li><li><p>IRFs (<code>:irf</code>): see <a href="https://en.wikipedia.org/wiki/Impulse_response">Impulse response</a>. Our IRFs are in response to a shock of size -1 standard deviation.</p></li></ul><p>An <code>output_var</code> is then just a <code>Symbol</code> with a product and class concatenated, e.g. <code>:histstates</code> for smoothed historical states.</p><p>It is not necessary to compute all forecast outputs in one call to <code>forecast_one</code>. Which steps are run depends on which <code>output_vars</code> are passed in. Most users will just want to calculate <code>:forecastobs</code>, <code>:histobs</code>, <code>:forecastpseudo</code>, and <code>:histpseudo</code>.</p><h3 id="calc-shock-dec-1"><a class="docs-heading-anchor" href="#calc-shock-dec-1">Calculating Shock Decompositions</a><a class="docs-heading-anchor-permalink" href="#calc-shock-dec-1" title="Permalink"></a></h3><p>The user should note that shock decompositions <strong>are not</strong> the same thing as forecast decompositions in DSGE.jl. The former decomposes a forecast into the contributions of individual or groups of shocks. The latter decomposes the change between two different forecasts into &quot;data revision&quot;, &quot;news&quot; and &quot;re-estimation&quot; components.</p><p>If the user wants to plot shock decompositions to decompose a forecast&#39;s deviations from trend into the contributions of individual or groups of shocks, then the user needs to calculate the <code>shockdec</code>, <code>detttrend</code>, and <code>trend</code> output variables. Otherwise, the plotting script <code>plot_shock_decompositions</code> will fail.</p><p>Finally, note that full-distribution shock decompositions are very memory intensive. For <code>Model1002</code>, we typically need 30GB-40GB using the default settings. To avoid memory problems, the user should decrease the setting <code>:forecast_block_size</code> to a smaller number than the default 5000. A smaller block size means that fewer draws from the posterior are loaded into memory at any one time, hence the size of the matrices associated with shock decompositions will also be smaller.</p><h2 id="Preparing-Forecast-Inputs-1"><a class="docs-heading-anchor" href="#Preparing-Forecast-Inputs-1">Preparing Forecast Inputs</a><a class="docs-heading-anchor-permalink" href="#Preparing-Forecast-Inputs-1" title="Permalink"></a></h2><p><strong>Adding Required <code>output_var</code>s:</strong></p><p>The user specifies what output to compute by passing a <code>Vector{Symbol}</code> of correctly named output variables into <code>forecast_one</code>. Underneath the hood, we will add any additional output variables that are required to complete a forecast using <code>add_requisite_output_vars</code>:</p><ul><li>If <code>:forecast&lt;class&gt;</code> is in <code>output_vars</code>, then <code>:bddforecast&lt;class&gt;</code> is also added. Hence we always forecast both with and without enforcing the ZLB.</li><li>If <code>:shockdec&lt;class&gt;</code> is in <code>output_vars</code>, then <code>:dettrend&lt;class&gt;</code> and <code>:trend&lt;class&gt;</code> are also added. This is because to plot shock decompositions, we also need the trend and the deterministic trend.</li></ul><p><strong>Loading Data:</strong></p><p>This is done the usual way, using <code>load_data</code> with the appropriate <code>cond_type</code>.</p><p>Note that if you are running a conditional forecast, then you should check that the appropriate observables are found in <code>cond_full_names(m)</code> and/or <code>cond_semi_names(m)</code>. If the observables on which you are conditioning do not match the ones found in these settings exactly, then conditional forecasting will not generate the results you want. To change these observables to, for example, condition on <code>custom_obs1</code> and <code>custom_obs2</code>, add the line</p><pre><code class="language-none">m &lt;= Setting(:cond_full_names, [custom_obs1, custom_obs2])</code></pre><p>to your script for full conditional forecasts. The syntax is similar for semi-conditional forecasts. If you have already created a conditional dataset successfully, then you should be sure to re-create the data set by running</p><pre><code class="language-none">load_data(m; try_disk = false, cond_type = cond_type)</code></pre><p>If you do not have <code>try_disk = false</code>, then the code may load a saved data set that does not have the conditional observables you want to use.</p><p><strong>Loading Draws:</strong></p><p>By default, the draws are loaded from the file whose path is given by <code>get_forecast_input_file</code>. However, you can directly pass a matrix of posterior parameter draws or a vector of the modal parameters via the keyword argument <code>params</code> for <code>forecast_one</code>, or you can override the default input file for a given input type by adding entries to the <code>Dict{Symbol, ASCIIString}</code> returned from <code>forecast_input_file_overrides(m)</code>. For example:</p><pre><code class="language-julia">overrides = forecast_input_file_overrides(m)
overrides[:mode] = &quot;path/to/input/file.h5&quot;</code></pre><p>Note that <code>load_draws</code> expects an HDF5 dataset called either <code>params</code> (for <code>input_type in [:mode, :mean]</code>) or <code>mhparams</code> (for <code>input_type in [:full, :subset]</code>) if the sampling method is <code>:MH</code>. If the sampling method is <code>:SMC</code>, then <code>load_draws</code> expects a jld2 file which has a variable named <code>cloud</code>.</p><h2 id="Computing-Forecast-Outputs-1"><a class="docs-heading-anchor" href="#Computing-Forecast-Outputs-1">Computing Forecast Outputs</a><a class="docs-heading-anchor-permalink" href="#Computing-Forecast-Outputs-1" title="Permalink"></a></h2><p>For each draw of parameters, the forecast calculations are run by the lower-level function <code>forecast_one_draw</code>.</p><p>This function is also useful on its own when the user wants to run a single-draw forecast without writing the output to data. A common use case is running experiments with different forecast specifications and/or alternative policy rules. Given the appropriate inputs, <code>forecast_one_draw</code> will return a <code>Dict</code> whose keys are the names of output variables (e.g. <code>:forecastobs</code>) and values are the corresponding matrices. This function does not perform transformations, so the units of the output are all model units, which are typically at the quarterly frequency, such as quarterly per-capita GDP growth.</p><p>The computations that <code>forecast_one_draw</code> can run are:</p><p><strong>Smoothing:</strong></p><p>Smoothing is necessary if either:</p><ul><li>You explicitly want the smoothed histories, or</li><li>You want to compute shock decompositions or deterministic trends, which use the smoothed historical shocks</li></ul><p>It is not necessary to keep track of these cases, however - <code>forecast_one</code> will deduce from the specified <code>output_vars</code> whether or not it is necessary to filter and smooth in order to produce your <code>output_vars</code>.</p><p><strong>Forecasting:</strong></p><p>Forecasting begins from the last filtered historical state, which is obtained from the Kalman filter. <code>forecast</code> accepts a keyword argument <code>enforce_zlb</code>, which indicates whether to enforce the zero lower bound. If <code>enforce_zlb = true</code>, then if in a given period, the forecasted interest rate goes below <code>forecast_zlb_value(m)</code>, we solve for the interest rate shock necessary to push it up to the ZLB. A forecast in which the ZLB is enforced corresponds to the product <code>:bddforecast</code>.</p><p><strong>Shock Decompositions, Deterministic Trends, and Trends:</strong></p><p>Since shock decompositions have an additional dimension (e.g. <code>nstates</code> x <code>nperiods</code> x <code>nshocks</code> for a single draw of state shock decompositions, compared to <code>nstates</code> x <code>nperiods</code> for a single draw of forecasted states), we usually wish to truncate some periods before returning. This behavior is governed by the <code>Settings</code> <code>:shockdec_starttdate</code> and <code>:shockdec_enddate</code>, which are of type <code>Nullable{Date}</code>.</p><p>Deterministic trends are also saved only for <code>date_shockdec_start(m)</code> and <code>date_shockdec_end(m)</code>. Trends are not time-dependent.</p><p>Note that shock decompositions are memory intensive. For a typical forecast of <code>Model1002</code> without shock decompositions, only 1-2GB of memory are needed. For a forecast with shock decompositions, roughtly 14-16GB will be needed.</p><p><strong>Impulse Response Functions:</strong></p><p>Like shock decompositions, IRFs have three dimensions (e.g. <code>nstates</code> x <code>nperiods</code> x <code>nshocks</code>) for each draw.</p><h2 id="Saving-Forecast-Outputs-1"><a class="docs-heading-anchor" href="#Saving-Forecast-Outputs-1">Saving Forecast Outputs</a><a class="docs-heading-anchor-permalink" href="#Saving-Forecast-Outputs-1" title="Permalink"></a></h2><p>Forecast outputs are saved in the location specified by <code>get_forecast_output_files(m)</code>, which is typically a subdirectory of <code>saveroot(m)</code>. Each <code>output_var</code> is saved in its own JLD file, which contains the following datasets:</p><ul><li><p><code>arr::Array</code>: actual array of forecast outputs. For trends, this array is of size <code>ndraws</code> x <code>nvars</code>. For histories, forecasts, and deterministic trends, it is <code>ndraws</code> x <code>nvars</code> x <code>nperiods</code>. For shock decompositions and IRFs, it is <code>ndraws</code> x <code>nvars</code> x <code>nperiods</code> x <code>nshocks</code>. (In all of these, <code>nvars</code> refers to the number of variables of the output class.)</p></li><li><p><code>date_indices::Dict{Date, Int}</code>: maps <code>Date</code>s to their indices along the <code>nperiods</code> dimension of <code>arr</code>. Not saved for IRFs.</p></li><li><p><code>&lt;class&gt;_names::Dict{Symbol, Int}</code>: maps names of variables of the output class (e.g. <code>:OutputGap</code>) into their indices along the <code>nvars</code> dimension of <code>arr</code>.</p></li><li><p><code>&lt;class&gt;_revtransforms::Dict{Symbol, Symbol}</code>: maps names of variables to the names of the reverse transforms (from model units into plotting units) associated with those variables. For example, <code>pseudoobservable_revtransforms[:π_t] = :quartertoannual</code>.</p></li><li><p><code>shock_names::Dict{Symbol, Int}</code>: for shock decompositions and IRFs only, maps names of shocks into their indices along the <code>nshocks</code> dimension of <code>arr</code>.</p></li></ul><p>Some helpful functions for getting file names, as well as reading and writing forecast outputs, include:</p><ul><li><code>get_forecast_input_file</code></li><li><code>get_forecast_filename</code></li><li><code>get_forecast_output_files</code></li><li><code>write_forecast_outputs</code></li><li><code>write_forecast_block</code></li><li><code>write_forecast_metadata</code></li><li><code>read_forecast_metadata</code></li><li><code>read_forecast_output</code></li></ul><h2 id="Forecasting-Functions-1"><a class="docs-heading-anchor" href="#Forecasting-Functions-1">Forecasting Functions</a><a class="docs-heading-anchor-permalink" href="#Forecasting-Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DSGE.decompose_forecast-Union{Tuple{M}, Tuple{M,M,DataFrames.DataFrame,DataFrames.DataFrame,Symbol,Symbol,Symbol,Array{Symbol,1}}} where M&lt;:AbstractDSGEModel" href="#DSGE.decompose_forecast-Union{Tuple{M}, Tuple{M,M,DataFrames.DataFrame,DataFrames.DataFrame,Symbol,Symbol,Symbol,Array{Symbol,1}}} where M&lt;:AbstractDSGEModel"><code>DSGE.decompose_forecast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decompose_forecast(m_new, m_old, df_new, df_old, input_type, cond_new, cond_old,
    classes; verbose = :low, kwargs...)

decompose_forecast(m_new, m_old, df_new, df_old, params_new, params_old,
    cond_new, cond_old, classes; check = false)</code></pre><p>explains the differences between an old forecast and a new forecast by decomposing the differences into three sources:</p><p>(1) Data revisions, (2) News (e.g. new data that has become available since the old forecast), (3) Re-estimation (i.e. changes in model parameters).</p><p>This function <strong>does not</strong> compute which shocks explain a forecast. For example, if you want to know whether TFP or financial shocks drive a given forecast, then you want to compute the shock decomposition output variable (see <code>?shock_decompositions</code>, <code>forecast_one</code>, and <code>compute_meansbands</code>).</p><p>Note that this function currently does not work for a model in which there are changes in the degree of &quot;regime-switching&quot; in the <code>TTT</code>, <code>RRR</code>, <code>CCC</code>, <code>ZZ</code>, and <code>DD</code> matrices, e.g. decomposing the changes in the forecast when the monetary policy rule changes or if a temporary policy is implemented that did not occur in the old forecast.</p><p><strong>Inputs</strong></p><ul><li><code>m_new::M</code> and <code>m_old::M</code> where <code>M&lt;:AbstractDSGEModel</code></li><li><code>df_new::DataFrame</code> and <code>df_old::DataFrame</code></li><li><code>cond_new::Symbol</code> and <code>cond_old::Symbol</code></li><li><code>classes::Vector{Symbol}</code>: some subset of <code>[:states, :obs, :pseudo]</code></li></ul><p><strong>Method 1 only:</strong></p><ul><li><code>input_type::Symbol</code>: estimation type to use. Parameters will be loaded using <code>load_draws(m_new, input_type)</code> and <code>load_draws(m_old, input_type)</code> in this method</li></ul><p><strong>Method 2 only:</strong></p><ul><li><code>params_new::Vector{Float64}</code> and <code>params_old::Vector{Float64}</code>: single parameter draws to use</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>check::Bool</code>: whether to check that the individual components add up to the correct total difference in forecasts. This roughly doubles the runtime</li></ul><p><strong>Method 1 only:</strong></p><ul><li><code>verbose::Symbol</code></li></ul><p><strong>Outputs</strong></p><p>The first method returns nothing. The second method returns <code>decomp::Dict{Symbol, Matrix{Float64}}</code>, which has keys of the form <code>:decomp&lt;component&gt;&lt;class&gt;</code> and values of size <code>Ny</code> x <code>Nh</code>, where</p><ul><li><code>Ny</code> is the number of variables in the given class</li><li><code>Nh</code> is the number of common forecast periods, i.e. periods between <code>date_forecast_start(m_new)</code> and <code>date_forecast_end(m_old)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/decomp/drivers.jl#L1-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.forecast_one-Tuple{AbstractDSGEModel{Float64},Symbol,Symbol,Array{Symbol,1}}" href="#DSGE.forecast_one-Tuple{AbstractDSGEModel{Float64},Symbol,Symbol,Array{Symbol,1}}"><code>DSGE.forecast_one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forecast_one(m, input_type, cond_type, output_vars; df = DataFrame(),
    subset_inds = 1:0, forecast_string = &quot;&quot;, verbose = :low, ...)</code></pre><p>Compute and save <code>output_vars</code> for input draws given by <code>input_type</code> and conditional data case given by <code>cond_type</code>.</p><p><strong>Inputs</strong></p><ul><li><p><code>m::AbstractDSGEModel</code>: model object</p></li><li><p><code>input_type::Symbol</code>: one of:</p></li></ul><pre><code class="language-none">  - `:mode`: forecast using the modal parameters only
  - `:mean`: forecast using the mean parameters only
  - `:init`: forecast using the initial parameter values only
  - `:full`: forecast using all parameters (full distribution)
  - `:subset`: forecast using a well-defined user-specified subset of draws</code></pre><ul><li><code>cond_type::Symbol</code>: one of:</li></ul><pre><code class="language-none">  - `:none`: no conditional data
  - `:semi`: use &quot;semiconditional data&quot; - average of quarter-to-date
    observations for high frequency series
  - `:full`: use &quot;conditional data&quot; - semiconditional plus nowcasts for
    desired observables</code></pre><ul><li><code>output_vars::Vector{Symbol}</code>: vector of desired output variables. See <code>?forecast_one_draw</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>df::DataFrame</code>: Historical data. If <code>cond_type in [:semi, :full]</code>, then the  final row of <code>df</code> should be the period containing conditional data. If not  provided, will be loaded using <code>load_data</code> with the appropriate <code>cond_type</code></p></li><li><p><code>subset_inds::AbstractRange{Int64}</code>: indices specifying the draws we want to use. If a more sophisticated selection criterion is desired, the user is responsible for determining the indices corresponding to that criterion. If <code>input_type</code> is not <code>subset</code>, <code>subset_inds</code> will be ignored</p></li><li><p><code>forecast_string::String</code>: short string identifying the subset to be appended to the output filenames. If <code>input_type = :subset</code> and <code>forecast_string</code> is empty, an error is thrown.</p></li><li><p><code>only_filter::Bool</code>: do not run the smoother and only run the filter. This limits the number of output variables which can be calculated.</p></li><li><p><code>verbose::Symbol</code>: desired frequency of function progress messages printed to standard out. One of <code>:none</code>, <code>:low</code>, or <code>:high</code>.</p></li><li><p><code>check_empty_columns::Bool = true</code>: check empty columns or not when loading data (if <code>df</code> is empty)</p></li><li><p><code>bdd_fcast::Bool = true</code>: are we computing the bounded forecasts or not?</p></li><li><p><code>params::AbstractArray{Float64} = Vector{Float64}(undef, 0)</code>: parameter draws for the forecast.    If empty, then we load draws from estimation files implied by the settings in <code>m</code>.</p></li><li><p><code>zlb_method::Symbol</code>: method for enforcing the zero lower bound. Defaults to <code>:shock</code>,   meaning we use a monetary policy shock to enforce the ZLB.</p><p>Other available methods:</p><ol><li><code>:temporary_altpolicy</code> -&gt; use a temporary alternative policy to enforce the ZLB.</li></ol></li><li><p><code>rerun_smoother::Bool = false</code>: if true, rerun the conditional forecast when automatically enforcing   the ZLB as a temporary alternative policy.</p></li><li><p><code>nan_endozlb_failures::Bool = false</code>: if true, failures of an endogenous ZLB (when implemented   as a temporary policy) will be handled by throwing NaNs instead of using   unanticipated monetary policy shocks.</p></li><li><p><code>set_regime_vals_altpolicy::Function</code>: <code>Function</code> that adds new regimes to parameters when   using temporary alternative policies (if needed). Defaults to identity (which does nothing)   This function should take as inputs the model object <code>m</code> and the total number of regimes   (after adding the required temporary regimes), i.e. <code>set_regime_vals_altpolicy(m, n)</code>. It should then   set up regime-switching parameters for these new additional regimes.</p></li><li><p><code>set_info_sets_altpolicy::Function = auto_temp_altpolicy_info_set</code>: <code>Function</code> that automatically updates   the <code>tvis_information_set</code>, e.g. when <code>zlb_method = :temporary_altpolicy</code>.</p></li><li><p><code>update_regime_eqcond_info!::Function = (x1, x2, x3, x4) -&gt;   default_update_regime_eqcond_info(x1, x2, x3, x4, alternative_policy(m)</code>: <code>Function</code> that automatically   updates the setting <code>:regime_eqcond_info</code>. The arguments of <code>update_regime_eqcond_info!</code> should be (in order)   <code>m::AbstractDSGEModel</code>, <code>eqcond_dict::AbstractDict{Int64, EqcondEntry}</code>, <code>zlb_start_regime::Int64</code>,   and <code>liftoff_regime::Int64</code>. The last two arguments are the regime numbers of the first regime for which   the ZLB applies and the regime after the ZLB ends, respectively.   The <code>eqcond_dict</code> argument should specify the <code>EqcondEntry</code> during the historical/conditional horizon regime   (if it is desired) but can otherwise be empty. This function should then update <code>eqcond_dict</code>   in place to implement a temporary ZLB and any other permanent alternative policies/regime-switching   in the forecast horizon (after the conditional horizon).   The user should also be careful and make sure <code>update_regime_eqcond_info!</code> handles imperfect awareness properly   if they want to implement an imperfectly credible ZLB. For an example, see <code>?default_update_regime_eqcond_info</code>.</p></li><li><p><code>show_failed_percent::Bool = false</code>: prints out the number of failed forecasts, which are returned as NaNs.   These may occur when the ZLB is not enforced, for example.</p></li><li><p><code>pegFFR::Bool = false</code>: peg the nominal FFR at the value specified by <code>FFRpeg</code></p></li><li><p><code>FFRpeg::Float64 = -0.25/4</code>: value of the FFR peg</p></li><li><p><code>H::Int = 4</code>: number of horizons for which the FFR is pegged</p></li><li><p><code>testing_carer_kohn::Bool = false</code>: whether to create a file storing some property of Σ in Carter Kohn</p></li></ul><p><strong>Outputs</strong></p><p>None. Output is saved to files returned by <code>get_forecast_output_files(m, input_type, cond_type, output_vars)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/drivers.jl#L411-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.load_draws-Tuple{AbstractDSGEModel,Symbol}" href="#DSGE.load_draws-Tuple{AbstractDSGEModel,Symbol}"><code>DSGE.load_draws</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_draws(m, input_type; subset_inds = 1:0, verbose = :low)

load_draws(m, input_type, block_inds; verbose = :low)</code></pre><p>Load and return parameter draws from Metropolis-Hastings or SMC.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code>: model object</li><li><code>input_type::Symbol</code>: one of the options for <code>input_type</code> described in the documentation for <code>forecast_one</code></li><li><code>block_inds::AbstractRange{Int64}</code>: indices of the current block (already indexed by <code>jstep</code>) to be read in. Only used in second method</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>subset_inds::AbstractRange{Int64}</code>: indices specifying the subset of draws to be read in. Only used in first method</li><li><code>verbose::Symbol</code>: desired frequency of function progress messages printed to standard out. One of <code>:none</code>, <code>:low</code>, or <code>:high</code>. If <code>:low</code> or greater, prints location of input file.</li></ul><p><strong>Outputs</strong></p><ul><li><code>params</code>: first method returns a single parameter draw of type <code>Vector{Float64}</code>. Second method returns a <code>Vector{Vector{Float64}}</code> of parameter draws for this block.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/drivers.jl#L175-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.usual_model_forecast" href="#DSGE.usual_model_forecast"><code>DSGE.usual_model_forecast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">usual_model_forecast(m, input_type, cond_type,
    output_vars = [:histobs, :histpseudo, :forecastobs, :forecastpseudo];
    est_override = &quot;&quot;, forecast_string = &quot;&quot;,
    density_bands = [0.5, 0.6, 0.7, 0.8, 0.9],
    mb_matrix = false, check_empty_columns = true, params = [])</code></pre><p>Forecast, compute means and bands, and optionally (if <code>mb_matrix</code>) convert <code>MeansBands</code> to matrices. If the path <code>est_override</code> is provided, it will be added to <code>forecast_input_file_overrides(m)</code>.</p><p>See <code>?forecast_one</code> for descriptions of the keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/packet/drivers.jl#L35-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.usual_model_settings!-Tuple{AbstractDSGEModel,String}" href="#DSGE.usual_model_settings!-Tuple{AbstractDSGEModel,String}"><code>DSGE.usual_model_settings!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">usual_model_settings!(m, vint; cdvt = vint, dsid = data_id(m), cdid = cond_id(m),
    fcast_date = Dates.lastdayofquarter(Dates.today()),
    altpolicy = AltPolicy(:historical, eqcond, solve))</code></pre><p>Apply usual defaults for the following settings:</p><ul><li><code>data_vintage</code> and <code>cond_vintage</code>: given by input argument <code>vint</code></li><li><code>date_forecast_start</code> and <code>date_conditional_end</code>: given by kwarg <code>fcast_date</code></li><li><code>use_population_forecast</code>: <code>true</code></li><li><code>alternative_policy</code>: given by input argument <code>altpolicy</code>. If this argument is specified, then <code>altpolicy_settings!</code> and <code>altpolicy.setup</code> are also called.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/packet/drivers.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.compute_scenario_system-Tuple{AbstractDSGEModel,Scenario}" href="#DSGE.compute_scenario_system-Tuple{AbstractDSGEModel,Scenario}"><code>DSGE.compute_scenario_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_scenario_system(m, scen::Scenario; apply_altpolicy = false)</code></pre><p>Given the current model parameters, compute the state-space system corresponding to model <code>m</code> and alternative scenario <code>scen</code>. This function differs from <code>compute_system</code> in that the <code>CCC</code>, <code>DD</code>, and <code>DD_pseudo</code> vectors are set to zero (since we forecast in deviations from baseline) and shocks that are not in <code>scen.instrument_names</code> are zeroed out in the <code>QQ</code> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/forecast.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.filter_shocks!" href="#DSGE.filter_shocks!"><code>DSGE.filter_shocks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter_shocks!(m, scen, system::Scenario)</code></pre><p>Given a scenario draw <code>scen</code>, back out the shocks necessary to hit <code>scen.targets</code> and put them into <code>scen.instruments</code>. This function returns <code>forecastshocks</code>, an <code>nshocks</code> x <code>horizon</code> matrix of filtered and smoothed shocks.</p><p>This function checks <code>forecast_uncertainty_override(m)</code> for whether to smooth shocks using the simulation smoother.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/forecast.jl#L38-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.forecast-Union{Tuple{S}, Tuple{AbstractDSGEModel,Union{RegimeSwitchingSystem{S}, System{S}},Array{S,1}}} where S&lt;:AbstractFloat" href="#DSGE.forecast-Union{Tuple{S}, Tuple{AbstractDSGEModel,Union{RegimeSwitchingSystem{S}, System{S}},Array{S,1}}} where S&lt;:AbstractFloat"><code>DSGE.forecast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forecast(m, system, z0; cond_type = :none,
    enforce_zlb = false, shocks = Matrix{S}(undef, 0,0))

forecast(m, altpolicy, z0, states, obs, pseudo, shocks)

forecast(system, z0, shocks; enforce_zlb = false)

forecast(m, system, z0, shocks; cond_type = :none, enforce_zlb = false)</code></pre><p>The first method produces a forecast, given a state space system, initial state, and shocks, using information about the desired forecast contained in <code>m</code>. It enforces the ZLB by using monetary policy shocks.</p><p>The second method is similar but differs in two ways. First, it produces forecasts specifically when an alternative policy is used. Second, it enforces the ZLB by treating it as a temporary alternative policy.</p><p>The third and fourth methods are internal functions used by the first two methods.</p><p><strong>Inputs</strong></p><ul><li><code>system::System{S}</code>: state-space system matrices</li><li><code>z0::Vector{S}</code>: state vector in the final historical period</li><li><code>shocks::Matrix{S}</code>: <code>nshocks</code> x <code>nperiods</code> matrix of shocks to use when forecasting. Note that in the first method, <code>nperiods</code> doesn&#39;t necessarily have to equal <code>forecast_horizons(m)</code>; it will be truncated or padded with zeros appropriately</li></ul><p><strong>Method 1 and 2 only:</strong></p><ul><li><code>m::AbstractDSGEModel</code></li></ul><p><strong>Method 2 only:</strong></p><ul><li><code>altpolicy::Symbol</code>: Which alternative policy is being used</li><li><code>obs::Matrix{S &lt;: Real}</code>: matrix of forecasted observables</li></ul><p>where <code>S&lt;:AbstractFloat</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>cond_type::Symbol</code>: one of <code>:none</code>, <code>:semi</code>, or <code>:full</code>, used to determine how many periods to forecast ahead. If <code>cond_type in [:semi, :full]</code>, the forecast horizon is reduced by the number of periods of conditional data. Defaults to <code>:none</code>.</p></li><li><p><code>enforce_zlb::Bool</code>: whether to enforce the zero lower bound. Defaults to <code>false</code>.</p></li><li><p><code>shocks::Matrix{S}</code>: matrix of size <code>nshocks</code> x <code>shock_horizon</code> of shock innovations under which to forecast. If <code>shock_horizon &gt; horizon</code>, the extra periods of shocks will be ignored; if <code>shock_horizon &lt; horizon</code>, zeros will be filled in for the shocks hitting the remaining forecasted periods.</p></li><li><p><code>draw_shocks::Bool</code>: if <code>isempty(shocks)</code>, indicates whether to draw shocks according to:</p><ol><li>If <code>forecast_tdist_shocks(m)</code>, draw <code>horizons</code> many shocks from a <code>Distributions.TDist(forecast_tdist_df_val(m))</code></li><li>Otherwise, draw <code>horizons</code> many shocks from a <code>DegenerateMvNormal(zeros(nshocks), sqrt(system[:QQ]))</code></li></ol><p>or to set <code>shocks</code> to a <code>nshocks</code> x <code>horizon</code> matrix of zeros. Defaults to <code>false</code>. If <code>shocks</code> is provided as a keyword argument, this flag has no effect.</p></li></ul><p><strong>Method 2 only:</strong></p><ul><li><p><code>set_zlb_regime_vals::Function</code>: user-provided function that adds additional regimes to   regime-switching parameters if not enough regimes exist to impose the ZLB   as a temporary alternative policy. Defaults to <code>identity</code>, and nothing will happen   if this is the case.</p></li><li><p><code>tol::{&lt;: Real}</code>: Tolerance for the smallest permissible value for the nominal interest rate.   Defaults to -1e-14.</p></li></ul><p><strong>Outputs</strong></p><ul><li><code>states::Matrix{S}</code>: matrix of size <code>nstates</code> x <code>horizon</code> of forecasted states</li><li><code>obs::Matrix{S}</code>: matrix of size <code>nobs</code> x <code>horizon</code> of forecasted observables</li><li><code>pseudo::Matrix{S}</code>: matrix of size <code>npseudo</code> x <code>horizon</code> of forecasted pseudo-observables</li><li><code>shocks::Matrix{S}</code>: matrix of size <code>nshocks</code> x <code>horizon</code> of shock innovations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/forecast.jl#L1-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.forecast_scenario-Tuple{AbstractDSGEModel,Scenario}" href="#DSGE.forecast_scenario-Tuple{AbstractDSGEModel,Scenario}"><code>DSGE.forecast_scenario</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forecast_scenario(m, scen::Scenario; verbose = :low)</code></pre><p>Simulate all draws of <code>scen</code> using the modal parameters of the model <code>m</code>. This function returns a <code>Dict{Symbol, Array{Float64}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/forecast.jl#L157-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.histforecast" href="#DSGE.histforecast"><code>DSGE.histforecast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">histforecast(var, hist, forecast;
    start_date = hist.means[1, :date], end_date = forecast.means[end, :date],
    names = Dict{Symbol, String}(), colors = Dict{Symbol, Any}(),
    alphas = Dict{Symbol, Float64}(), styles = Dict{Symbol, Symbol}(),
    bands_pcts = union(which_density_bands(hist, uniquify = true),
                       which_density_bands(forecast, uniquify = true)),
    bands_style = :fan, label_bands = false, transparent_bands = true,
    tick_size = 2)</code></pre><p>User recipe called by <code>plot_history_and_forecast</code>.</p><p><strong>Inputs</strong></p><ul><li><code>var::Symbol</code>: e.g. <code>obs_gdp</code></li><li><code>hist::MeansBands</code></li><li><code>forecast::MeansBands</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_date::Date</code></li><li><code>end_date::Date</code></li><li><code>names::Dict{Symbol, String}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to labels. If a key is missing from <code>names</code>, a default value will be used</li><li><code>colors::Dict{Symbol, Any}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to colors</li><li><code>alphas::Dict{Symbol, Float64}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to transparency values (between 0.0 and 1.0)</li><li><code>styles::Dict{Symbol, Symbol}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to linestyles</li><li><code>bands_pcts::Vector{String}</code>: which bands percentiles to plot</li><li><code>bands_style::Symbol</code>: either <code>:fan</code> or <code>:line</code></li><li><code>label_bands::Bool</code></li><li><code>transparent_bands::Bool</code></li><li><code>tick_size::Int</code>: x-axis (time) tick size in units of years</li><li><code>add_new_model::Bool</code>: Adding history from another model?</li><li><code>new_data::Array{Flaot64,1}</code>: The new history to plot</li></ul><p>Additionally, all Plots attributes (see docs.juliaplots.org/latest/attributes) are supported as keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/plot/plot_history_and_forecast.jl#L234-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.histforecast_vector" href="#DSGE.histforecast_vector"><code>DSGE.histforecast_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">histforecast_vector(var, hist, forecast;
    start_date::Date = hf.args[2][1].means[1, :date],
    end_date::Date = hf.args[3][1].means[end, :date],
    names = Dict{Symbol, Vector{String}}(),
    colors = Dict{Symbol, Any}(),
    alphas = Dict{Symbol, Float64}(),
    styles = Dict{Symbol, Symbol}(),
    add_new_model::Bool = false, new_data::Array{Float64,1} = [],
    bands_pcts = union(which_density_bands(hf.args[2][1], uniquify = true),
        which_density_bands(hf.args[3][1], uniquify = true)),
    bands_style = :fan,
    label_bands = false,
    transparent_bands = true,
    add_trendline::Bool = false, trend_vals::Vector{Float64} = [1.0],
    tick_size = 2)</code></pre><p>User recipe called by <code>plot_history_and_forecast</code>.</p><p><strong>Inputs</strong></p><ul><li><code>var::Symbol</code>: e.g. <code>obs_gdp</code></li><li><code>hist::Vector{MeansBands}</code></li><li><code>forecast::Vector{MeansBands}</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_date::Date</code></li><li><code>end_date::Date</code></li><li><code>names::Dict{Symbol, String}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to labels. If a key is missing from <code>names</code>, a default value will be used</li><li><code>colors::Dict{Symbol, Any}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to colors</li><li><code>alphas::Dict{Symbol, Float64}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to transparency values (between 0.0 and 1.0)</li><li><code>styles::Dict{Symbol, Symbol}</code>: maps keys <code>[:hist, :forecast, :bands]</code> to linestyles</li><li><code>bands_pcts::Vector{String}</code>: which bands percentiles to plot</li><li><code>bands_style::Symbol</code>: either <code>:fan</code> or <code>:line</code></li><li><code>label_bands::Bool</code></li><li><code>transparent_bands::Bool</code></li><li><code>tick_size::Int</code>: x-axis (time) tick size in units of years</li><li><code>add_new_model::Bool</code>: Adding history from another model?</li><li><code>new_data::Array{Float64,1}</code>: The new history to plot</li><li><code>add_trendline::Bool</code>: Whether add a trendline or not</li><li><code>trend_vals::Vector{Float64}</code>: The values to multiply last historical value by   for the trendline (should start with 0.0 to keep last historical value the same)</li><li><code>plot_all_histories::Bool</code>: Whether to plot histories for each model (generally used   for pseudo observables like Natural Rate.</li></ul><p>Additionally, all Plots attributes (see docs.juliaplots.org/latest/attributes) are supported as keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/plot/plot_history_and_forecast.jl#L446-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.plot_history_and_forecast-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol,Symbol}" href="#DSGE.plot_history_and_forecast-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol,Symbol}"><code>DSGE.plot_history_and_forecast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_history_and_forecast(m, var, class, input_type, cond_type;
    title = &quot;&quot;, plot_handle = plot(), kwargs...)

plot_history_and_forecast(m, vars, class, input_type, cond_type;
    forecast_string = &quot;&quot;, use_bdd = :unbdd,
    plotroot = figurespath(m, &quot;forecast&quot;), titles = [],
    plot_handles = fill(plot(), length(vars)), verbose = :low,
    add_trendline::Bool = false, trend_vals::Vector{Float64} = [1.0],
    kwargs...)

plot_history_and_forecast(ms::Vector, vars::Vector{Symbol}, class::Symbol,
    input_type::Symbol, cond_type::Symbol;
    forecast_string::String = &quot;&quot;,
    use_bdd::Symbol = :bdd,
    modal_line::Bool = false, untrans::Bool = false,
    fourquarter::Bool = false,
    plotroot::String = figurespath(ms[1], &quot;forecast&quot;),
    titles::Vector{String} = String[],
    plot_handles::Vector{Plots.Plot} = Plots.Plot[plot() for i = 1:length(vars)],
    verbose::Symbol = :low, names = Dict{Symbol, Vector{String}}(),
    start_date::Date = Date(2019,3,31), end_date::Date = iterate_quarters(date_forecast_start(m), 12),
    add_new_model::Bool = false, new_model::AbstractDSGEModel = Model1002(),
    new_cond_type::Symbol = :full, outfile_end::String =  &quot;&quot;,
    new_forecast_string::String = forecast_string,
    add_trendline::Bool = false, trend_vals::Vector{Float64} = [1.0],
    forecast_strings::Vector{String} = repeat([forecast_string], length(ms)),
    kwargs...)</code></pre><p>Plot history and forecast for <code>var</code> or <code>vars</code>. If these correspond to a full-distribution forecast, you can specify the <code>bands_style</code> and <code>bands_pcts</code>.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code></li><li><code>var::Symbol</code> or <code>vars::Vector{Symbol}</code>: variable(s) to be plotted, e.g. <code>:obs_gdp</code> or <code>[:obs_gdp, :obs_nominalrate]</code></li><li><code>class::Symbol</code></li><li><code>input_type::Symbol</code></li><li><code>cond_type::Symbol</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>forecast_string::String = &quot;&quot;</code></li><li><code>use_bdd::Symbol = :unbdd</code>: specifies which combination of means and bands to use   a. <code>:bdd</code> -&gt; bounded bands and bounded means (from <code>:bddforecastobs</code>, etc.)   b. <code>:bdd_and_unbdd</code> -&gt; bounded bands (from <code>:bddforecastobs</code>, etc.) and unbounded means (from <code>:forecastobs</code>, etc.)   c. <code>:unbdd</code> -&gt; unbounded bands and unbounded means (from <code>:forecastobs</code>, etc.)</li><li><code>modal_line::Bool = false</code>: if true, the modal line is plotted instead of the mean.</li><li><code>untrans::Bool = false</code>: whether to plot untransformed (model units) history and forecast</li><li><code>fourquarter::Bool = false</code>: whether to plot four-quarter history and forecast</li><li><code>plotroot::String = figurespath(m, &quot;forecast&quot;)</code>: if nonempty, plots will be saved in that directory</li><li><code>title::String = &quot;&quot;</code> or <code>titles::Vector{String} = []</code></li><li><code>plot_handle::Plot</code> or <code>plot_handles::Vector{Plot}</code>: existing plot(s) on which to overlay new forecast plot(s)</li><li><code>verbose::Symbol = :low</code></li><li><code>names::Dict{Symbol, Vector{String}}</code>: Legend names for lines</li><li><code>start_date::Date</code> = Date(2019,3,31)`: Date plot should start at</li><li><code>end_date::Date</code> = iterate<em>quarters(date</em>forecast_start(m), 12)`: Date plot should end at</li><li><code>add_new_model::Bool</code> = false: Whether history should be plotted using a new model</li><li><code>new_model::AbstractDSGEModel</code> = Model1002(): The new model to use to plot history</li><li><code>new_cond_type::Symbol</code> = :full: Cond_type of new model</li><li><code>outfile_end::String = &quot;&quot;</code>: String to append to the end of file name of plot</li><li><code>new_forecast_string::String = forecast_string</code>: Forecast string for new model</li><li><code>add_trendline::Bool</code>: Whether add a trendline or not</li><li><code>trend_vals::Vector{Float64}</code>: The values to multiply last historical value by   for the trendline (should start with 0.0 to keep last historical value the same)</li><li><code>forecast_strings::Vector{String}</code>: Forecast string to use for each give model.</li></ul><p>See <code>?histforecast</code> or <code>?histforecast_vector&#39; for additional keyword arguments, all of which can be passed into</code>plot<em>history</em>and_forecast`.</p><p><strong>Output</strong></p><ul><li><code>p::Plot</code> or <code>plots::OrderedDict{Symbol, Plot}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/plot/plot_history_and_forecast.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.smooth-Union{Tuple{S}, Tuple{AbstractDSGEModel,DataFrames.DataFrame,System{S}}, Tuple{AbstractDSGEModel,DataFrames.DataFrame,System{S},Array{S,1}}, Tuple{AbstractDSGEModel,DataFrames.DataFrame,System{S},Array{S,1},Array{S,2}}} where S&lt;:AbstractFloat" href="#DSGE.smooth-Union{Tuple{S}, Tuple{AbstractDSGEModel,DataFrames.DataFrame,System{S}}, Tuple{AbstractDSGEModel,DataFrames.DataFrame,System{S},Array{S,1}}, Tuple{AbstractDSGEModel,DataFrames.DataFrame,System{S},Array{S,1},Array{S,2}}} where S&lt;:AbstractFloat"><code>DSGE.smooth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">smooth(m, df, system, s_0, P_0; cond_type = :none, draw_states = true,
    include_presample = false)</code></pre><p>Computes and returns the smoothed values of states and shocks for the system <code>system</code>.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code>: model object</li><li><code>df::DataFrame</code>: data for observables. This should include the conditional period if <code>cond_type in [:semi, :full]</code></li><li><code>system::System</code>: <code>System</code> object representing the state-space system</li><li><code>s_0::Vector{S}</code>: optional initial state vector</li><li><code>P_0::Matrix{S}</code>: optional initial state covariance matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>cond_type</code>: conditional case. See <code>forecast_one</code> for documentation of all <code>cond_type</code> options</li><li><code>draw_states</code>: if using a simulation smoother (i.e. <code>forecast_smoother(m) in [:carter_kohn, :durbin_koopman]</code>), indicates whether  to draw smoothed states from the distribution <code>N(z_{t|T}, P_{t|T})</code> or to use  the mean <code>z_{t|T}</code>. Defaults to <code>false</code>. If not using a simulation smoother,  this flag has no effect (though the user will be warned if  <code>draw_states = true</code>)</li><li><code>include_presample::Bool</code>: indicates whether to include presample periods in the returned matrices. Defaults to <code>false</code>.</li><li><code>in_sample::Bool</code>: indicates whether or not to discard out of sample rows in <code>df_to_matrix</code> call.</li></ul><p><strong>Outputs</strong></p><ul><li><code>states::Matrix{S}</code>: array of size <code>nstates</code> x <code>hist_periods</code> of smoothed states (not including the presample)</li><li><code>shocks::Matrix{S}</code>: array of size <code>nshocks</code> x <code>hist_nperiods</code> of smoothed shocks</li><li><code>pseudo::Matrix{S}</code>: matrix of size <code>npseudo</code> x <code>hist_periods</code> of pseudo-observables computed from the smoothed states</li><li><code>initial_states::Vector{S}</code>: vector of length <code>nstates</code> of the smoothed states in the last presample period. This is used as the initial state for computing the deterministic trend</li></ul><p><strong>Notes</strong></p><p><code>states</code> and <code>shocks</code> are returned from the smoother specified by <code>forecast_smoother(m)</code>, which defaults to <code>:durbin_koopman</code>. This can be overridden by calling</p><pre><code class="language-none">m &lt;= Setting(:forecast_smoother, :koopman_smoother))</code></pre><p>before calling <code>smooth</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/smooth.jl#L1-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.deterministic_trends-Union{Tuple{S}, Tuple{AbstractDSGEModel{S},System{S},Array{S,1}}} where S&lt;:AbstractFloat" href="#DSGE.deterministic_trends-Union{Tuple{S}, Tuple{AbstractDSGEModel{S},System{S},Array{S,1}}} where S&lt;:AbstractFloat"><code>DSGE.deterministic_trends</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deterministic_trends(m, system, z0)

deterministic_trends(system, z0, nperiods, start_index, end_index)

deterministic_trends(m, system, z0, start_date, end_date)

deterministic_trends(m, system, z0, nperiods, start_index, end_index,
    regime_inds, regimes, cond_type)

deterministic_trends(m, system, old_system, z0, start_date, end_date)

deterministic_trends(m, system, old_system, z0, nperiods, start_index, end_index,
    regime_inds, regimes, cond_type)</code></pre><p>Compute deterministic trend values of states, observables, and pseudo-observables, given a model object and system matrices. The deterministic trend for a single draw is simply the series that would be obtained by iterating the state-space system forward, beginning from a state vector <code>z0</code> in the last presample period.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code>: model object</li><li><code>system::System{S}</code> or <code>RegimeSwitchingSystem</code>: state-space system matrices</li><li><code>z0</code>::Vector{S}: initial state vector</li><li><code>start_date::Date</code>: initial date for deterministic trends</li><li><code>end_date::Date</code>: final date for deterministic trends</li><li><code>regime_inds::Vector{UnitRange}</code>: indices of the data corresponding to each regime.</li><li><code>regimes::UnitRange</code>: which regimes are involved in the date range for which   we want to compute the deterministic trends</li><li><code>old_system::</code>RegimeSwitchingSystem`: state-space system matrices for old model</li></ul><p>where <code>S&lt;:AbstractFloat</code>.</p><p><strong>Outputs</strong></p><ul><li><code>states::Matrix{S}</code>: matrix of size <code>nstates</code> x <code>nperiods</code> of state steady-state values</li><li><code>obs::Matrix{S}</code>: matrix of size <code>nobs</code> x <code>nperiods</code> of observable steady-state values</li><li><code>pseudo::Matrix{S}</code>: matrix of size <code>npseudo</code> x <code>nperiods</code> of pseudo-observable steady-state values</li></ul><p>where <code>nperiods</code> is the number of quarters between <code>date_shockdec_start(m)</code> and <code>date_shockdec_end(m)</code>, inclusive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/shock_decompositions.jl#L344-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.shock_decompositions-Union{Tuple{S}, Tuple{AbstractDSGEModel,System{S},Array{S,2}}} where S&lt;:AbstractFloat" href="#DSGE.shock_decompositions-Union{Tuple{S}, Tuple{AbstractDSGEModel,System{S},Array{S,2}}} where S&lt;:AbstractFloat"><code>DSGE.shock_decompositions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shock_decompositions(m, system, histshocks)

shock_decompositions(system, forecast_horizons, histshocks, start_index,
    end_index)

shock_decompositions(m, system, histshocks, start_date, end_date)

shock_decompositions(m, system, forecast_horizons, histshocks, start_index,
    end_index, regime_inds, cond_type)

shock_decompositions(m, system, old_system,
                              histshocks, old_histshocks, start_date, end_date,
                              cond_type; full_shock_decomp)

shock_decompositions(m, system, old_system,
                              forecast_horizons, histshocks, old_histshocks,
                              start_index, end_index,
                              regime_inds, cond_type; full_shock_decomp)</code></pre><p><strong>Inputs</strong></p><ul><li><code>system::System{S}</code> or <code>RegimeSwitchingSystem{S}</code>: state-space system matrices</li><li><code>forecast_horizons::Int</code>: number of periods ahead to forecast</li><li><code>histshocks::Matrix{S}</code>: matrix of size <code>nshocks</code> x <code>hist_periods</code> of historical smoothed shocks</li><li><code>start_index::Int</code>: first index from which to return computed shock decompositions</li><li><code>end_index::Int</code>: last index for which to return computed shock decompositions</li><li><code>start_date::Date</code>: initial date for deterministic trends</li><li><code>end_date::Date</code>: final date for deterministic trends</li><li><code>regime_inds::Vector{UnitRange}</code>: indices of the data corresponding to each regime.</li><li><code>old_system::RegimeSwitchingSystem{S}</code>: state-space system matrices for the old model</li><li><code>old_histshocks::Matrix{S}</code>: matrix of size <code>nshocks</code> x <code>hist_periods</code> of historical smoothed shocks using the old system</li><li><code>full_shock_decomp::Bool</code>: If true for old_system case, return difference in shockdecs   between all shocks for the new and old systems. Else, return old system&#39;s shocks   with 1 cumulative AIT shock added on.</li></ul><p>where <code>S&lt;:AbstractFloat</code>.</p><p><strong>Outputs</strong></p><ul><li><code>states::Array{S, 3}</code>: matrix of size <code>nstates</code> x <code>nperiods</code> x <code>nshocks</code> of state shock decompositions</li><li><code>obs::Array{S, 3}</code>: matrix of size <code>nobs</code> x <code>nperiods</code> x <code>nshocks</code> of observable shock decompositions</li><li><code>pseudo::Array{S, 3}</code>: matrix of size <code>npseudo</code> x <code>nperiods</code> x <code>nshocks</code> of pseudo-observable shock decompositions</li></ul><p>where <code>nperiods =</code>end<em>index - start</em>index + 1`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/shock_decompositions.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.trends-Union{Tuple{System{S}}, Tuple{S}} where S&lt;:AbstractFloat" href="#DSGE.trends-Union{Tuple{System{S}}, Tuple{S}} where S&lt;:AbstractFloat"><code>DSGE.trends</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trends(system::System{S}) where {S&lt;:AbstractFloat}
trends(system::RegimeSwitchingSystem{S}) where {S&lt;:AbstractFloat}
trends(m::AbstractDSGEModel, system::RegimeSwitchingSystem{S},
                start_date::Dates.Date = date_presample_start(m),
                end_date::Dates.Date = prev_quarter(date_forecast_start(m)),
                cond_type::Symbol) where {S&lt;:AbstractFloat}</code></pre><p>Compute trend (steady-state) states, observables, and pseudo-observables. The trend is used for plotting shock decompositions. The first method applies to non-regime switching systems, the second to regime-switching systems that do not involve time variation in the <code>CCC</code> or <code>DD</code> vectors, and the third to regime-switching systems with time variation in <code>CCC</code> or <code>DD</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/shock_decompositions.jl#L607-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_forecast_filename-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol}" href="#DSGE.get_forecast_filename-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol}"><code>DSGE.get_forecast_filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_filename(m, input_type, cond_type, output_var;
    pathfcn = rawpath, forecast_string = &quot;&quot;, fileformat = :jld2)

get_forecast_filename(directory, filestring_base, input_type, cond_type,
    output_var; forecast_string = &quot;&quot;, fileformat = :jld2)</code></pre><p><strong>Notes</strong></p><ul><li>If <code>input_type == :subset</code>, then the <code>forecast_string</code> is also appended to the</li></ul><p>filenames. If in this case <code>forecast_string</code> is empty, <code>get_forecast_filename</code> throws an error.</p><ul><li>In the second method, <code>directory</code> should be a string of the form <code>&quot;$saveroot/m990/ss2/forecast/raw/&quot;</code>. (Note that a <code>pathfcn</code> is therefore not required.) <code>filestring_base</code> should be equivalent to the result of <code>filestring_base(m)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L63-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_forecast_input_file-Tuple{Any,Any}" href="#DSGE.get_forecast_input_file-Tuple{Any,Any}"><code>DSGE.get_forecast_input_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_input_file(m, input_type)</code></pre><p>Compute the appropriate forecast input filenames for model <code>m</code> and forecast input type <code>input_type</code>.</p><p>The default input files for each <code>input_type</code> can be overriden by adding entries to the <code>Dict{Symbol, String}</code> returned from <code>forecast_input_file_overrides(m)</code>. For example:</p><pre><code class="language-none">overrides = forecast_input_file_overrides(m)
overrides[:mode] = &quot;path/to/input/file.h5&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_forecast_output_files-Tuple{AbstractDSGEModel,Symbol,Symbol,Array{Symbol,1}}" href="#DSGE.get_forecast_output_files-Tuple{AbstractDSGEModel,Symbol,Symbol,Array{Symbol,1}}"><code>DSGE.get_forecast_output_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_output_files(m, input_type, cond_type, output_vars;
    forecast_string = &quot;&quot;, fileformat = :jld2)

get_forecast_output_files(directory, filestring_base, input_type, cond_type,
    output_vars; forecast_string = &quot;&quot;, fileformat = :jld2)</code></pre><p>Compute the appropriate output filenames for model <code>m</code>, forecast input type <code>input_type</code>, and conditional type <code>cond_type</code>, for each output variable in <code>output_vars</code>. Returns a dictionary of file names with one entry for each output_var.</p><p><strong>Arguments</strong></p><ul><li>See <code>forecast_one</code> for descriptions of other non-keyword arguments.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>forecast_string::String</code>: subset identifier for when <code>input_type = :subset</code></li><li><code>fileformat::Symbol</code>: file extension, without a period. Defaults to <code>:jld2</code>, though <code>:h5</code> is another common option.</li></ul><p><strong>Notes</strong></p><p>See <code>get_forecast_filename</code> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L129-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_meansbands_input_file-Tuple{Union{AbstractDSGEModel, AbstractVARModel},Symbol,Symbol,Symbol}" href="#DSGE.get_meansbands_input_file-Tuple{Union{AbstractDSGEModel, AbstractVARModel},Symbol,Symbol,Symbol}"><code>DSGE.get_meansbands_input_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_meansbands_input_file(m, input_type, cond_type, output_var;
    forecast_string = &quot;&quot;, fileformat = :jld2)</code></pre><pre><code class="language-none">get_meansbands_input_file(directory, filestring_base, input_type, cond_type, output_var;
    forecast_string = &quot;&quot;, fileformat = :jld2)</code></pre><p>Returns a dictionary of raw forecast output files to read in to compute means and bands.</p><p><strong>Inputs</strong></p><p><strong>Method 1:</strong></p><ul><li><code>m::AbstractDSGEModel</code></li></ul><p><strong>Method 2:</strong></p><ul><li><code>directory::String</code>: directory location of input files to read</li><li><code>filestring_base::Vector{String}</code>: a vector of strings to be added as a suffix. These usually come from model settings for which <code>print = true</code>. It should <em>not</em> include entries for <code>cond_type</code> and <code>input_type</code> (these will be added automatically).</li></ul><p><strong>Both methods:</strong></p><ul><li><code>input_type::Symbol</code>: See <code>?forecast_one</code></li><li><code>cond_type::Symbol</code>: See <code>?forecast_one</code></li><li><code>output_var::Symbol</code>: See <code>?forecast_one</code></li><li><code>forecast_string::String</code>: See <code>?forecast_one</code></li><li><code>fileformat</code>: file extension of saved files</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L5-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_meansbands_output_file-Tuple{Union{AbstractDSGEModel, AbstractVARModel},Symbol,Symbol,Symbol}" href="#DSGE.get_meansbands_output_file-Tuple{Union{AbstractDSGEModel, AbstractVARModel},Symbol,Symbol,Symbol}"><code>DSGE.get_meansbands_output_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_meansbands_output_file(m, input_type, cond_type, output_var;
    forecast_string = &quot;&quot;, fileformat = :jld2)</code></pre><pre><code class="language-none">get_meansbands_output_file(directory, filestring_base, input_type, cond_type, output_var;
    forecast_string = &quot;&quot;, fileformat = :jld2)</code></pre><p>Returns a dictionary of raw forecast output files in which to save computed means and bands.</p><p><strong>Inputs</strong></p><p><strong>Method 1:</strong></p><ul><li><code>m::AbstractDSGEModel</code>: Model object</li></ul><p><strong>Method 2:</strong></p><ul><li><code>directory::String</code>: directory location of input files to read</li><li><code>filestring_base::Vector{String}</code>: a vector of strings to be added as a suffix. These usually come from model settings for which print=true. It should <em>not</em> include entries for <code>cond_type</code> and <code>input_type</code> (these will be added automatically).</li></ul><p><strong>Both methods:</strong></p><ul><li><code>input_type::Symbol</code>: See <code>?forecast_one</code></li><li><code>cond_type::Symbol</code>: See <code>?forecast_one</code></li><li><code>output_vars::Symbol</code>: See <code>?forecast_one</code></li><li><code>forecast_string::String</code>: See <code>?forecast_one</code></li><li><code>fileformat</code>: file extension of saved files</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L72-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_scenario_filename-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}" href="#DSGE.get_scenario_filename-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}"><code>DSGE.get_scenario_filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_filename(m, scen::AbstractScenario, output_var;
    pathfcn = rawpath, fileformat = :jld2, directory = &quot;&quot;)</code></pre><p>Get scenario file name of the form <code>pathfcn(m, &quot;scenarios&quot;, output_var * filestring * string(fileformat))</code>. If <code>directory</code> is provided (nonempty), then the same file name in that directory will be returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L70-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_scenario_input_file-Tuple{AbstractDSGEModel,Scenario}" href="#DSGE.get_scenario_input_file-Tuple{AbstractDSGEModel,Scenario}"><code>DSGE.get_scenario_input_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_input_file(m, scen::Scenario)</code></pre><p>Get file name of raw scenario targets from <code>inpath(m, &quot;scenarios&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_scenario_mb_input_file-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}" href="#DSGE.get_scenario_mb_input_file-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}"><code>DSGE.get_scenario_mb_input_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_mb_input_file(m, scen::AbstractScenario, output_var)</code></pre><p>Call <code>get_scenario_filename</code> while replacing <code>forecastut</code> and <code>forecast4q</code> in <code>output_var</code> with <code>forecast</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_scenario_mb_output_file-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}" href="#DSGE.get_scenario_mb_output_file-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}"><code>DSGE.get_scenario_mb_output_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_mb_output_file(m, scen::AbstractScenario, output_var;
    directory = &quot;&quot;)</code></pre><p>Call <code>get_scenario_filename</code> while tacking on <code>&quot;mb&quot;</code> to the front of the base file name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_scenario_output_files-Tuple{AbstractDSGEModel,SingleScenario,Array{Symbol,1}}" href="#DSGE.get_scenario_output_files-Tuple{AbstractDSGEModel,SingleScenario,Array{Symbol,1}}"><code>DSGE.get_scenario_output_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_output_files(m, scen::SingleScenario, output_vars)</code></pre><p>Return a <code>Dict{Symbol, String}</code> mapping <code>output_vars</code> to the raw simulated scenario outputs for <code>scen</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.plot_scenario-Tuple{AbstractDSGEModel,Symbol,Symbol,AbstractScenario}" href="#DSGE.plot_scenario-Tuple{AbstractDSGEModel,Symbol,Symbol,AbstractScenario}"><code>DSGE.plot_scenario</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_scenario(m, var, class, scen; title = &quot;&quot;, kwargs...)

plot_scenario(m, vars, class, scen; untrans = false, fourquarter = false,
    plotroot = figurespath(m, &quot;scenarios&quot;), titles = [], tick_size = 1,
    kwargs...)</code></pre><p>Plot <code>var</code> or <code>vars</code> <em>in deviations from baseline</em> for the alternative scenario specified by <code>key</code> and <code>vint</code>.</p><p><strong>Inputs</strong></p><ul><li><code>var::Symbol</code> or <code>vars::Vector{Symbol}</code>: variable(s) to be plotted, e.g. <code>:obs_gdp</code> or <code>[:obs_gdp, :obs_nominalrate]</code></li><li><code>class::Symbol</code></li><li><code>scen::AbstractScenario</code>: scenario</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>untrans::Bool</code>: whether to plot untransformed (model units) forecast</li><li><code>fourquarter::Bool</code>: whether to plot four-quarter forecast</li><li><code>plotroot::String</code>: if nonempty, plots will be saved in that directory</li><li><code>title::String</code> or <code>titles::Vector{String}</code></li><li><code>tick_size::Int</code>: x-axis (time) tick size in units of years</li><li><code>legend</code></li></ul><p>See <code>?histforecast</code> for additional keyword arguments, all of which can be passed into <code>plot_scenario</code>.</p><p><strong>Output</strong></p><ul><li><code>p::Plot</code> or <code>plots::OrderedDict{Symbol, Plot}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/plot/plot_scenario.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_bdd_and_unbdd_mb-Tuple{String,String}" href="#DSGE.read_bdd_and_unbdd_mb-Tuple{String,String}"><code>DSGE.read_bdd_and_unbdd_mb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_bdd_and_unbdd_mb(bdd_fn::String, unbdd_fn::String; modal_line::Bool = false)</code></pre><p>Read in the bounded and unbounded forecast <code>MeansBands</code> from <code>bdd_fn</code> and <code>unbdd_fn</code>. Create and return a <code>MeansBands</code> with the unbounded means and bounded bands. If <code>modal_line</code> is true, then the <code>unbdd_fn</code> is known to load in a modal forecast but should be treated as having the same <code>input_type</code> as the bounded forecast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L235-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_mb-Tuple{String}" href="#DSGE.read_mb-Tuple{String}"><code>DSGE.read_mb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_mb(fn::String)

read_mb(fn1::String, fn2::String)

read_mb(m, input_type, cond_type, output_var; forecast_string = &quot;&quot;,
    use_bdd = :unbdd, modal_line = false, directory = workpath(m, &quot;forecast&quot;))</code></pre><p>Read in a <code>MeansBands</code> object saved in <code>fn</code>, or use the model object <code>m</code> to determine the file location.</p><p>The second method construct a <code>MeansBands</code> object with means from the modal object and bands, where <code>fn1</code> is the file location of the bands and <code>fn2</code> is the file location of the means.</p><p>If <code>bdd_and_unbdd</code>, then <code>output_var</code> must be either <code>:forecast</code> or <code>:forecast4q</code>. Then this function calls <code>read_bdd_and_unbdd</code> to return a <code>MeansBands</code> with unbounded means and bounded bands. If modal line is set to true, then the modal mean rather than the full-distribution mean is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L132-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_scenario_mb-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}" href="#DSGE.read_scenario_mb-Tuple{AbstractDSGEModel,AbstractScenario,Symbol}"><code>DSGE.read_scenario_mb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_scenario_mb(m, scen::AbstractScenario, output_var; directory = &quot;&quot;)</code></pre><p>Read in an alternative scenario <code>MeansBands</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L460-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_scenario_output-Tuple{AbstractDSGEModel,SingleScenario,Symbol,Symbol,Symbol}" href="#DSGE.read_scenario_output-Tuple{AbstractDSGEModel,SingleScenario,Symbol,Symbol,Symbol}"><code>DSGE.read_scenario_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_scenario_output(m, scen::SingleScenario, class, product, var_name)

read_scenario_output(m, agg::ScenarioAggregate, class, product, var_name)</code></pre><p>Given either <code>scen</code> or <code>agg</code>, read in and return all draws of and the appropriate reverse transform for <code>var_name</code>.</p><p>The third function that takes in two models is used for when we have scenarios from two different models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L197-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_means_tables_shockdec-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol}" href="#DSGE.write_means_tables_shockdec-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol}"><code>DSGE.write_means_tables_shockdec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_means_tables_shockdec(m, input_type, cond_type, class;
    forecast_string = &quot;&quot;,
    read_dirname = workpath(m, &quot;forecast&quot;),
    write_dirname = tablespath(m, &quot;forecast&quot;),
    kwargs...)

write_means_tables_shockdec(write_dirname, filestring_base, mb_shockdec,
    mb_trend, mb_dettrend, mb_hist, mb_forecast; tablevars = get_variables(mb),
    columnvars = get_shocks(mb), groups = [])</code></pre><p><strong>Inputs</strong></p><p><strong>Method 1 only:</strong></p><ul><li><code>m::AbstractDSGEModel</code></li><li><code>input_type::Symbol</code></li><li><code>cond_type::Symbol</code></li><li><code>class::Symbol</code></li></ul><p><strong>Method 2 only:</strong></p><ul><li><code>write_dirname::String</code>: directory to which tables are saved</li><li><code>filestring_base::Vector{String}</code>: the result of <code>filestring_base(m)</code>, typically <code>[&quot;vint=yymmdd&quot;]</code>`</li><li><code>mb_shockdec::MeansBands</code></li><li><code>mb_trend::MeansBands</code></li><li><code>mb_dettrend::MeansBands</code></li><li><code>mb_hist::MeansBands</code>: optional</li><li><code>mb_forecast::MeansBands</code>: optional</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tablevars::Vector{Symbol}</code>: which series to write tables for</li><li><code>columnvars::Vector{Symbol}</code>: which shocks to include as columns in the tables</li><li><code>groups::Vector{ShockGroup}</code>: if provided, shocks will be grouped accordingly</li></ul><p><strong>Method 1 only:</strong></p><ul><li><code>forecast_string::String</code></li><li><code>use_bdd::Symbol</code>: whether to use unbounded means and bounded bands. Applies only for <code>class(output_var) in [:forecast, :forecast4q]</code></li><li><code>read_dirname::String</code>: directory from which <code>MeansBands</code> are read in</li><li><code>write_dirname::String</code>: directory to which tables are saved</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L378-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_meansbands_tables_all-Tuple{AbstractDSGEModel,Symbol,Symbol,Array{Symbol,1}}" href="#DSGE.write_meansbands_tables_all-Tuple{AbstractDSGEModel,Symbol,Symbol,Array{Symbol,1}}"><code>DSGE.write_meansbands_tables_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_meansbands_tables_all(m, input_type, cond_type, output_vars;
    forecast_string = &quot;&quot;, dirname = tablespath(m, &quot;forecast&quot;),
    vars = [], shocks = [], shock_groups = [])</code></pre><p>Write all <code>output_vars</code> corresponding to model <code>m</code> to tables in <code>dirname</code>.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code></li><li><code>input_type::Symbol</code>: See <code>?forecast_one</code></li><li><code>cond_type::Symbol</code>: See <code>?forecast_one</code></li><li><code>output_vars::Symbol</code>: See <code>?forecast_one</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>forecast_string::String</code>: See <code>?forecast_one</code></li><li><code>vars</code>::Vector{Symbol}: Vector of economic variables for which to print <code>output_vars</code> to tables. If omitted, all shocks will be printed.</li><li><code>shocks::Vector{Symbol}</code>: Vector of shocks to print if <code>output_vars</code> contains a shock decomposition. If omitted, all shocks will be printed.</li><li><code>shock_groups::Vector{ShockGroup}</code>: if provided, shocks will be grouped accordingly in shockdec tables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L517-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_meansbands_tables_timeseries-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol}" href="#DSGE.write_meansbands_tables_timeseries-Tuple{AbstractDSGEModel,Symbol,Symbol,Symbol}"><code>DSGE.write_meansbands_tables_timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_meansbands_tables_timeseries(m, input_type, cond_type, output_var;
    forecast_string = &quot;&quot;, bdd_and_unbdd = false,
    read_dirname = workpath(m, &quot;forecast&quot;),
    write_dirname = tablespath(m, &quot;forecast&quot;), kwargs...)

write_meansbands_tables_timeseries(dirname, filestring_base, mb;
    tablevars = get_variables(mb))</code></pre><p><strong>Inputs</strong></p><p><strong>Method 1 only:</strong></p><ul><li><code>m::AbstractDSGEModel</code></li><li><code>input_type::Symbol</code></li><li><code>cond_type::Symbol</code></li><li><code>output_var::Symbol</code>: <code>class(output_var)</code> must be one of <code>[:hist, :histut, :hist4q, :forecast, :forecastut, :forecast4q, :bddforecast, :bddforecastut, :bddforecast4q, :trend, :dettrend, :histforecast, :histforecastut, :histforecast4q]</code></li><li><code>read_dirname::String</code>: directory to which meansbands objects are read from</li></ul><p><strong>Method 2 only:</strong></p><ul><li><code>read_dirname::String</code>: directory from which <code>MeansBands</code> are read in</li><li><code>write_dirname::String</code>: directory to which tables are saved</li><li><code>filestring_base::Vector{String}</code>: the result of <code>filestring_base(m)</code>, typically <code>[&quot;vint=yymmdd&quot;]</code>`</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tablevars::Vector{Symbol}</code>: which series to write tables for</li></ul><p><strong>Method 1 only:</strong></p><ul><li><code>forecast_string::String</code></li><li><code>bdd_and_unbdd::Bool</code>: whether to use unbounded means and bounded bands. Applies only for <code>class(output_var) in [:forecast, :forecast4q]</code></li><li><code>dirname::String</code>: directory to which tables are saved</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L277-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_ref_trial-Tuple{BenchmarkTools.Trial,String}" href="#DSGE.write_ref_trial-Tuple{BenchmarkTools.Trial,String}"><code>DSGE.write_ref_trial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_ref_trial(trial, trial_name)</code></pre><p>Write a reference trial to a JLD file, to act as the standard that new trials are benchmarked against.</p><p><strong>Arguments</strong></p><ul><li><code>trial::BenchmarkTools.Trial</code>: The trial object that is being written.</li><li><code>trial_name::String</code>: The name of the trial being written.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/benchmark/io.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.decomposition_forecast-Tuple{AbstractDSGEModel,DataFrames.DataFrame,Array{Float64,1},Symbol,Int64,Int64,Int64}" href="#DSGE.decomposition_forecast-Tuple{AbstractDSGEModel,DataFrames.DataFrame,Array{Float64,1},Symbol,Int64,Int64,Int64}"><code>DSGE.decomposition_forecast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decomposition_forecast(m, df, params, cond_type, keep_startdate, keep_enddate, shockdec_splitdate;
    outputs = [:forecast, :shockdec], check = false)</code></pre><p>Equivalent of <code>forecast_one_draw</code> for forecast decomposition. <code>keep_startdate = date_forecast_start(m_new)</code> corresponds to time T+1, <code>keep_enddate = date_forecast_end(m_old)</code> to time T+H, and <code>shockdec_splitdate = date_mainsample_end(m_old)</code> to time T-k.</p><p>Returns <code>out::Dict{Symbol, Array{Float64}}</code>, which has keys determined as follows:</p><ul><li><p>If <code>:forecast in outputs</code> or <code>check = true</code>:</p><ul><li><code>:forecast&lt;class&gt;</code></li></ul></li><li><p>If <code>:shockdec in outputs</code>:</p><ul><li><code>:trend&lt;class&gt;</code></li><li><code>:dettrend&lt;class&gt;</code></li><li><code>:data&lt;class&gt;</code>: like a shockdec, but only applying smoothed shocks up to <code>shockdec_splitdate</code></li><li><code>:news&lt;class&gt;</code>: like a shockdec, but only applying smoothed shocks after <code>shockdec_splitdate</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/decomp/drivers.jl#L252-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.decomposition_periods-Union{Tuple{M}, Tuple{M,M,DataFrames.DataFrame,DataFrames.DataFrame,Symbol,Symbol}} where M&lt;:AbstractDSGEModel" href="#DSGE.decomposition_periods-Union{Tuple{M}, Tuple{M,M,DataFrames.DataFrame,DataFrames.DataFrame,Symbol,Symbol}} where M&lt;:AbstractDSGEModel"><code>DSGE.decomposition_periods</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decomposition_periods(m_new, m_old, df_new, df_old, cond_new, cond_old)</code></pre><p>Returns <code>T</code>, <code>k</code>, and <code>H</code>, where:</p><ul><li>New model has <code>T</code> periods of data</li><li>Old model has <code>T-k</code> periods of data</li><li>Old and new models both forecast up to <code>T+H</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/decomp/drivers.jl#L215-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.forecast_one_draw-Tuple{AbstractDSGEModel{Float64},Symbol,Symbol,Array{Symbol,1},Array{Float64,1},DataFrames.DataFrame}" href="#DSGE.forecast_one_draw-Tuple{AbstractDSGEModel{Float64},Symbol,Symbol,Array{Symbol,1},Array{Float64,1},DataFrames.DataFrame}"><code>DSGE.forecast_one_draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forecast_one_draw(m, input_type, cond_type, output_vars, params, df;
    verbose = :low, only_filter = false)</code></pre><p>Compute <code>output_vars</code> for a single parameter draw, <code>params</code>. Called by <code>forecast_one</code>.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel{Float64}</code>: model object</li><li><code>input_type::Symbol</code>: See <code>?forecast_one</code>.</li><li><code>cond_type::Symbol</code>: See <code>?forecast_one</code>.</li><li><code>output_vars::Vector{Symbol}</code>: vector of desired output variables. See Outputs section</li><li><code>params::Vector{Float64}</code>: parameter vector</li><li><code>df::DataFrame</code>: historical data.</li><li><code>verbose::Symbol</code>: desired frequency of function progress messages printed to standard out. One of <code>:none</code>, <code>:low</code>, or <code>:high</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>forecast_outputs::Dict{Symbol, Array{Float64}}</code>: dictionary of forecast outputs. Keys are <code>output_vars</code>, which is some subset of:</li></ul><pre><code class="language-none">  - `:histstates`: `Matrix{Float64}` of smoothed historical states
  - `:histobs`: `Matrix{Float64}` of smoothed historical data
  - `:histpseudo`: `Matrix{Float64}` of smoothed historical
    pseudo-observables
  - `:histshocks`: `Matrix{Float64}` of smoothed historical shocks
  - `:forecaststates`: `Matrix{Float64}` of forecasted states
  - `:forecastobs`: `Matrix{Float64}` of forecasted observables
  - `:forecastpseudo`: `Matrix{Float64}` of forecasted pseudo-observables
  - `:forecastshocks`: `Matrix{Float64}` of forecasted shocks
  - `:bddforecaststates`, `:bddforecastobs`, `:bddforecastpseudo`, and
    `:bddforecastshocks`: `Matrix{Float64}`s of forecasts where we enforce
    the zero lower bound to be `forecast_zlb_value(m)`
  - `:shockdecstates`: `Array{Float64, 3}` of state shock decompositions
  - `:shockdecobs`: `Array{Float64, 3}` of observable shock decompositions
  - `:shockdecpseudo`: `Array{Float64, 3}` of pseudo-observable shock
    decompositions
  - `:dettrendstates`: `Matrix{Float64}` of state deterministic trends
  - `:dettrendobs`: `Matrix{Float64}` of observable deterministic trends
  - `:dettrendpseudo`: `Matrix{Float64}` of pseudo-observable deterministic
    trends
  - `:trendstates`: `Vector{Float64}` of state trends, i.e. the `CCC` vector
  - `:trendobs`: `Vector{Float64}` of observable trends, i.e. the `DD` vector
  - `:trendpseudo`: `Vector{Float64}` of pseudo-observable trends, i.e. the
    `DD_pseudo` vector
  - `:irfstates`: `Array{Float64, 3}` of state impulse responses
  - `:irfobs`: `Array{Float64, 3}` of observable impulse responses
  - `:irfpseudo`: `Array{Float64, 3}` of pseudo-observable impulse responses</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/drivers.jl#L720-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.prepare_forecast_inputs!-Union{Tuple{S}, Tuple{AbstractDSGEModel{S},Symbol,Symbol,Array{Symbol,1}}} where S&lt;:AbstractFloat" href="#DSGE.prepare_forecast_inputs!-Union{Tuple{S}, Tuple{AbstractDSGEModel{S},Symbol,Symbol,Array{Symbol,1}}} where S&lt;:AbstractFloat"><code>DSGE.prepare_forecast_inputs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prepare_forecast_inputs!(m, input_type, cond_type, output_vars;
    df = DataFrame(), verbose = :none)</code></pre><p>Add required outputs using <code>add_requisite_output_vars</code> and load data if necessary.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code>: model object</li><li><code>input_type::Symbol</code>: See <code>?forecast_one</code>.</li><li><code>cond_type::Symbol</code>: See <code>?forecast_one</code>.</li><li><code>output_vars::Vector{Symbol}</code>: vector of desired output variables. See <code>?forecast_one_draw</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>df::DataFrame</code>: historical data. If <code>cond_type in [:semi, :full]</code>, then the  final row of <code>df</code> should be the period containing conditional data. If not  provided, then <code>df</code> will be loaded using <code>load_data</code> with the appropriate  <code>cond_type</code></li><li><code>only_filter::Bool</code>: do not run the smoother and only run the filter. This limits the number of output variables which can be calculated.</li><li><code>verbose::Symbol</code>: desired frequency of function progress messages printed to standard out. One of <code>:none</code>, <code>:low</code>, or <code>:high</code></li></ul><p><strong>Outputs</strong></p><ul><li><code>output_vars</code></li><li><code>df</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/drivers.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.default_update_regime_eqcond_info!-Tuple{AbstractDSGEModel,AbstractDict{Int64,EqcondEntry},Int64,Int64,AltPolicy}" href="#DSGE.default_update_regime_eqcond_info!-Tuple{AbstractDSGEModel,AbstractDict{Int64,EqcondEntry},Int64,Int64,AltPolicy}"><code>DSGE.default_update_regime_eqcond_info!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">default_update_regime_eqcond_info!(m::AbstractDSGEModel, eqcond_dict::AbstractDict{Int64, EqcondEntry},
                                   zlb_start_regime::Int64, liftoff_regime::Int64, liftoff_policy::AltPolicy)</code></pre><p>is the default method for updating the setting <code>regime_eqcond_info</code> during the automatic endogenous ZLB enforcement as a temporary policy.</p><p>The input <code>eqcond_dict</code> should be a dictionary whose historical/conditional horizon regimes should already be set (and won&#39;t be affected by this function. The regimes which will be altered are those for which the temporary ZLB will apply (according to <code>zlb_start_regime</code> and <code>liftoff_regime</code>), and if there is time-varying credibility, forecast regimes past the ZLB.</p><p>In general, other implementations of the <code>update_regime_eqcond_info!</code> function should not change the EqcondEntry during historical/conditional horizon regimes, but any other regimes in the forecast horizon should be/can be set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/forecast.jl#L887-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.forecast_scenario_draw-Tuple{AbstractDSGEModel,Scenario,System,Int64}" href="#DSGE.forecast_scenario_draw-Tuple{AbstractDSGEModel,Scenario,System,Int64}"><code>DSGE.forecast_scenario_draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forecast_scenario_draw(m, scen::Scenario, system, draw_index)</code></pre><p>Filter shocks and use them to forecast the <code>draw_index</code>th draw of <code>scen</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/forecast.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_scenario_forecasts-Tuple{AbstractDSGEModel,Dict{Symbol,String},Dict{Symbol,Array{Float64,N} where N}}" href="#DSGE.write_scenario_forecasts-Tuple{AbstractDSGEModel,Dict{Symbol,String},Dict{Symbol,Array{Float64,N} where N}}"><code>DSGE.write_scenario_forecasts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_scenario_forecasts(m, scenario_output_files, forecast_output;
    verbose = :low)</code></pre><p>Write scenario outputs in <code>forecast_output</code> to <code>values(scenario_output_files)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/forecast.jl#L131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.shock_decompositions_sequence-Union{Tuple{S}, Tuple{AbstractDSGEModel,System{S},Array{S,2}}} where S&lt;:AbstractFloat" href="#DSGE.shock_decompositions_sequence-Union{Tuple{S}, Tuple{AbstractDSGEModel,System{S},Array{S,2}}} where S&lt;:AbstractFloat"><code>DSGE.shock_decompositions_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shock_decompositions_sequence(m, system, histshocks, n_back, back_shocks)

shock_decompositions_sequence(system, forecast_horizons, histshocks, start_index,
    end_index, n_back, back_shocks)

shock_decompositions_sequence(m, system, histshocks, start_date, end_date, n_back, back_shocks)

shock_decompositions_sequence(m, system, forecast_horizons, histshocks, start_index,
    end_index, regime_inds, cond_type, n_back, back_shocks)

shock_decompositions_sequence(m, system, old_system,
                              histshocks, old_histshocks, start_date, end_date,
                              cond_type; full_shock_decomp, n_back, back_shocks)

shock_decompositions_sequence(m, system, old_system,
                              forecast_horizons, histshocks, old_histshocks,
                              start_index, end_index,
                              regime_inds, cond_type; full_shock_decomp, n_back, back_shocks)</code></pre><p><strong>Inputs</strong></p><ul><li><code>system::System{S}</code> or <code>RegimeSwitchingSystem{S}</code>: state-space system matrices</li><li><code>forecast_horizons::Int</code>: number of periods ahead to forecast</li><li><code>histshocks::Matrix{S}</code>: matrix of size <code>nshocks</code> x <code>hist_periods</code> of historical smoothed shocks</li><li><code>start_index::Int</code>: first index from which to return computed shock decompositions</li><li><code>end_index::Int</code>: last index for which to return computed shock decompositions</li><li><code>start_date::Date</code>: initial date for deterministic trends</li><li><code>end_date::Date</code>: final date for deterministic trends</li><li><code>regime_inds::Vector{UnitRange}</code>: indices of the data corresponding to each regime.</li><li><code>old_system::RegimeSwitchingSystem{S}</code>: state-space system matrices for the old model</li><li><code>old_histshocks::Matrix{S}</code>: matrix of size <code>nshocks</code> x <code>hist_periods</code> of historical smoothed shocks using the old system</li><li><code>full_shock_decomp::Bool</code>: If true for old_system case, return difference in shockdecs   between all shocks for the new and old systems. Else, return old system&#39;s shocks   with 1 cumulative AIT shock added on.</li></ul><p>where <code>S&lt;:AbstractFloat</code>.</p><p><strong>Outputs</strong></p><ul><li><code>states::Array{S, 4}</code>: matrix of size <code>nhistperiods</code> x <code>nstates</code> x <code>nperiods</code> x <code>nshocks</code> of state shock decompositions</li><li><code>obs::Array{S, 4}</code>: matrix of size <code>nhistperiods</code> x <code>nobs</code> x <code>nperiods</code> x <code>nshocks</code> of observable shock decompositions</li><li><code>pseudo::Array{S, 4}</code>: matrix of size <code>nhistperiods</code> x <code>npseudo</code> x <code>nperiods</code> x <code>nshocks</code> of pseudo-observable shock decompositions</li></ul><p>where <code>nperiods =</code>end<em>index - start</em>index + 1<code>and</code>nhistperiods<code>=</code>size(histshocks,2)`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/shock_decompositions.jl#L764-L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.combine_raw_forecast_output_and_metadata-Tuple{AbstractDSGEModel,Dict{Symbol,String}}" href="#DSGE.combine_raw_forecast_output_and_metadata-Tuple{AbstractDSGEModel,Dict{Symbol,String}}"><code>DSGE.combine_raw_forecast_output_and_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combine_raw_forecast_output_and_metadata(m, forecast_output_files; verbose = :low)</code></pre><p>Writes the raw forecast output data (<code>arr</code>) saved in the temporary h5 file to the jld2 file containing the rest of the forecast metadata. The intermediary h5 step exists because jld2 does not support chunked memory assignment in the same way that jld and h5 permitted previously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L382-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.count_scenario_draws!-Tuple{AbstractDSGEModel,Scenario}" href="#DSGE.count_scenario_draws!-Tuple{AbstractDSGEModel,Scenario}"><code>DSGE.count_scenario_draws!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">count_scenario_draws!(m, scen::Scenario)</code></pre><p>Return the number of draws for <code>scen</code>, determined using <code>get_scenario_input_file(m, scen)</code>, and update the <code>n_draws</code> field of <code>scen</code> with this count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_scenario_mb_metadata-Tuple{AbstractDSGEModel,SingleScenario,Symbol}" href="#DSGE.get_scenario_mb_metadata-Tuple{AbstractDSGEModel,SingleScenario,Symbol}"><code>DSGE.get_scenario_mb_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_mb_metadata(m, scen::SingleScenario, output_var)

get_scenario_mb_metadata(m, agg::ScenarioAggregate, output_var)</code></pre><p>Return the <code>MeansBands</code> metadata dictionary for <code>scen</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L148-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.load_scenario_targets!-Tuple{AbstractDSGEModel,Scenario,Int64}" href="#DSGE.load_scenario_targets!-Tuple{AbstractDSGEModel,Scenario,Int64}"><code>DSGE.load_scenario_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_scenario_targets!(m, scen::Scenario, draw_index)</code></pre><p>Add the targets from the <code>draw_index</code>th draw of the raw scenario targets to <code>scen.targets</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/scenarios/io.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_forecast_metadata-Tuple{JLD2.JLDFile}" href="#DSGE.read_forecast_metadata-Tuple{JLD2.JLDFile}"><code>DSGE.read_forecast_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_forecast_metadata(file::JLDFile)</code></pre><p>Read metadata from forecast output files. This includes dictionaries mapping dates, as well as state, observable, pseudo-observable, and shock names, to their respective indices in the saved forecast output array. Depending on the <code>output_var</code>, the saved dictionaries might include:</p><ul><li><code>date_indices::Dict{Date, Int}</code>: not saved for IRFs</li><li><code>state_indices::Dict{Symbol, Int}</code></li><li><code>observable_indices::Dict{Symbol, Int}</code></li><li><code>pseudoobservable_indices::Dict{Symbol, Int}</code></li><li><code>shock_indices::Dict{Symbol, Int}</code></li><li><code>state_revtransforms::Dict{Symbol, Symbol}</code>: states are not transformed, so all values are <code>:identity</code></li><li><code>observable_revtransforms::Dict{Symbol, Symbol}</code></li><li><code>pseudoobservable_revtransforms::Dict{Symbol, Symbol}</code></li><li><code>shock_revtransforms::Dict{Symbol, Symbol}</code>: shocks are not transformed, so all values are <code>:identity</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L413-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_forecast_series-Tuple{String,Symbol,Int64}" href="#DSGE.read_forecast_series-Tuple{String,Symbol,Int64}"><code>DSGE.read_forecast_series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_forecast_series(filepath, product, var_ind)
read_forecast_series(filepath, var_ind, shock_ind)</code></pre><p>Read only the forecast output for a particular variable (e.g. for a particular observable) and possibly a particular shock. Result should be a matrix of size <code>ndraws</code> x <code>nperiods</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L556-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_regime_switching_trend-Tuple{String,Int64}" href="#DSGE.read_regime_switching_trend-Tuple{String,Int64}"><code>DSGE.read_regime_switching_trend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_regime_switching_trend(filepath, var_ind)</code></pre><p>Read only the trend output for a particular variable (e.g. for a particular observable). Result should be a matrix of size <code>ndraws</code> × <code>n_regimes</code> or <code>ndraws</code> × <code>n_data_periods</code>, depending on whether the state space system was time-varying or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L616-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_forecast_block-Tuple{Any,Array,AbstractRange{Int64}}" href="#DSGE.write_forecast_block-Tuple{Any,Array,AbstractRange{Int64}}"><code>DSGE.write_forecast_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_forecast_block(file::JLDFile, arr::Array, block_number::Int,
    block_inds::AbstractRange{Int64})</code></pre><p>Writes <code>arr</code> to the subarray of <code>file</code> indicated by <code>block_inds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L361-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_forecast_metadata-Tuple{AbstractDSGEModel,JLD2.JLDFile,Symbol}" href="#DSGE.write_forecast_metadata-Tuple{AbstractDSGEModel,JLD2.JLDFile,Symbol}"><code>DSGE.write_forecast_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_forecast_metadata(m::AbstractDSGEModel, file::JLDFile, var::Symbol)</code></pre><p>Write metadata about the saved forecast output <code>var</code> to <code>filepath</code>.</p><p>Specifically, we save dictionaries mapping dates, as well as state, observable, pseudo-observable, and shock names, to their respective indices in the saved forecast output array. The saved dictionaries include:</p><ul><li><code>date_indices::Dict{Date, Int}</code>: saved for all forecast outputs except IRFs</li><li><code>state_names::Dict{Symbol, Int}</code>: saved for <code>var in [:histstates, :forecaststates, :shockdecstates]</code></li><li><code>observable_names::Dict{Symbol, Int}</code>: saved for <code>var in [:forecastobs, :shockdecobs]</code></li><li><code>observable_revtransforms::Dict{Symbol, Symbol}</code>: saved identifiers for reverse transforms used for observables</li><li><code>pseudoobservable_names::Dict{Symbol, Int}</code>: saved for <code>var in [:histpseudo, :forecastpseudo, :shockdecpseudo]</code></li><li><code>pseudoobservable_revtransforms::Dict{Symbol, Symbol}</code>: saved identifiers for reverse transforms used for pseudoobservables</li><li><code>shock_names::Dict{Symbol, Int}</code>: saved for <code>var in [:histshocks, :forecastshocks, :shockdecstates, :shockdecobs, :shockdecpseudo]</code></li></ul><p>Note that we don&#39;t save dates or transformations for impulse response functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L265-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_forecast_outputs-Tuple{AbstractDSGEModel,Symbol,Array{Symbol,1},Dict{Symbol,String},Dict{Symbol,Array{Float64,N} where N}}" href="#DSGE.write_forecast_outputs-Tuple{AbstractDSGEModel,Symbol,Array{Symbol,1},Dict{Symbol,String},Dict{Symbol,Array{Float64,N} where N}}"><code>DSGE.write_forecast_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_forecast_outputs(m, output_vars, forecast_output_files, forecast_output;
    df = DataFrame(), block_number = Nullable{Int64}(), block_inds = 1:0,
    verbose = :low)</code></pre><p>Writes the elements of <code>forecast_output</code> indexed by <code>output_vars</code> to file, given <code>forecast_output_files</code>, which maps <code>output_vars</code> to file names.</p><p>If <code>output_vars</code> contains <code>:histobs</code>, data must be passed in as <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/forecast/io.jl#L184-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.write_meansbands_table-Tuple{String,Array{String,1},MeansBands,DataFrames.DataFrame,Symbol}" href="#DSGE.write_meansbands_table-Tuple{String,Array{String,1},MeansBands,DataFrames.DataFrame,Symbol}"><code>DSGE.write_meansbands_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_meansbands_table(dirname, filestring_base, mb, df, tablevar)</code></pre><p><strong>Inputs</strong></p><ul><li><code>dirname::String</code>: directory to which tables are saved. Defaults to <code>tablespath(m, &quot;forecast&quot;)</code></li><li><code>filestring_base::Vector{String}</code>: the result of <code>filestring_base(m)</code>, typically <code>[&quot;vint=yymmdd&quot;]</code>`</li><li><code>mb::MeansBands</code>: used for computing the output file name</li><li><code>df::DataFrame</code>: the result of calling one of <code>prepare_meansbands_table_timeseries</code>, <code>prepare_means_table_shockdec</code>, or <code>prepare_means_table, irf</code></li><li><code>tablevar::Symbol</code>: used for computing the base output file name</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/e8699527ad8309756e0411d59bf985103b396417/src/analysis/io.jl#L482-L498">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../estimation/">« Estimation</a><a class="docs-footer-nextpage" href="../irf/">Impulse Response Functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 23 August 2021 18:35">Monday 23 August 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
