<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Impulse Response Functions · DSGE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DSGE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DSGE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../model_design/">Model Design</a></li><li><a class="tocitem" href="../special_model_types/">Special Model Types</a></li><li><a class="tocitem" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="tocitem" href="../input_data/">Input Data</a></li><li><a class="tocitem" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="tocitem" href="../implementation_details/">Implementation Details</a></li><li><a class="tocitem" href="../solving/">Solving the Model</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../forecast/">Forecasting</a></li><li class="is-active"><a class="tocitem" href>Impulse Response Functions</a><ul class="internal"><li><a class="tocitem" href="#DSGE-Impulse-Responses-1"><span>DSGE Impulse Responses</span></a></li><li><a class="tocitem" href="#VAR-Impulse-Responses-1"><span>VAR Impulse Responses</span></a></li><li><a class="tocitem" href="#DSGE-VAR-Impulse-Responses-1"><span>DSGE-VAR Impulse Responses</span></a></li><li><a class="tocitem" href="#VECM-Impulse-Responses-1"><span>VECM Impulse Responses</span></a></li><li><a class="tocitem" href="#DSGE-VECM-Impulse-Responses-1"><span>DSGE-VECM Impulse Responses</span></a></li><li><a class="tocitem" href="#Wrappers-for-Impulse-Response-Functions-1"><span>Wrappers for Impulse Response Functions</span></a></li><li><a class="tocitem" href="#Docstrings-1"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../means_bands/">Computing Means and Bands</a></li><li><a class="tocitem" href="../altpolicy/">Alternative Policies</a></li><li><a class="tocitem" href="../scenarios/">Alternative Scenarios</a></li><li><a class="tocitem" href="../forecast_decomposition/">Forecast Decomposition</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="tocitem" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="tocitem" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Impulse Response Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Impulse Response Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/docs/src/irf.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Impulse-Responses-1"><a class="docs-heading-anchor" href="#Impulse-Responses-1">Impulse Responses</a><a class="docs-heading-anchor-permalink" href="#Impulse-Responses-1" title="Permalink"></a></h1><p>We provide many different types of impulse responses for DSGEs, VARs, VECMs, DSGE-VARs, and DSGE-VECMs. The forecast step allows the user to automatically compute &quot;structural&quot; impulse responses specifically for DSGEs, but for some purposes, a user may just want impulse responses without having to compute any other quantities. We provide this functionality with the <code>impulse_responses</code> function. See the end of this page for the docstrings of all available impulse response functions.</p><p>We overload impulse_responses to cover specific use cases. For any <code>AbstractDSGEModel</code>, we can compute the impulse responses over a specified horizon for all endogenous state variables, observables, and pseudo-observables by running</p><pre><code class="language-julia">m = AnSchorfheide()
system = compute_system(m)
horizon = 40
states_irf, obs_irf, pseudo_irf = impulse_response(system, horizon)</code></pre><p>For an <code>AbstractRepModel</code> (a subtype of <code>AbstractDSGEModel</code> for representative agent models), we can also grab the impulse responses by running</p><pre><code class="language-julia">states_irf, obs_irf, pseudo_irf = impulse_response(m, system)</code></pre><p>This use case requires the user to add a setting under the key <code>:impulse_response_horizons</code>, which is set by default to 40.</p><p>If a user wants to specify a subset of the exogenous shocks and the size of those shocks, the user can run</p><pre><code class="language-julia">shock_names = [:g_sh, :b_sh]
shock_values = [1.0, 1.0]
impulse_responses(m, system, horizon, shock_names, shock_values)</code></pre><p>For the response of an endogenous state or observable to a specific shock,</p><pre><code class="language-julia">shock_name  =  :g_sh
var_name = :obs_gdp
var_value = 0.
impulse_responses(m, system, horizon, shock_name , var_name, var_value)</code></pre><h2 id="DSGE-Impulse-Responses-1"><a class="docs-heading-anchor" href="#DSGE-Impulse-Responses-1">DSGE Impulse Responses</a><a class="docs-heading-anchor-permalink" href="#DSGE-Impulse-Responses-1" title="Permalink"></a></h2><p>There are two categories of impulse responses for DSGEs provided by DSGE.jl. It is easy to distinguish them by examining the state space form of a DSGE model (see <a href="../solving/#solving-dsge-doc-1">Solving</a>):</p><div>\[\begin{aligned}
s_t &amp;= T s_{t-1} + R \epsilon_t + C &amp; \epsilon_t &amp;\sim N(0, Q) &amp; \mathrm{(transition)} \\
y_t &amp;= Z s_t + D + u_t &amp; u_t &amp;\sim N(0, E) &amp; \mathrm{(measurement)}
\end{aligned}\]</div><p>Impulse responses in the first category are &quot;structural&quot; impulse responses, which are the response of states and observables to the exogenous structural shocks <span>$\epsilon_t$</span>.</p><p>Impulse responses in the second category are &quot;observables-identified&quot; impulse responses. First, we may suppose that the measurement equation generically follows</p><div>\[y_t = F(s_t) + \eta_t,\]</div><p>where <span>$F(\cdot)$</span> is some function of the unknown states <span>$s_t$</span>, and <span>$\eta_t$</span> are random innovation to the observables <span>$y_t$</span>. By innovations, we mean that these random variables are potentially endogenous shocks, i.e. shocks which do not have a causal interpretation. An &quot;observables-identified&quot; impulse response specifies a certain response of <span>$y_t$</span> to the innovations <span>$\eta_t$</span>, and uses this response to identify the underlying structural shocks which are consistent with these innovations. A DSGE identifies these innovations using the state space form of a DSGE.</p><p>We provide three types of &quot;observables-identified&quot; impulse responses for DSGEs.</p><ul><li>Short-Run Cholesky</li><li>Long-Run Cholesky</li><li>Maximizing Explained Cyclical Variance</li></ul><p>We document the details of the identification in the docstrings of these impulse response functions. For the first two types of impulse responses, search the docstrings at the end of the page for</p><pre><code class="language-none">function impulse_responses(system::System{S}, horizon::Int, permute_mat::AbstractMatrix{T},
                           shocks::AbstractVector{S} = Vector{S}(undef, 0);
                           restriction::Symbol = :short_run, flip_shocks::Bool = false,
                           get_shocks::Bool = false) where {S &lt;: Real, T &lt;: Number}</code></pre><p>For the third type of impulse response, search for</p><pre><code class="language-none">function impulse_responses(system::System{S}, horizon::Int, frequency_band::Tuple{S,S},
                           n_obs_shock::Int; flip_shocks::Bool = false,
                           get_shocks::Bool = false) where {S &lt;: Real}</code></pre><h2 id="VAR-Impulse-Responses-1"><a class="docs-heading-anchor" href="#VAR-Impulse-Responses-1">VAR Impulse Responses</a><a class="docs-heading-anchor-permalink" href="#VAR-Impulse-Responses-1" title="Permalink"></a></h2><p>While we have not yet implemented a VAR model, we do have impulse responses often used on VARs because of DSGE-VARs. Consider the VAR</p><div>\[y_t = X_t \beta + \epsilon_t,\]</div><p>where <span>$X_t$</span> is a matrix of the lags of <span>$y_t$</span>, <span>$\beta$</span> are the VAR coefficients, and <span>$\epsilon_t \sim N(0, \Omega)$</span> are the innovations to observables.</p><p>We provide three types of impulse responses, each of which provide a different way of identifying orthogonalized shocks from the innovations.</p><ul><li>Short-Run Cholesky</li><li>Long-Run Cholesky</li><li>Maximizing Explained Cyclical Variance</li></ul><p>These impulse responses are named the same as the observables-identified impulse responses for DSGEs because they are considering the same response of observables to the innovations. However, the treatment of identification is different when using a VAR because the mathematical structure of a VAR is not the same as a DSGE&#39;s. As a result, there are slight differences between these impulse responses and the observables-identified DSGE impulse responses.</p><pre><code class="language-none">impulse_responses(β, Σ, n_obs_shock, horizon, shock_size = 1;
    method = :cholesky, flip_shocks = false, use_intercept = true,
    frequency_band = (2π/32, 2π/6)) where {S&lt;:Real}</code></pre><h2 id="DSGE-VAR-Impulse-Responses-1"><a class="docs-heading-anchor" href="#DSGE-VAR-Impulse-Responses-1">DSGE-VAR Impulse Responses</a><a class="docs-heading-anchor-permalink" href="#DSGE-VAR-Impulse-Responses-1" title="Permalink"></a></h2><p>There are two types of impulse responses we can compute for a DSGE-VAR. For both types, we first draw from the posterior distributions of the <span>$VAR(p)$</span> coefficients and innovations variance-covariance matrix, where <span>$p$</span> is the number of lags. With these draws, we can do one of two things:</p><ol><li>Compute the VAR impulse response implied by the draws.</li><li>Use the DSGE&#39;s structural impact response (i.e. the first period of an impulse response) to identify a mapping from the (endogenous) innovations in the VAR to the structural shocks of the DSGE.</li></ol><p>The first type of impulse response uses the same code as the VAR impulse responses once we compute the coefficients and innovations variance-covariance matrix. We call the second type of impulse responses &quot;DSGE-VAR rotation impulse responses&quot; because we effectively use the DSGE to identify a rotation matrix.</p><p>For the first type of impulse response, see</p><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVARModel{S}, data::AbstractArray{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0 ,use_intercept::Bool = false,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}

function impulse_responses(m::AbstractDSGEVARModel{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0 ,use_intercept::Bool = false,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}</code></pre><p>The second function is for the specific case when <span>$\lambda = \infty$</span>, where the data does not matter for the impulse response.</p><p>For the second type of impulse responses, see</p><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVARModel{S}, data::AbstractArray{S},
    X̂::Matrix{S} = Matrix{S}(undef, 0, 0);
    horizon::Int = 0, MM::Matrix{S} = Matrix{S}(undef, 0, 0),
    flip_shocks::Bool = false, draw_shocks::Bool = false,
    deviations::Bool = false,
    verbose::Symbol = :none) where {S &lt;: Real}</code></pre><h2 id="VECM-Impulse-Responses-1"><a class="docs-heading-anchor" href="#VECM-Impulse-Responses-1">VECM Impulse Responses</a><a class="docs-heading-anchor-permalink" href="#VECM-Impulse-Responses-1" title="Permalink"></a></h2><p>While we have not yet implemented a VECM model, we do have impulse responses often used on VECMs because of DSGE-VECMs. Consider the VECM</p><div>\[\Delta y_t = e_{t - 1} \beta_e +  X_t \beta_v + \epsilon_t,\]</div><p>where <span>$e_{t - 1}$</span> are cointegrating relationships (the error correction terms); <span>$X_t$</span> is a matrix of the lags of <span>$\Delta y_t$</span>; <span>$\beta_e$</span> and <span>$\beta_v$</span> are the VECM coefficients; and <span>$\epsilon_t \sim N(0, \Omega)$</span> are the innovations to observables. We identify orthogonalized shocks for VECMs from the innovations using the short-run Cholesky method. Other methods have yet to be implemented, hence passing keywords specific to these methods will not do anything (namely <code>frequency_band</code>). Find the docstring of the following function for details.</p><pre><code class="language-none">impulse_responses(β, Σ, coint_mat, n_obs_shock, horizon, shock_size = 1;
    method = :cholesky, flip_shocks = false, use_intercept = true,
    frequency_band = (2π/32, 2π/6)) where {S&lt;:Real}</code></pre><h2 id="DSGE-VECM-Impulse-Responses-1"><a class="docs-heading-anchor" href="#DSGE-VECM-Impulse-Responses-1">DSGE-VECM Impulse Responses</a><a class="docs-heading-anchor-permalink" href="#DSGE-VECM-Impulse-Responses-1" title="Permalink"></a></h2><p>Most of the impulse responses for DSGE-VARs have been implemented for DSGE-VECMs. The two impulse responses that have not been implemented, due to the differences in VECMs and VARs, are the <code>maxBC</code> and <code>cholesky_long_run</code> impulse responses. For the first type of impulse responses, which use the VECM impulse response code, see the functions</p><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVECMModel{S}, data::AbstractArray{S},
                           coint_mat::AbstractMatrix{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0 ,use_intercept::Bool = false,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}

function impulse_responses(m::AbstractDSGEVECMModel{S}, coint_mat::AbstractMatrix{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0 ,use_intercept::Bool = false,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}</code></pre><p>The second function is for the specific case when <span>$\lambda = \infty$</span>, where the data does not matter for the impulse response.</p><p>For the second type of impulse responses, which we call rotation impulse responses, see</p><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVECMModel{S}, data::AbstractArray{S},
                           coint_mat::AbstractMatrix{S},
                           X̂::Matrix{S} = Matrix{S}(undef, 0, 0);
                           horizon::Int = 0, MM::Matrix{S} = Matrix{S}(undef, 0, 0),
                           flip_shocks::Bool = false, draw_shocks::Bool = false,
                           deviations::Bool = false,
                           verbose::Symbol = :none) where {S &lt;: Real}</code></pre><h2 id="Wrappers-for-Impulse-Response-Functions-1"><a class="docs-heading-anchor" href="#Wrappers-for-Impulse-Response-Functions-1">Wrappers for Impulse Response Functions</a><a class="docs-heading-anchor-permalink" href="#Wrappers-for-Impulse-Response-Functions-1" title="Permalink"></a></h2><p>The <code>forecast_one</code> function provides a wrapper for computing structural DSGE impulse responses when drawing from a distribution of parameters and for saving these impulse responses as <code>MeansBands</code> objects (see <a href="../means_bands/#means-bands-1">Computing Means and Bands</a>).</p><p>However, <code>forecast_one</code> currently cannot compute observables-identified DSGE impulse responses, VAR impulse responses, or DSGE-VAR impulse responses, and we do not plan on modifying <code>forecast_one</code> to make it possible to do so. Instead, we provide three wrapper functions specifically for computing means and bands for these impulse responses. Please see their docstrings for details. The first wrapper is for observables-identified DSGE impulse responses, and the second two are for DSGE-VAR impulse responses. The first one applies generically to a DSGE-VAR with any prior weight <span>$\lambda$</span>, but the second one is a convenience wrapper for the case of <span>$\lambda = \infty$</span>, which is equivalent to computing the impulse responses of the VAR approximation to a DSGE.</p><p>No wrappers for DSGE-VECM impulse responses have been implemented because we have not constructed a DSGE model that can be interfaced with the <code>DSGEVECM</code> type yet. As a result, there are no explicit test cases for these wrappers. We have decided against implementing wrappers for DSGE-VECM impulse responses until we have test cases to guarantee the wrappers do not have bugs.</p><p>For observables-identified DSGE impulse responses, find</p><pre><code class="language-none">function impulse_responses(m::AbstractDSGEModel, paras::Matrix{S},
                           input_type::Symbol, method::Symbol, n_obs_shock::Int,
                           output_vars::Vector{Symbol} =
                           [:irfstates, :irfobs, :irfpseudo]; parallel::Bool = false,
                           permute_mat::Matrix{S} = Matrix{Float64}(undef,0,0),
                           frequency_band::Tuple{S,S} = (2*π/32, 2*π/6),
                           flip_shocks::Bool = false,
                           density_bands::Vector{Float64} = [.5, .6, .7, .8, .9],
                           create_meansbands::Bool = false, test_meansbands::Bool = false,
                           minimize::Bool = true,
                           forecast_string::String = &quot;&quot;,
                           do_rev_transform::Bool = false,
                           verbose::Symbol = :high) where {S&lt;:Real}</code></pre><p>For DSGE-VAR impulse responses, find</p><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVARModel{S}, paras::Matrix{S},
                           data::Matrix{S}, input_type::Symbol, method::Symbol;
                           parallel::Bool = false,
                           frequency_band::Tuple{S,S} = (2*π/32, 2*π/6),
                           n_obs_shock::Int = 1, draw_shocks::Bool = false,
                           flip_shocks::Bool = false,
                           X̂::AbstractMatrix{S} = Matrix{S}(undef, 0, 0),
                           deviations::Bool = false
                           density_bands::Vector{Float64} = [.5, .6, .7, .8, .9],
                           create_meansbands::Bool = false, test_meansbands::Bool = false,
                           minimize::Bool = true,
                           forecast_string::String = &quot;&quot;,
                           verbose::Symbol = :high) where {S&lt;:Real}</code></pre><p>For the impulse response of a VAR approximation to a DSGE, find</p><pre><code class="language-none">function impulse_responses(m::AbstractDSGEModel, paras::Union{Vector{S}, Matrix{S}},
                           input_type::Symbol, method::Symbol,
                           lags::Int, observables::Vector{Symbol},
                           shocks::Vector{Symbol},
                           n_obs_shock::Int; parallel::Bool = false,
                           frequency_band::Tuple{S,S} = (2*π/32, 2*π/6),
                           flip_shocks::Bool = false,
                           use_intercept::Bool = false,
                           density_bands::Vector{Float64} = [.5, .6, .7, .8, .9],
                           create_meansbands::Bool = false,
                           minimize::Bool = true,
                           forecast_string::String = &quot;&quot;,
                           verbose::Symbol = :high) where {S&lt;:Real}</code></pre><h2 id="Docstrings-1"><a class="docs-heading-anchor" href="#Docstrings-1">Docstrings</a><a class="docs-heading-anchor-permalink" href="#Docstrings-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DSGE.impulse_responses" href="#DSGE.impulse_responses"><code>DSGE.impulse_responses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impulse_responses(m, system)

impulse_responses(system, horizon)</code></pre><p>Compute impulse responses for a single draw.</p><p><strong>Inputs</strong></p><ul><li><code>m::AbstractDSGEModel</code>: model object</li><li><code>system::System{S}</code>: state-space system matrices</li><li><code>horizon::Int</code>: number of periods ahead to forecast</li><li><code>flip_shocks::Bool</code>: Whether to compute IRFs in response to a positive shock (by default the shock magnitude is a negative 1 std. shock)</li></ul><p>where <code>S&lt;:AbstractFloat</code></p><p><strong>Outputs</strong></p><ul><li><code>states::Array{S, 3}</code>: matrix of size <code>nstates</code> x <code>horizon</code> x <code>nshocks</code> of state impulse response functions</li><li><code>obs::Array{S, 3}</code>: matrix of size <code>nobs</code> x <code>horizon</code> x <code>nshocks</code> of observable impulse response functions</li><li><code>pseudo::Array{S, 3}</code>: matrix of size <code>npseudo</code> x <code>horizon</code> x <code>nshocks</code> of pseudo-observable impulse response functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/impulse_responses.jl#L1-L27">source</a></section><section><div><pre><code class="language-none">function impulse_responses(system::System{S}, horizon::Int, permute_mat::AbstractMatrix{T},
                           shocks::AbstractVector{S} = Vector{S}(undef, 0);
                           restriction::Symbol = :short_run, flip_shocks::Bool = false,
                           get_shocks::Bool = false) where {S &lt;: Real, T &lt;: Number}</code></pre><p>computes impulse responses using a Cholesky-identified shock to observables, with the ability to apply a permutation matrix.</p><p><strong>Inputs</strong></p><ul><li><code>system::System{S}</code>: state-space system matrices</li><li><code>horizon::Int</code>: number of periods ahead to forecast</li><li><code>permute_mat::AbstractMatrix{T}</code>: permutation matrix</li><li><code>shocks::AbstractVector{S}</code>: vector of orthogonal shocks to observables.   See the section Restriction Types below for a mathematical explanation.   If no vector is provided, then we assume the user wants a shock vector   whose first entry is one and all other entries are zero (a 1 standard deviation   shock to the innovation affecting the first variable).</li><li><code>restriction::Symbol</code>: type of restriction for the Cholesky identification.   Can be either <code>:short_run</code> or <code>:long_run</code>. We also let <code>:cholesky</code> refer   specifically to the <code>:short_run</code> restriction and   <code>:choleskyLR</code> or <code>:cholesky_long_run</code> refer to the <code>:long_run</code> restriction.</li><li><code>flip_shocks::Bool</code>: Whether to compute IRFs in response to a positive shock   (by default the shock magnitude is a negative 1 std. shock)</li><li><code>get_shocks::Bool</code>: Whether to return the Cholesky-identified shocks and the   underlying structural shocks</li></ul><p><strong>Outputs</strong></p><ul><li><code>states::Matrix{S}</code>: matrix of size <code>nstates</code> x <code>horizon</code> x <code>nshocks</code> of state impulse response functions</li><li><code>obs::Matrix{S}</code>: matrix of size <code>nobs</code> x <code>horizon</code> x <code>nshocks</code> of observable impulse response functions</li><li><code>pseudo::Matrix{S}</code>: matrix of size <code>npseudo</code> x <code>horizon</code> x <code>nshocks</code> of pseudo-observable impulse response functions</li><li><code>cholesky_shock::Vector{S}</code>: Cholesky-identified shock on impact (only if <code>get_shocks = true</code>)</li><li><code>structural_shock::Vector{S}</code>: structural shocks causing the   Cholesky-identified shock (only if <code>get_shocks = true</code>)</li></ul><p><strong>Restriction Types</strong></p><p>Consider a state space system</p><pre><code class="language-none">sₜ = TTT * sₜ₋₁ + RRR * sqrt(QQ) * ϵₜ
yₜ = ZZ * sₜ</code></pre><p>where <code>ϵₜ ∼ 𝒩 (0, I)</code> and <code>QQ</code> is a diagonal matrix specifying the variances of the structural shocks <code>ϵₜ</code>. Under this specification, the units of <code>ϵₜ</code> are standard deviations.</p><p>A Cholesky identification searches for a lower triangular matrix <code>M</code> such that <code>M * M&#39;</code> equals the covariance of observables. The restriction is short-run if we take the short-run covariance and is long run if we take the long-run covariance (i.e. the covariance of observables when shocks occur to the stationary level of sₜ). Explicitly, the short- and long-run restrictions are, respectively,</p><pre><code class="language-none">Covₛᵣ = (ZZ * RRR) * QQ * (ZZ * RRR)&#39;,
Covₗᵣ = (ZZ * (I - TTT)⁻¹ * RRR) * QQ * (ZZ * (I - TTT)⁻¹ * RRR)&#39;.</code></pre><p>Taking the Cholesky decomposition of the appropriate covariance matrix yields the lower triangular matrix <code>M</code>.</p><p>Using <code>M</code>, we may re-write the measurement equation of the state space as</p><pre><code class="language-none">yₜ = ZZ * TTT * sₜ₋₁ + M * uₜ,</code></pre><p>where <code>uₜ ∼ 𝒩 (0, I)</code> are orthogonal shocks identified from the covariance of <code>yₜ</code> using <code>M</code>. The orthogonal shocks <code>uₜ</code> are precisely the input argument <code>shocks</code>. We can map <code>uₜ</code> to <code>ϵₜ</code>, i.e. identify structural shocks, by solving the linear system</p><pre><code class="language-none">(ZZ * RRR * sqrt(QQ)) * ϵₜ = M * uₜ</code></pre><p>when using the short-run restriction and</p><pre><code class="language-none">(ZZ * (I - TTT)⁻¹ * RRR * sqrt(QQ)) * ϵₜ = M * uₜ</code></pre><p>when using the long-run restriction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/impulse_responses.jl#L292-L368">source</a></section><section><div><pre><code class="language-none">function impulse_responses(system::System{S}, horizon::Int, frequency_band::Tuple{S,S},
                           n_obs_shock::Int; flip_shocks::Bool = false,
                           get_shocks::Bool = false) where {S&lt;:Real}</code></pre><p>computes impulse responses by identifying the shock which maximizes the variance explained of a chosen observable within a certain frequency band.</p><p>For typical business-cycle frequences, we recommend setting <code>frequency_band = (2 * π / 32, 2 * π / 6)</code>.</p><p><strong>Inputs</strong></p><ul><li><code>system::System{S}</code>: state-space system matrices</li><li><code>horizon::Int</code>: number of periods ahead to forecast</li><li><code>frequency_band::Tuple{S, S}</code>: the frequencies at which we want to maximize the variance explained.   The first frequency must be less than the second one.</li><li><code>n_obs_shock::Int</code>: the index of the observable whose variance we want to maximally explain   in the state space model implied by <code>system</code>.</li><li><code>flip_shocks::Bool</code>: Whether to compute IRFs in response to a positive shock (by default the shock magnitude is a negative 1 std. shock)</li><li><code>get_shocks::Bool</code>: Whether to return the structural shocks.</li></ul><p>where <code>S &lt;: Real</code></p><p><strong>Outputs</strong></p><ul><li><code>states::Matrix{S}</code>: matrix of size <code>nstates</code> x <code>horizon</code> x <code>nshocks</code> of state impulse response functions</li><li><code>obs::Matrix{S}</code>: matrix of size <code>nobs</code> x <code>horizon</code> x <code>nshocks</code> of observable impulse response functions</li><li><code>pseudo::Matrix{S}</code>: matrix of size <code>npseudo</code> x <code>horizon</code> x <code>nshocks</code> of pseudo-observable impulse response functions</li><li><code>structural_shock::Vector{S}</code>: structural shocks causing the   Cholesky-identified shock (only if <code>get_shocks = true</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/impulse_responses.jl#L442-L476">source</a></section><section><div><pre><code class="language-none">function impulse_responses(m::AbstractDSGEModel, paras::Union{Vector{S}, Matrix{S}},
                           input_type::Symbol, method::Symbol,
                           lags::Int, observables::Vector{Symbol},
                           shocks::Vector{Symbol},
                           n_obs_shock::Int; parallel::Bool = false,
                           frequency_band::Tuple{S,S} = (2*π/32, 2*π/6),
                           flip_shocks::Bool = false,
                           use_intercept::Bool = false,
                           density_bands::Vector{Float64} = [.5, .6, .7, .8, .9],
                           create_meansbands::Bool = false,
                           minimize::Bool = true,
                           forecast_string::String = &quot;&quot;,
                           verbose::Symbol = :high) where {S&lt;:Real}</code></pre><p>computes the impulse responses of a VAR(p) approximation to a DSGE.</p><p><strong>Inputs</strong></p><ul><li><code>m::Union{AbstractDSGEModel,AbstractDSGEVARModel}</code>: DSGE/DSGEVAR model object</li><li><code>paras::Matrix{S}</code> or <code>paras::Vector{S}</code>: parameters to calibrate the model</li><li><code>input_type::Symbol</code>: <code>:mode</code> specifies a modal impulse response, and   <code>:full</code> specifies a full-distribution forecast if <code>paras</code> is not given.   This argument is also used to construct the file names of computed <code>MeansBands</code>.</li><li><code>method::Symbol</code>: type of impulse response to compute. The options are   <code>:cholesky</code>, <code>:maximum_business_cycle_variance</code> or <code>:maxBC</code>,   and <code>:cholesky_long_run</code> or <code>:choleskyLR</code>. See <code>?cholesky_shock</code>,   <code>?maxBC_shock</code>, and <code>?choleskyLR_shock</code>.</li><li><code>lags::Int</code>: number of lags in the VAR(p) approximation, i.e. p = lags</li><li><code>observables::Vector{Symbol}</code>: observables to be used in the VAR. These can be   any of the observables or pseudo-observables in <code>m</code>.</li><li><code>shocks::Vector{Symbol}</code>: (structural) exogenous shocks to be used in the DSGE-VAR.   These shocks must be in <code>m</code>.</li><li><code>n_obs_shock::Int</code>: the index of the observable corresponding to the orthogonalized shock causing the impulse response.</li></ul><p><strong>Keywords</strong></p><ul><li><code>parallel::Bool</code>: use parallel workers or not</li><li><code>frequency_band::Tuple{S,S}</code>: See <code>?maxBC_shock</code>.</li><li><code>flip_shocks::Bool</code>: impulse response shocks are negative by default. Set to <code>true</code> for   a positive signed shock.</li><li><code>density_bands::Vector{Float64}</code>: bands for full-distribution IRF computations</li><li><code>create_meansbands::Bool</code>: set to <code>true</code> to save output as a <code>MeansBands</code> object.</li><li><code>minimize::Bool</code>: choose shortest interval if true, otherwise just chop off lowest and   highest (percent/2)</li><li><code>forecast_string::String</code>: string tag for identifying this impulse response</li><li><code>verbose::Symbol</code>: quantity of output desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/wrappers_impulse_responses/var_approx_dsge_impulse_responses.jl#L1-L48">source</a></section><section><div><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVARModel{S}, paras::Matrix{S},
                           data::Matrix{S}, input_type::Symbol, method::Symbol;
                           parallel::Bool = false,
                           frequency_band::Tuple{S,S} = (2*π/32, 2*π/6),
                           n_obs_shock::Int = 1, draw_shocks::Bool = false,
                           flip_shocks::Bool = false,
                           X̂::AbstractMatrix{S} = Matrix{S}(undef, 0, 0),
                           deviations::Bool = false, normalize_rotation::Bool = false,
                           density_bands::Vector{Float64} = [.5, .6, .7, .8, .9],
                           create_meansbands::Bool = false, test_meansbands::Bool = false,
                           minimize::Bool = true,
                           forecast_string::String = &quot;&quot;,
                           verbose::Symbol = :high) where {S&lt;:Real}</code></pre><p>computes the VAR impulse responses identified by the state space system</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × impact[:, i],
yₜ = ZZ × sₜ + DD + MM × impact[:, i],</code></pre><p>where <code>impact[:, i]</code> is a linear combination of (orthogonal) structural shocks <code>ϵₜ ∼ 𝒩 (0, I)</code>, and <code>MM × impact[:, i]</code> are the correlated measurement errors.</p><p>The VAR impulse responses are computed according to</p><pre><code class="language-none">ŷₜ₊₁ = X̂ₜ₊₁β + uₜ₊₁,</code></pre><p>where <code>X̂ₜ₊₁</code> are the lags of observables in period <code>t + 1</code>, i.e. <code>yₜ, yₜ₋₁, ..., yₜ₋ₚ</code>.</p><p>If the method is <code>:rotation</code>, the shock <code>uₜ₊₁</code> is identified via</p><pre><code class="language-none">Σᵤ = 𝔼[u × u&#39;] = chol(Σᵤ) × Ω × ϵₜ,</code></pre><p>where the rotation matrix <code>Ω</code> is the <code>Q</code> matrix from a QR decomposition of the impact response matrix corresponding to the state space system, i.e.</p><pre><code class="language-none">Ω, _ = qr(∂yₜ / ∂ϵₜ&#39;).</code></pre><p>Otherwise, we draw a β and Σᵤ from the posterior implied by the DSGE and data, and we then compute normal VAR impulse responses given those coefficients and innovations variance-covariance matrix.</p><hr/><p>NOTE: this function generally involves taking random draws from probability distributions, so seeds need to be set to achieve reproducibility. ****</p><p><strong>Inputs</strong></p><ul><li><code>m::Union{AbstractDSGEModel,AbstractDSGEVARModel}</code>: DSGE/DSGEVAR model object</li><li><code>paras::Matrix{S}</code> or <code>paras::Vector{S}</code>: parameters to calibrate the model</li><li><code>input_type::Symbol</code>: <code>:mode</code> specifies a modal impulse response, and   <code>:full</code> specifies a full-distribution forecast if <code>paras</code> is not given.   This argument is also used to construct the file names of computed <code>MeansBands</code>.</li><li><code>method::Symbol</code>: type of impulse response to compute. The options are   <code>:cholesky</code> and <code>:rotation</code>. For the first, see <code>?cholesky_shock</code>,   and for the latter, we use the DSGE model to identify the rotation matrix   which maps the DSGE&#39;s structural shocks to the innovations in the VAR&#39;s observables.</li><li><code>lags::Int</code>: number of lags in the VAR(p) approximation, i.e. p = lags</li><li><code>observables::Vector{Symbol}</code>: observables to be used in the VAR. These can be   any of the observables or pseudo-observables in <code>m</code>.</li><li><code>shocks::Vector{Symbol}</code>: (structural) exogenous shocks to be used in the DSGE-VAR.   These shocks must be in <code>m</code>.</li><li><code>n_obs_shock::Int</code>: the index of the observable corresponding to the orthogonalized shock causing the impulse response.</li></ul><p><strong>Keywords</strong></p><ul><li><code>parallel::Bool</code>: use parallel workers or not</li><li><code>frequency_band::Tuple{S,S}</code>: See <code>?maxBC_shock</code>.</li><li><code>n_obs_shock::Int</code>: Index of observable to be shocked when using a Cholesky-based impulse response</li><li><code>draw_shocks::Bool</code>: true if you want to draw shocks along the entire horizon</li><li><code>flip_shocks::Bool</code>: impulse response shocks are negative by default. Set to <code>true</code> for   a positive signed shock.</li><li><code>X̂::AbstractMatrix{S}</code>: matrix stacking the intercept and lags of the data for   rotation IRFs. Set to a vector of zeros with length <code>1 + n_observables * p</code>   to compute the rotation IRFs in deviations from the baseline forecast.</li><li><code>deviations::Bool</code>: set true to compute the impulse response in deviations   rather than as a forecast. Mechnically, we ignore <code>X̂</code> (treated as zeros)   and the intercept term.</li><li><code>normalize_rotation::Bool</code>: set to true to normalize the rotation   so that rows have the correct sign. This requires as many structural shocks   as there are observables in the DSGE-VAR.</li><li><code>density_bands::Vector{Float64}</code>: bands for full-distribution IRF computations</li><li><code>create_meansbands::Bool</code>: set to <code>true</code> to save output as a <code>MeansBands</code> object.</li><li><code>minimize::Bool</code>: choose shortest interval if true, otherwise just chop off lowest and   highest (percent/2)</li><li><code>forecast_string::String</code>: string tag for identifying this impulse response</li><li><code>verbose::Symbol</code>: quantity of output desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/wrappers_impulse_responses/dsgevar_lambda_impulse_responses.jl#L1-L92">source</a></section><section><div><pre><code class="language-none">impulse_responses(β, Σ, n_obs_shock, horizon, shock_size = 1;
    method = :cholesky, flip_shocks = false, use_intercept = true,
    frequency_band = (2π/32, 2π/6)) where {S&lt;:Real}</code></pre><p>computes the impulse responses of a VAR system represented in the form</p><pre><code class="language-none">yₜ = Xₜβ + ϵₜ,</code></pre><p>where <code>Xₜ</code> stacks the lags of yₜ (with dimensions n<em>observables x n</em>regressors), and</p><pre><code class="language-none">ϵₜ ∼ 𝒩 (0, Σ).</code></pre><p><strong>Inputs</strong></p><ul><li><code>β::AbstractMatrix{S}</code>: coefficient matrix</li><li><code>Σ::AbstractMatrix{S}</code>: innovations variance-covariance matrix</li><li><code>n_obs_shock::Int</code>: index of the observable corresponding to the orthogonalized shock   causing the impulse response.</li><li><code>shock_size::S</code>: number of standard deviations of the shock</li></ul><p><strong>Keywords</strong></p><ul><li><code>method::Symbol</code>: type of impulse response to compute. The available options are   <code>:cholesky</code> (default), <code>:maximum_business_cycle_variance</code> or <code>:maxBC</code>, and   <code>:cholesky_long_run</code> or <code>:choleskyLR</code>. See <code>?cholesky_shock</code>, <code>?maxBC_shock</code>,   and <code>?cholesky_long_run_shock</code>.</li><li><code>flip_shocks::Bool</code>: by default, we compute the impulse responses to a negative shock.   Set <code>flip_shocks = true</code> to obtain a positive shock.</li><li><code>use_intercept::Bool</code>: <code>impulse_responses</code> assumes <code>β</code> has constant term(s). If there   are no such terms, then <code>use_intercept</code> must be set to <code>false</code>.</li><li><code>frequency_band::Tuple{S,S}</code>: See <code>?maxBC_shock</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Y::AbstractMatrix</code>: Impulse response matrix with dimensions horizons x n_observables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/impulse_responses.jl#L1-L38">source</a></section><section><div><pre><code class="language-none">impulse_responses(β, Σ, coint_mat, n_obs_shock, horizon, shock_size = 1;
    method = :cholesky, flip_shocks = false, use_intercept = true,
    frequency_band = (2π/32, 2π/6)) where {S&lt;:Real}</code></pre><p>computes the impulse responses of a VECM system represented in the form</p><pre><code class="language-none">Δyₜ = eₜ₋₁ βₑ + Xₜ βᵥ + ϵₜ,</code></pre><p>where <code>βₑ</code> are the coefficients for the error correction terms; <code>eₜ</code> are the error correction terms specifying the cointegrating relationships; <code>βᵥ</code> are the coefficients for the VAR terms (including the intercept); <code>Xₜ</code> are the lags of observables in period <code>t</code>, i.e. <code>yₜ₋₁, yₜ₋2, ..., yₜ₋ₚ</code>; and <code>ϵₜ ∼ 𝒩 (0, Σ)</code>. We assume that <code>β = [βₑ; βᵥ]</code>.</p><p><strong>Inputs</strong></p><ul><li><code>β::AbstractMatrix{S}</code>: coefficient matrix</li><li><code>Σ::AbstractMatrix{S}</code>: innovations variance-covariance matrix</li><li><code>coint_mat::AbstractMatrix{S}</code>: matrix specifying the cointegrating relationships.   Multiplying <code>coint_mat * data</code>, where <code>data</code> is an <code>n_observables × T</code> matrix, should yield   an <code>n_coint × T</code> matrix, where <code>n_coint</code> are the number of cointegrating   relationships and <code>T</code> are the number of periods of data.</li><li><code>n_obs_shock::Int</code>: index of the observable corresponding to the orthogonalized shock   causing the impulse response.</li><li><code>shock_size::S</code>: number of standard deviations of the shock</li></ul><p><strong>Keywords</strong></p><ul><li><code>method::Symbol</code>: type of impulse response to compute. The available option is   <code>:cholesky</code> (default).</li><li><code>flip_shocks::Bool</code>: by default, we compute the impulse responses to a negative shock.   Set <code>flip_shocks = true</code> to obtain a positive shock.</li><li><code>use_intercept::Bool</code>: <code>impulse_responses</code> assumes <code>β</code> has constant term(s). If there   are no such terms, then <code>use_intercept</code> must be set to <code>false</code>.</li><li><code>frequency_band::Tuple{S,S}</code>: See <code>?maxBC_shock</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Y::AbstractMatrix</code>: Impulse response matrix with dimensions horizons x n_observables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/impulse_responses.jl#L225-L264">source</a></section><section><div><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVARModel{S}, data::AbstractArray{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}

function impulse_responses(m::AbstractDSGEVARModel{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0, use_intercept::Bool = false,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}</code></pre><p>computes the VAR impulse responses identified by the DSGE</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × impact[:, i],
yₜ = ZZ × sₜ + DD + MM × impact[:, i],</code></pre><p>where <code>impact[:, i]</code> is a linear combination of (orthogonal) structural shocks <code>ϵₜ ∼ 𝒩 (0, I)</code>, and <code>MM × impact[:, i]</code> are the correlated measurement errors.</p><p>We draw a β and Σᵤ from the posterior implied by the DSGE and data, and we then compute normal VAR impulse responses given those coefficients and innovations variance-covariance matrix. The weight placed on the DSGE is encoded by the field <code>λ</code> of the DSGEVAR object <code>m</code>.</p><p>Given β, Σᵤ, we compute impulse responses to the VAR system</p><pre><code class="language-none">ŷₜ₊₁ = X̂ₜ₊₁β + uₜ₊₁,</code></pre><p>where <code>X̂ₜ₊₁</code> are the lags of observables in period <code>t + 1</code>, i.e. <code>yₜ, yₜ₋₁, ..., yₜ₋ₚ₊₁</code> using one of the available identification methods for VARs</p><p>If the second function is used (where <code>data</code> is not an input), then we assume the user wants to compute the VAR approximation of the DSGE, regardless of the <code>λ</code> value in <code>m</code>. Note that this function will not update the value of <code>λ</code> in <code>m</code> (even though we are computing the DSGE-VAR(∞) approximation).</p><p><strong>Inputs</strong></p><ul><li><code>method::Symbol</code>: The available methods are <code>:cholesky</code>, <code>:maxBC</code>, and <code>:choleskyLR</code>.   See the docstrings <code>impulse_responses</code> for VARs specifically.</li><li><code>n_obs_shock::Int</code>: The index of the observable corresponding to the orthogonalized shock   causing the impulse response.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>horizon::Int</code>: the desired horizon of the impulse responses.</li><li><code>use_intercept::Bool</code>: use an intercept term for the VAR approximation</li><li><code>flip_shocks::Bool</code>: default is a &quot;negative&quot; impulse response on impact.   Set to <code>true</code> for the positive impulse response.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/dsgevar/impulse_responses.jl#L1-L48">source</a></section><section><div><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVARModel{S}, data::AbstractArray{S},
                           X̂::Matrix{S} = Matrix{S}(undef, 0, 0);
                           horizon::Int = 0, MM::Matrix{S} = Matrix{S}(undef, 0, 0),
                           flip_shocks::Bool = false, draw_shocks::Bool = false,
                           deviations::Bool = false, normalize_rotation::Bool = false,
                           verbose::Symbol = :none) where {S &lt;: Real}</code></pre><p>computes the VAR impulse responses identified by the DSGE</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × impact[:, i],
yₜ = ZZ × sₜ + DD + MM × impact[:, i],</code></pre><p>where <code>impact[:, i]</code> is a linear combination of (orthogonal) structural shocks <code>ϵₜ ∼ 𝒩 (0, I)</code>, and <code>MM × impact[:, i]</code> are the correlated measurement errors.</p><p>The VAR impulse responses are computed according to</p><pre><code class="language-none">ŷₜ₊₁ = X̂ₜ₊₁β + uₜ₊₁,</code></pre><p>where <code>X̂ₜ₊₁</code> are the lags of observables in period <code>t + 1</code>, i.e. <code>yₜ, yₜ₋₁, ..., yₜ₋ₚ</code>. Note these impulse responses are <em>not</em> computed in deviations from the baseline forecast <code>ŷₜ₊₁ = X̂ₜ₊₁β</code>. To compute these impulse responses, use the keyword <code>deviations</code>.</p><p>The shock <code>uₜ₊₁</code> is identified by assuming</p><pre><code class="language-none">Σᵤ = 𝔼[u × u&#39;] = chol(Σᵤ) × Ω × ϵₜ,</code></pre><p>where the rotation matrix <code>Ω</code> is the <code>Q</code> matrix from a QR decomposition of the impact response matrix corresponding to the state space system, i.e.</p><pre><code class="language-none">Ω, _ = qr(∂yₜ / ∂ϵₜ&#39;).</code></pre><p>For reference, see Del Negro and Schorfheide (2004), Del Negro and Schorfheide (2006), and Del Negro and Schorfheide (2009).</p><p><strong>Inputs</strong></p><ul><li><code>X̂::Matrix{S}</code>: covariates for the first &quot;forecast&quot; period   of the impulse response, i.e. if we have a VAR with <code>p</code> lags, then</li></ul><pre><code class="language-none">X̂ = [1, ŷₜ, ŷₜ₋₁, ..., ŷₜ₋ₚ₊₁]</code></pre><p>so that, when β is the vector of VAR coefficients, then</p><pre><code class="language-none">𝔼[ŷₜ₊₁] = kron(I, X̂&#39;) * β.</code></pre><p>Internally, we do equivalent matrix operations to avoid allocating the Kronecker product.</p><hr/><p>NOTE: this function generally involves taking random draws from probability distributions, so seeds need to be set to achieve reproducibility. ****</p><p><strong>Keywords</strong></p><ul><li><code>horizon::Int</code>: horizon of impulse responses</li><li><code>flip_shocks::Bool</code>: impulse response shocks are negative by default. Set to <code>true</code> for   a positive signed shock.</li><li><code>draw_shocks::Bool</code>: true if you want to draw shocks along the entire horizon</li><li><code>deviations::Bool</code>: set true to compute the impulse response in deviations   rather than as a forecast. Mechnically, we ignore <code>X̂</code> (treated as zeros)   and the intercept term.</li><li><code>normalize_rotation::Bool</code>: set to true to normalize the rotation   so that rows have the correct sign. Requires same number of structural shocks   as observables.</li><li><code>verbose::Symbol</code>: quantity of output desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/dsgevar/impulse_responses.jl#L78-L149">source</a></section><section><div><pre><code class="language-none">function impulse_responses(TTT::Matrix{S}, RRR::Matrix{S}, ZZ::Matrix{S},
                           DD::Vector{S}, MM::Matrix{S}, impact::Matrix{S}, horizon::Int;
                           accumulate::Bool = false,
                           cum_inds::Union{Int,UnitRange{Int},Vector{Int}} = 0) where {S&lt;:Real}</code></pre><p>computes the impulse responses of the linear state space system to linear combinations of (orthogonal) structural shocks specified by <code>impact</code>. Measurement error that is correlated with the impact matrix is allowed. We also include the option to accumulate certain observables.</p><p>This state space model takes the form</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × impact[:, i],
yₜ = ZZ × sₜ + DD + MM × impact[:, i],</code></pre><p>where <code>impact[:, i]</code> is a linear combination of orthogonal structural shocks with mean zero and identity covariance, and <code>MM × impact[:, i]</code> are the correlated measurement errors.</p><p>The <code>impact</code> matrix must be <code>nshock × nirf</code>, where <code>nshock</code> is  the number of structural shocks and <code>nirf</code> is the number of desired impulse responses. For each row of <code>impact</code>, we compute the corresponding impulse responses.</p><p>A standard choice for <code>impact</code> is a square diagonal matrix. In this case, we compute the impulse response of observables to each structural shock, scaled by the desired size of the shock.</p><p><strong>Keywords</strong></p><ul><li><code>accumulate</code>: set to true if an observable should be accumulated.</li><li><code>cum_inds</code>: specifies the indices of variables to accumulated.</li></ul><p><strong>Outputs</strong></p><ul><li><code>irf_results::Matrix{S}</code>: a <code>nobs x horizon × nirf</code> matrix, where    <code>nobs</code> is the number of observables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/dsgevar/impulse_responses.jl#L191-L229">source</a></section><section><div><pre><code class="language-none">function impulse_responses(TTT::Matrix{S}, RRR::Matrix{S}, ZZ::Matrix{S},
                           DD::Vector{S}, MM::Matrix{S}, QQ::Matrix{S},
                           k::Int, β::Matrix{S}, Σ::Matrix{S},
                           horizon::Int, X̂::Matrix{S} = zeros(S, k);
                           flip_shocks::Bool = false, draw_shocks::Bool = false,
                           deviations::Bool = false, normalize_rotation::Bool = false,
                           test_shocks::Matrix{S} =
                           Matrix{S}(undef, 0, 0)) where {S&lt;:Real}</code></pre><p>computes the VAR impulse responses identified by the state space system</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × ϵₜ
yₜ = ZZ × sₜ + DD + MM × ϵₜ</code></pre><p>where <code>ϵₜ ∼ 𝒩 (0, QQ)</code> and <code>MM × ϵₜ</code> are the correlated measurement errors.</p><p>The VAR impulse responses are computed according to</p><pre><code class="language-none">ŷₜ₊₁ = X̂ₜ₊₁β + uₜ₊₁,</code></pre><p>where <code>X̂ₜ₊₁</code> are the lags of observables in period <code>t + 1</code>, i.e. <code>yₜ, yₜ₋₁, ..., yₜ₋ₚ</code>. Note these impulse responses are <em>not</em> computed in deviations from the baseline forecast <code>ŷₜ₊₁ = X̂ₜ₊₁β</code>. To compute these impulse responses, set the keyword <code>deviations = true</code>.</p><p>The shock <code>uₜ₊₁</code> is identified via</p><pre><code class="language-none">Σᵤ = 𝔼[u × u&#39;] = chol(Σᵤ) × Ω × ϵₜ,</code></pre><p>where the rotation matrix <code>Ω</code> is the <code>Q</code> matrix from a QR decomposition of the impact response matrix corresponding to the state space system, i.e.</p><pre><code class="language-none">Ω, _ = qr(∂yₜ / ∂ϵₜ&#39;).</code></pre><p>To normalize the rotation so that rows have the correct sign, set <code>normalize_rotation = true</code>. This requires that there are as many structural shocks as observables.</p><p>For reference, see Del Negro and Schorfheide (2004), Del Negro and Schorfheide (2006), and Del Negro and Schorfheide (2009).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/dsgevar/impulse_responses.jl#L261-L303">source</a></section><section><div><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVECMModel{S}, data::AbstractArray{S},
                           coint_mat::AbstractMatrix{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}

function impulse_responses(m::AbstractDSGEVECMModel{S}, coint_mat::AbstractMatrix{S}, method::Symbol,
                           n_obs_shock::Int; horizon::Int = 0, use_intercept::Bool = false,
                           flip_shocks::Bool = false, verbose::Symbol = :none) where {S &lt;: Real}</code></pre><p>computes the VECM impulse responses identified by the DSGE</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × impact[:, i],
yₜ = ZZ × sₜ + DD + MM × impact[:, i],</code></pre><p>where <code>impact[:, i]</code> is a linear combination of (orthogonal) structural shocks <code>ϵₜ ∼ 𝒩 (0, I)</code>, and <code>MM × impact[:, i]</code> are the correlated measurement errors.</p><p>We draw a β and Σᵤ from the posterior implied by the DSGE and data, and we then compute normal VECM impulse responses given those coefficients, innovations variance-covariance matrix, and the matrix specifying cointegrating relationships in observables. The weight placed on the DSGE is encoded by the field <code>λ</code> of the DSGEVECM object <code>m</code>.</p><p>Given β, Σᵤ, we compute impulse responses using one of the available identifiction strategies to the VECM system</p><pre><code class="language-none">Δŷₜ₊₁ = eₜβₑ + X̂ₜ₊₁βᵥ + uₜ₊₁,</code></pre><p>where <code>βₑ</code> are the coefficients for the error correction terms; <code>eₜ₊₁</code> are the error correction terms specifying the cointegrating relationships; <code>βᵥ</code> are the coefficients for the VAR terms; <code>X̂ₜ₊₁</code> are the lags of observables in period <code>t + 1</code>, i.e. <code>yₜ, yₜ₋₁, ..., yₜ₋ₚ</code>, and <code>uₜ₊₁ ∼ 𝒩 (0, Σ)</code>.</p><p>If the second function is used (where <code>data</code> is not an input), then we assume the user wants to compute the VECM approximation of the DSGE, regardless of the <code>λ</code> value in <code>m</code>. Note that this function will not update the value of <code>λ</code> in <code>m</code> (even though we are computing the DSGE-VECM(∞) approximation).</p><p><strong>Inputs</strong></p><ul><li><code>coint_mat::AbstractMatrix{S}</code>: matrix specifying the cointegrating relationships   in observables. Given a matrix <code>data</code> with dimensions <code>n_observables × T</code>,   multiplying <code>coint_mat * data</code> should yield a <code>n_coint × T</code> matrix, where   <code>n_coint</code> is the number of cointegrating relationships and <code>T</code> is   the number of periods of data.</li><li><code>method::Symbol</code>: The available methods are <code>:cholesky</code>, <code>:maxBC</code>, and <code>:choleskyLR</code>.   See the docstrings <code>impulse_responses</code> for VECMs specifically.</li><li><code>n_obs_shock::Int</code>: The index of the observable corresponding to the orthogonalized shock   causing the impulse response.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>horizon::Int</code>: the desired horizon of the impulse responses.</li><li><code>use_intercept::Bool</code>: use an intercept term for the VECM approximation</li><li><code>flip_shocks::Bool</code>: default is a &quot;negative&quot; impulse response on impact.   Set to <code>true</code> for the positive impulse response.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/dsgevecm/impulse_responses.jl#L1-L59">source</a></section><section><div><pre><code class="language-none">function impulse_responses(m::AbstractDSGEVECMModel{S}, data::AbstractArray{S},
    X̂::Matrix{S} = Matrix{S}(undef, 0, 0);
    horizon::Int = 0, MM::Matrix{S} = Matrix{S}(undef, 0, 0),
    flip_shocks::Bool = false, draw_shocks::Bool = false,
    verbose::Symbol = :none) where {S &lt;: Real}</code></pre><p>computes the VECM impulse responses identified by the DSGE</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × impact[:, i],
yₜ = ZZ × sₜ + DD + MM × impact[:, i],</code></pre><p>where <code>impact[:, i]</code> is a linear combination of (orthogonal) structural shocks <code>ϵₜ ∼ 𝒩 (0, I)</code>, and <code>MM × impact[:, i]</code> are the correlated measurement errors.</p><p>The VECM impulse responses are computed according to</p><pre><code class="language-none">Δŷₜ₊₁ = eₜβₑ + X̂ₜ₊₁βᵥ + uₜ₊₁,</code></pre><p>where <code>βₑ</code> are the coefficients for the error correction terms; <code>eₜ</code> are the error correction terms specifying the cointegrating relationships; <code>βᵥ</code> are the coefficients for the VAR terms; <code>X̂ₜ₊₁</code> are the lags of observables in period <code>t + 1</code>, i.e. <code>yₜ, yₜ₋₁, ..., yₜ₋ₚ</code>, and <code>uₜ₊₁ ∼ 𝒩 (0, Σ)</code>. Note these impulses responses are <em>not</em> computed in deviations from the baseline forecast <code>Δŷₜ₊₁ = eₜ₊₁βₑ + X̂ₜ₊₁βᵥ</code>. To compute these impulse responses, use the keyword <code>deviations</code>.</p><p>The shock <code>uₜ₊₁</code> is identified by assuming</p><pre><code class="language-none">Σᵤ = 𝔼[u × u&#39;] = chol(Σᵤ) × Ω × ϵₜ,</code></pre><p>where the rotation matrix <code>Ω</code> is the <code>Q</code> matrix from a QR decomposition of the impact response matrix corresponding to the state space system, i.e.</p><pre><code class="language-none">Ω, _ = qr(∂yₜ / ∂ϵₜ&#39;).</code></pre><p>The impact response matrix is constructed using only the stationary component of the state space system and ignores the cointegration components of <code>ZZ</code> and <code>DD</code>.</p><p>For reference, see Del Negro and Schorfheide (2004), Del Negro and Schorfheide (2006), and Del Negro and Schorfheide (2009).</p><p><strong>Inputs</strong></p><ul><li><code>coint_mat::Matrix{S}</code>: matrix specifying the cointegrating relationships   in the actual <code>data</code> matrix. Evaluating <code>coint_mat * data</code> should yield   a time series of the cointegrating relationships.</li><li><code>X̂::Matrix{S}</code>: covariates for the first &quot;forecast&quot; period   of the impulse response, i.e. if we have a VECM with <code>p</code> lags, then</li></ul><pre><code class="language-none">X̂ = [eₜ, 1, ŷₜ, ŷₜ₋₁, ..., ŷₜ₋ₚ₊₁]</code></pre><p>so that, when β is the vector of VECM coefficients, then</p><pre><code class="language-none">𝔼[ŷₜ₊₁] = kron(I, X̂&#39;) * β.</code></pre><p>Internally, we do equivalent matrix operations to avoid allocating the Kronecker product.</p><hr/><p>NOTE: this function generally involves taking random draws from probability distributions, so seeds need to be set to achieve reproducibility. ****</p><p><strong>Keywords</strong></p><ul><li><code>horizon::Int</code>: horizon of impulse responses</li><li><code>flip_shocks::Bool</code>: impulse response shocks are negative by default. Set to <code>true</code> for   a positive signed shock.</li><li><code>draw_shocks::Bool</code>: true if you want to draw shocks along the entire horizon</li><li><code>deviations::Bool</code>: set true to compute the impulse response in deviations   rather than as a forecast. Mechnically, we ignore <code>X̂</code> (treated as zeros)   and the intercept term.</li><li><code>verbose::Symbol</code>: quantity of output desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/dsgevecm/impulse_responses.jl#L87-L162">source</a></section><section><div><pre><code class="language-none">function impulse_responses(TTT::Matrix{S}, RRR::Matrix{S}, ZZ::Matrix{S},
                           DD::Vector{S}, MM::Matrix{S}, QQ::Matrix{S},
                           k::Int, n_obs::Int, n_coint::Int, β::Matrix{S}, Σ::Matrix{S},
                           coint_mat::Matrix{S}, horizon::Int, X̂::Matrix{S} = zeros(S, k);
                           flip_shocks::Bool = false, draw_shocks::Bool = false,
                           deviations::Bool = false,
                           test_shocks::Matrix{S} =
                           Matrix{S}(undef, 0, 0)) where {S&lt;:Real}</code></pre><p>computes the VECM impulse responses identified by the state space system</p><pre><code class="language-none">sₜ = TTT × sₜ₋₁ + RRR × ϵₜ
yₜ = ZZ × sₜ + DD + MM × ϵₜ</code></pre><p>where <code>ϵₜ ∼ 𝒩 (0, QQ)</code> and <code>MM × ϵₜ</code> are the correlated measurement errors.</p><p>Consider the VECM</p><pre><code class="language-none">Δŷₜ₊₁ = eₜβₑ + X̂ₜ₊₁βᵥ + uₜ₊₁,</code></pre><p>where <code>βₑ</code> are the coefficients for the error correction terms; <code>eₜ</code> are the error correction terms specifying the cointegrating relationships; <code>βᵥ</code> are the coefficients for the VAR terms (including the intecept)o; <code>X̂ₜ₊₁</code> are the lags of observables in period <code>t + 1</code>, i.e. <code>yₜ, yₜ₋₁, ..., yₜ₋ₚ₊₁</code>; and <code>uₜ₊₁ ∼ 𝒩 (0, Σ)</code>. Note these impulses responses are <em>not</em> computed in deviations from the baseline forecast <code>Δŷₜ₊₁ = eₜ₊₁βₑ + X̂ₜ₊₁βᵥ</code>. To compute these impulse responses, set the keyword <code>deviations = true</code>.</p><p>The shock <code>uₜ₊₁</code> is identified via</p><pre><code class="language-none">Σᵤ = 𝔼[u × u&#39;] = chol(Σᵤ) × Ω × ϵₜ,</code></pre><p>where the rotation matrix <code>Ω</code> is the <code>Q</code> matrix from a QR decomposition of the impact response matrix corresponding to the state space system, i.e.</p><pre><code class="language-none">Ω, _ = qr(∂yₜ / ∂ϵₜ&#39;).</code></pre><p>The impact response matrix is constructed using only the stationary component of the state space system and ignores the cointegration components of <code>ZZ</code> and <code>DD</code>.</p><p>The data are assumed to have dimensions <code>n_obs × T</code>, and the cointegration relationships in the data are given by <code>coint_mat * data</code>, where <code>coint_mat</code> has dimensions <code>n_coint × n_obs</code>. The variable <code>k</code> is the number of total regressors in the VECM, including cointegration terms.</p><p>For reference, see Del Negro and Schorfheide (2004), Del Negro and Schorfheide (2006), and Del Negro, Schorfheide, Smets, and Wouters (2007).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/528cc2b45f51c11a8fcca4b964d29e1c91e50175/src/forecast/var/dsgevecm/impulse_responses.jl#L202-L251">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../forecast/">« Forecasting</a><a class="docs-footer-nextpage" href="../means_bands/">Computing Means and Bands »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 26 January 2021 22:54">Tuesday 26 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
