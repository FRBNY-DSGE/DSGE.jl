<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Input Data · DSGE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DSGE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DSGE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../learning_how_to_use_dsgejl/">Learning How to Use DSGE.jl</a></li><li><a class="tocitem" href="../model_design/">Model Design</a></li><li><a class="tocitem" href="../special_model_types/">Special Model Types</a></li><li><a class="tocitem" href="../model_implementation_details/">Model Implementation Details</a></li><li><a class="tocitem" href="../running_existing_model/">Running An Existing Model</a></li><li class="is-active"><a class="tocitem" href>Input Data</a><ul class="internal"><li><a class="tocitem" href="#Setup-1"><span>Setup</span></a></li><li><a class="tocitem" href="#Loading-data-1"><span>Loading data</span></a></li><li><a class="tocitem" href="#Non-FRED-data-sources-1"><span>Non-FRED data sources</span></a></li><li><a class="tocitem" href="#Incorporate-population-forecasts-1"><span>Incorporate population forecasts</span></a></li><li><a class="tocitem" href="#Dataset-creation-implementation-details-1"><span>Dataset creation implementation details</span></a></li><li><a class="tocitem" href="#Conditional-data-1"><span>Conditional data</span></a></li><li><a class="tocitem" href="#Common-pitfalls-1"><span>Common pitfalls</span></a></li><li><a class="tocitem" href="#Update-sample-input-data-1"><span>Update sample input data</span></a></li><li><a class="tocitem" href="#Data-Transforms-and-Utilities-1"><span>Data Transforms and Utilities</span></a></li></ul></li><li><a class="tocitem" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="tocitem" href="../solving/">Solving the Model</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../forecast/">Forecasting</a></li><li><a class="tocitem" href="../irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../means_bands/">Computing Means and Bands</a></li><li><a class="tocitem" href="../altpolicy/">Alternative Policies</a></li><li><a class="tocitem" href="../scenarios/">Alternative Scenarios</a></li><li><a class="tocitem" href="../forecast_decomposition/">Forecast Decomposition</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="tocitem" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="tocitem" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Input Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Input Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/docs/src/input_data.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="input-data-step-1"><a class="docs-heading-anchor" href="#input-data-step-1">Input Data</a><a class="docs-heading-anchor-permalink" href="#input-data-step-1" title="Permalink"></a></h1><p>Given all of the hard work put into specifying the model, one should be able to maintain the input data painlessly. To that extent, DSGE.jl provides facilities to download appropriate vintages of data series from FRED (Federal Reserve Economic Data).</p><p>Note that a sample input dataset for use with model <code>m990</code> is provided; see <a href="../frbny_data/#frbny-data-1">New York Fed Model 990 Data</a> for more details. To update this sample dataset for use with model <code>m990</code>, see <a href="#Update-sample-input-data-1">Update sample input data</a>.</p><h2 id="Setup-1"><a class="docs-heading-anchor" href="#Setup-1">Setup</a><a class="docs-heading-anchor-permalink" href="#Setup-1" title="Permalink"></a></h2><p>To take advantage of the ability to automatically download data series from FRED via the FredData.jl package, set up your FRED API access by following the directions <a href="https://github.com/micahjsmith/FredData.jl/blob/master/README.md">here</a>.</p><h2 id="Loading-data-1"><a class="docs-heading-anchor" href="#Loading-data-1">Loading data</a><a class="docs-heading-anchor-permalink" href="#Loading-data-1" title="Permalink"></a></h2><p>At the most basic, loading data looks like this:</p><pre><code class="language-julia">m = Model990()
df = load_data(m)</code></pre><p>By default, <code>load_data</code> will look on the disk first to see if an appropriate vintage of data is already present. If data on disk are not present, or if the data are invalid for any reason, a fresh vintage will be downloaded from FRED and merged with the other data sources specified. See <a href="#DSGE.load_data-Tuple{AbstractDSGEModel}"><code>load_data</code></a> for more details.</p><p>The resulting DataFrame <code>df</code> contains all the required data series for this model, fully transformed. The first row is given by the Setting <code>date_presample_start</code> and the last row is given by <code>date_mainsample_end</code>. The first <code>n_presample_periods</code> rows of <code>df</code> are the presample.</p><p>Driver functions including <code>estimate</code> accept this <code>df</code> as an argument and convert it into a <code>Matrix</code> suitable for computations using <code>df_to_matrix</code>, which sorts the data, ensures the full sample is present, discards the date column, and sorts the observable columns according to the <code>observables</code> field of the model object.</p><h2 id="Non-FRED-data-sources-1"><a class="docs-heading-anchor" href="#Non-FRED-data-sources-1">Non-FRED data sources</a><a class="docs-heading-anchor-permalink" href="#Non-FRED-data-sources-1" title="Permalink"></a></h2><p>Some data series may not be available from FRED or one may simply wish to use a different data source, for whatever reason. The data sources and series are specified in the <code>input_series</code> field of an <code>Observable</code> object (see <a href="https://github.com/FRBNY-DSGE/ModelConstructors.jl">ModelConstructors.jl</a>). For each data source that is <em>not</em> <code>:fred</code>, a well-formed CSV of the form <code>&lt;source&gt;_&lt;yymmdd&gt;.csv</code> is expected in the directory indicated by <code>inpath(m, &quot;raw&quot;)</code>.  For example, the following might be the contents of a data source for two series <code>:series1</code> and <code>:series2</code>:</p><pre><code class="language-none">date,series1,series2
1959-06-30,1.0,NaN
1959-09-30,1.1,0.5
# etc.</code></pre><p>Note that quarters are represented by the date of the <em>last</em> day of the quarter and missing values are specified by <code>NaN</code>.</p><h3 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h3><p>Let&#39;s consider an example dataset comprised of 10 macro series sourced from FRED and one survey-based series sourced from, say, the Philadelphia Fed&#39;s <a href="http://www.philadelphiafed.org/research-and-data/real-time-center/survey-of-professional-forecasters/historical-data/inflation-forecasts">Survey of Professional Forecasters</a> via Haver Analytics. The <code>Observable</code> for that data series might look like this:</p><pre><code class="language-none">Observable(:obs_longcpi, [:ASAXC10__SPF], annualtoquarter, quartertoannual,
           &quot;Median 10Y CPI Expectations&quot;, &quot;Median 10Y CPI Expectations&quot;)</code></pre><p>If the data vintage specified for the model is <code>151127</code> (Nov. 27, 2015), then the following files are expected in <code>inpath(m, &quot;raw&quot;)</code>:</p><pre><code class="language-none">spf_151127.csv
fred_151127.csv</code></pre><p>The FRED series will be downloaded and the <code>fred_151127.csv</code> file will be automatically generated, but the <code>spf_151127.csv</code> file must be manually compiled as shown above:</p><pre><code class="language-none">date,ASACX10
1991-12-31,4.0
# etc.</code></pre><p>Now, suppose that we set the data vintage to <code>151222</code>, to incorporate the BEA&#39;s third estimate of GDP. The <code>fred_151222.csv</code> file will be downloaded, but there are no updates to the SPF dataset during this period. Regardless, the file <code>spf_151222.csv</code> must be present to match the data vintage. The solution in this case is to manually copy and rename the older SPF dataset. Although this is not an elegant approach, it is consistent with the concept of a vintage as the data available at a certain point in time –- in this example, it just so happens that the SPF data available on Nov. 27 and Dec. 22 are the same.</p><h2 id="Incorporate-population-forecasts-1"><a class="docs-heading-anchor" href="#Incorporate-population-forecasts-1">Incorporate population forecasts</a><a class="docs-heading-anchor-permalink" href="#Incorporate-population-forecasts-1" title="Permalink"></a></h2><p>Many variables enter the model in per-capita terms. To that extent, we use data on population levels to adjust aggregate variables into per-capita variables. Furthermore, we apply the <a href="https://en.wikipedia.org/wiki/Hodrick%E2%80%93Prescott_filter">Hodrick-Prescott filter</a> (&quot;H-P filter&quot;) to the population levels to smooth cyclical components.</p><p>The user will ultimately want to produce forecasts of key variables such as GDP and then represent these forecasts in standard terms. That is, one wants to report GDP forecasts in aggregate terms, which is standard, rather than per-capita terms. To do this, we either extrapolate from the last periods of population growth in the data, or use external population forecasts.</p><p>Note that if external population forecasts are provided, non-forecast procedures, such as model estimation, are also affected because the H-P filter smoothes back from the latest observation.</p><p>To incorporate population forecasts,</p><ol><li>Set the model setting <code>use_population_forecast</code> to <code>true</code>.</li><li>Provide a file <code>population_forecast_&lt;yymmdd&gt;.csv</code> to <code>inpath(m, &quot;raw&quot;)</code>. Population forecasts should be in levels, and represent the same series as given by the <code>population_mnemonic</code> setting (defaults to <code>:CNP16OV</code>, or &quot;Civilian Noninstitutional Population, Thousands&quot;). If your population forecast is in growth rates, convert it to levels yourself. The first row of data should correspond to the last period of the main sample, such that growth rates can be computed. As many additional rows of forecasts as desired can be provided.</li></ol><p>The file should look like this:</p><pre><code class="language-none">date,POPULATION
2015-12-31,250000
2016-03-31,251000
# etc.</code></pre><h2 id="Dataset-creation-implementation-details-1"><a class="docs-heading-anchor" href="#Dataset-creation-implementation-details-1">Dataset creation implementation details</a><a class="docs-heading-anchor-permalink" href="#Dataset-creation-implementation-details-1" title="Permalink"></a></h2><p>Let&#39;s quickly walk through the steps DSGE.jl takes to create a suitable dataset.</p><p>First, a user provides a detailed specification of the data series and transformations used for their model.</p><ul><li><p>the user specifies <code>m.observables</code>; the keys of this dictionary name   the series to be used in estimating the model.</p></li><li><p>the user specifies <code>m.observable_mappings</code>; the keys of this dictionary name observed variables, and the values correspond to the observable object, which contains information about the forward and reverse transforms as well as the input data series from which the observable is constructed.</p></li><li><p>For a given observable, an input series, e.g.   <code>m.observable_mappings[:obs_gdp].input_series</code>, is an array of mnemonics to be   accessed from the data source listed after the mnemonic (separated by the double   underscore). Note that these mnemonics do not correspond to observables one-to-one,   but rather are usually series in <em>levels</em> that will be further transformed.</p></li><li><p>There are also both forward and reverse transforms for a given observable,   e.g. <code>m.observable_mappings[:obs_gdp].fwd_transform</code> and   <code>m.observable_mappings[:obs_gdp].rev_transform</code>. The forward transform operates on a   single argument, <code>levels</code>, which is a DataFrame of the data in levels returned by the   function <code>load_data_levels</code>. The reverse transform operates on a forward transformed   series (which is in model units) transforming it into human-readable units, such   as one quarter percent changes or per-capita adjustments. Both transforms return a   DataArray for a single series. These functions could do nothing, or they could   perform a more complex transformation. See   <a href="#Data-Transforms-and-Utilities-1">Data Transforms and Utilities</a> for more information about series-specific   transformations.</p></li><li><p>the user adjusts data-related settings, such as <code>data_vintage</code>, <code>data_id</code>,   <code>dataroot</code>, <code>date_presample_start</code>, <code>date_zlb_start</code>, <code>date_forecast_start</code>,   and <code>use_population_forecast</code>. See <a href="../advanced_usage/#working-with-settings-1">Working with Settings</a> for details.</p></li></ul><p>Second, DSGE.jl attempts to construct the dataset given this setup through a call to <code>load_data</code>. See <a href="#DSGE.load_data-Tuple{AbstractDSGEModel}"><code>load_data</code></a> for more details.</p><ul><li>Intermediate data in levels are loaded. See <a href="#DSGE.load_data_levels-Tuple{AbstractDSGEModel}"><code>load_data_levels</code></a> for more details.</li><li>Transformations are applied to the data in levels. See <a href="#DSGE.transform_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}"><code>transform_data</code></a> for more details.</li><li>The data are saved to disk. See <a href="#DSGE.save_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}"><code>save_data</code></a> for more details.</li></ul><h2 id="Conditional-data-1"><a class="docs-heading-anchor" href="#Conditional-data-1">Conditional data</a><a class="docs-heading-anchor-permalink" href="#Conditional-data-1" title="Permalink"></a></h2><p>The user can easily add conditional data for any observables. By &quot;conditional data&quot;, we mean that, in reality, some data has not become available yet, but we believe that a certain number is a decent guess, so we want to forecast conditional on our guessed data. For example, suppose we are in 2019:Q4, in which case we have not observed 2019:Q4 GDP growth yet. However, we might have some idea of the number, so we want our forecasts to be conditional on that guess.</p><p>To load such data, the user needs to include a &quot;cond&quot; folder within the input data folder, i.e. this folder <code>joinpath(get_setting(m, :input_data), &quot;cond&quot;)</code> should exist. Within this folder, the user can create a csv file taking the form <code>cond_cdid=&lt;xx&gt;_cdvt=&lt;yymmdd&gt;.csv</code>. The user should then make sure that the model object being used has the following settings</p><ul><li><p><code>cond_id::Int64</code>: the conditional data&#39;s equivalent of <code>data_id</code> and will be inserted after the <code>cdid</code>. Note that the ID must be less than 100.</p></li><li><p><code>cond_vintage::String</code>: the conditional data&#39;s equivalent of <code>data_vintage</code> and will be inserted after the <code>cdvt</code>.</p></li></ul><p>The contents of <code>cond_cdid=&lt;xx&gt;_cdvt=&lt;yymmdd&gt;.csv</code> should have columns for each raw data series that is then used to construct a given conditional observable. The first column should be <code>date</code> for the quarters of the conditional horizon, and the following columns should be for the raw data series. For example, to obtain real GDP growth, we need to have a population forecast file with both CNP16OV and CE16OV, the forecasted value of nominal GDP (under pnemonic GDP), and the forecasted value of the GDP deflator (under pnemonic GDPDEF) since these series are all required to compute <code>obs_gdp</code>, which is per-capita real GDP growth. For core inflation, we just need the index level for core PCE (under pnemonic PCEPILFE).</p><p><em>Note that the csv should have only conditional horizon data</em>. If you have data for any historical quarters, then the <code>DataFrame</code> with both historical and conditional data will not be created in REPL correctly. For example, if I am forecasting 2019:Q4 with a conditional forecast of 2019:Q4 values, then the data conditional csv should have only values for 2019:Q4 (and onward). No values for 2019:Q3 or before should be in the conditional data csv.</p><p>Finally, to specify which variables should have conditional observations, make sure to set</p><ul><li><p><code>cond_full_names::Vector{Symbol}</code>: variables when running a &quot;full&quot; conditional forecast. For Model 1002, this means averages of the current quarter&#39;s daily financial data as well as nowcasts of real GDP growth and core PCE inflation.</p></li><li><p><code>cond_semi_names::Vector{Symbol}</code>: variables when running a &quot;semi&quot; conditional forecast. For Model 1002, this means averages of the current quarter&#39;s daily financial data.</p></li></ul><p>See the <a href="https://github.com/FRBNY-DSGE/DSGE.jl/src/defaults.jl">default</a> settings for an example of how these <code>cond_full_names</code> and <code>cond_semi_names</code> are initialized.</p><h2 id="Common-pitfalls-1"><a class="docs-heading-anchor" href="#Common-pitfalls-1">Common pitfalls</a><a class="docs-heading-anchor-permalink" href="#Common-pitfalls-1" title="Permalink"></a></h2><p>Given the complexity of the data download, you may find that the dataset generated by <code>load_data</code> is not exactly as you expect. It is a good idea to compare the <code>observables.jl</code> file for your model with the <a href="https://github.com/FRBNY-DSGE/DSGE.jl/src/models/representative/m1002/observables.jl">one used by <code>Model1002</code></a>, which uses all the features provided by the package for handling data. Be certain that any significant differences are intentional. Here are also some common pitfalls to look out for:</p><ul><li>Ensure that the <code>data_vintage</code> and <code>cond_vintage</code> model settings are as you expect. (Try checking   <code>data_vintage(m)</code> and <code>cond_vintage(m)</code>.)</li><li>Ensure that the <code>data_id</code> and <code>cond_id</code> model settings are correct for the given model.</li><li>Ensure that the <code>date_forecast_start</code> model setting is as you expect, and that is not   logically incompatible with <code>data_vintage</code>.</li><li>Ensure that the <code>date_conditional_end</code> model setting is as you expect, and that is not   logically incompatible with <code>cond_vintage</code>.</li><li>Double check the transformations specified in the <code>data_transforms</code> field of the model   object.</li><li>Ensure that the keys of the <code>observables</code> and <code>data_transforms</code> fields of the model object   match.</li><li>Check the input files for <a href="#Non-FRED-data-sources-1">Non-FRED data sources</a>. They should be   in the directory indicated by <code>inpath(m, &quot;raw&quot;)</code>, be named appropriately given the   vintage of data expected, and be formatted appropriately. One may have to copy and   rename files of non-FRED data sources to match the specified vintage, even if the   contents of the files would be identical.</li><li>Look for any immediate issues in the final dataset saved   (<code>data_dsid=&lt;xx&gt;_vint=&lt;yymmdd&gt;.csv</code>). If a data series in this file is all   <code>NaN</code> values, then likely a non-FRED data source was not provided correctly.</li><li>Ensure that the column names of the data CSV match the keys of the <code>observables</code> field of   the model object.</li><li>You may receive a warning that an input data file &quot;does not contain the entire date range   specified&quot;. This means that observations are not provided for some periods in which the   model requires data. This is perfectly okay if your data series starts after   <code>date_presample_start</code>.</li><li>If you successfully created a data set but it is missing observations that you want to add, you may need to recreate the data set. By default, <code>load_data</code> checks if a data set with the correct vintage already exists. If it does, then <code>load_data</code> loads the saved data rather than recreate a data set from scratch. However, if the saved data set is missing observations, then you want to recreate it by calling <code>load_data(m; try_disk = false)</code>.</li><li>If you have a column that is completely empty (all missing/NaN data), but you still want to load the data, then use the keyword <code>check_empty_columns = false</code>.</li></ul><p>If you experience any problems using FredData.jl, ensure your API key is provided correctly and that there are no issues with your firewall, etc. Any issues with FredData.jl proper should be reported on that project&#39;s page.</p><h2 id="Update-sample-input-data-1"><a class="docs-heading-anchor" href="#Update-sample-input-data-1">Update sample input data</a><a class="docs-heading-anchor-permalink" href="#Update-sample-input-data-1" title="Permalink"></a></h2><p>A sample dataset is provided for the 2015 Nov 27 vintage. To update this dataset:</p><p><strong>Step 1</strong>. See <a href="#Setup-1">Setup</a> to setup automatic data pulls using FredData.jl.</p><p><strong>Step 2</strong>. Specify the exact data vintage desired:</p><pre><code class="language-julia">julia&gt;  m &lt;= Setting(:data_vintage, &quot;yymmdd&quot;)</code></pre><p><strong>Step 3</strong>. Create data files for the non-FRED data sources. For model <code>m990</code>, the required data files include    <code>spf_&lt;yymmdd&gt;.csv</code> (with column <code>ASACX10</code>), <code>longrate_&lt;yymmdd&gt;.csv</code> (with    column <code>FYCCZA</code>), and <code>fernald_&lt;yymmdd&gt;.csv</code> (with columns <code>TFPJQ</code> and    <code>TFPKQ</code>). To include data on expected interest rates, the file    <code>ois_&lt;yymmdd&gt;.csv</code> is also required. To include data on population forecasts,    the file <code>population_forecst_&lt;yymmdd&gt;.csv</code> is also required (see    <a href="#Incorporate-population-forecasts-1">Incorporate population forecasts</a>. See    <a href="../frbny_data/#frbny-data-1">New York Fed Model Input Data</a> for details on the series    used and links to data sources.</p><p><strong>Step 4</strong>. Run <code>load_data(m)</code>; series from FRED will be downloaded and merged with the series from    non-FRED data sources that you have already created. See <a href="#Common-pitfalls-1">Common pitfalls</a> for some potential issues.</p><h2 id="Data-Transforms-and-Utilities-1"><a class="docs-heading-anchor" href="#Data-Transforms-and-Utilities-1">Data Transforms and Utilities</a><a class="docs-heading-anchor-permalink" href="#Data-Transforms-and-Utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DSGE.df_to_matrix-Tuple{Union{AbstractDSGEModel, AbstractVARModel},DataFrames.DataFrame}" href="#DSGE.df_to_matrix-Tuple{Union{AbstractDSGEModel, AbstractVARModel},DataFrames.DataFrame}"><code>DSGE.df_to_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">df_to_matrix(m, df; cond_type = :none, in_sample = true)</code></pre><p>Return <code>df</code>, converted to matrix of floats, and discard date column. Also ensure that rows are sorted by date and columns by <code>m.observables</code>, with the option to specify whether or not the out of sample rows are discarded. The output of this function is suitable for direct use in <code>estimate</code>, <code>posterior</code>, etc.</p><p><strong>Keyword Arguments:</strong></p><ul><li><code>include_presample::Bool</code>: indicates whether or not there are presample periods.</li><li><code>in_sample::Bool</code>: indicates whether or not to discard rows that are out of sample. Set this flag to false in</li></ul><p>the case that you are calling filter_shocks! in the scenarios codebase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L451-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.load_cond_data_levels-Tuple{AbstractDSGEModel}" href="#DSGE.load_cond_data_levels-Tuple{AbstractDSGEModel}"><code>DSGE.load_cond_data_levels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_cond_data_levels(m::AbstractDSGEModel; verbose::Symbol=:low)</code></pre><p>Check on disk in <code>inpath(m, &quot;cond&quot;)</code> for a conditional dataset (in levels) of the correct vintage and load it.</p><p>The following series are also loaded from <code>inpath(m, &quot;raw&quot;)</code> and either appended or merged into the conditional data:</p><ul><li>The last period of (unconditional) data in levels (<code>data_levels_&lt;yymmdd&gt;.csv</code>), used to calculate growth rates</li><li>The first period of forecasted population (<code>population_forecast_&lt;yymmdd&gt;.csv</code>), used for per-capita calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L270-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.load_data-Tuple{AbstractDSGEModel}" href="#DSGE.load_data-Tuple{AbstractDSGEModel}"><code>DSGE.load_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_data(m::AbstractDSGEModel; try_disk::Bool = true, verbose::Symbol = :low,
          check_empty_columns::Bool = true, summary_statistics::Symbol = :low)</code></pre><p>Create a DataFrame with all data series for this model, fully transformed.</p><p>First, check the disk to see if a valid dataset is already stored in <code>inpath(m, &quot;data&quot;)</code>. A dataset is valid if every series in <code>m.observable_mappings</code> is present and the entire sample is contained (from <code>date_presample_start</code> to <code>date_mainsample_end</code>. If no valid dataset is already stored, the dataset will be recreated. This check can be eliminated by passing <code>try_disk=false</code>.</p><p>If the dataset is to be recreated, in a preliminary stage, intermediate data series as specified in <code>m.observable_mappings</code> are loaded in levels using <code>load_data_levels</code>. See <code>?load_data_levels</code> for more details.</p><p>Then, the series in levels are transformed as specified in <code>m.observable_mappings</code>. See <code>?transform_data</code> for more details.</p><p>If <code>m.testing</code> is false, then the resulting DataFrame is saved to disk as <code>data_&lt;yymmdd&gt;.csv</code>. The data are then returned to the caller.</p><p>The keyword <code>check_empty_columns</code> throws an error whenever a column is completely empty in the loaded data set if it is set to true.</p><p>The keyword <code>summary_statistics</code> prints out a variety of summary statistics on the loaded data. When set to :low, we print only the number of missing/NaNs for each data series. When set to :high, we also print means, standard deviations,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.load_data_levels-Tuple{AbstractDSGEModel}" href="#DSGE.load_data_levels-Tuple{AbstractDSGEModel}"><code>DSGE.load_data_levels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_data_levels(m::AbstractDSGEModel; verbose::Symbol=:low)</code></pre><p>Load data in levels by appealing to the data sources specified for the model. Data from FRED is loaded first, by default; then, merge other custom data sources.</p><p>Check on disk in <code>inpath(m, &quot;data&quot;)</code> datasets, of the correct vintage, corresponding to the ones required by the entries in <code>m.observable_mappings</code>. Load the appropriate data series (specified in <code>m.observable_mappings[key].input_series</code>) for each data source.</p><p>To accomodate growth rates and other similar transformations, more rows of data may be downloaded than otherwise specified by the date model settings. (By the end of the process, these rows will have been dropped.)</p><p>Data from FRED (i.e. the <code>:fred</code> data source) are treated separately. These are downloaded using <code>load_fred_data</code>. See <code>?load_fred_data</code> for more details.</p><p>Data from non-FRED data sources are read from disk, verified, and merged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L120-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.parse_data_series-Tuple{AbstractDSGEModel}" href="#DSGE.parse_data_series-Tuple{AbstractDSGEModel}"><code>DSGE.parse_data_series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_data_series(m::AbstractDSGEModel)</code></pre><p>Parse <code>m.observable_mappings</code> for the data sources and mnemonics to read in.</p><p>Returns a <code>Dict{Symbol, Vector{Symbol}}</code> mapping sources =&gt; mnemonics found in that data file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L521-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.save_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}" href="#DSGE.save_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}"><code>DSGE.save_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_data(m::AbstractDSGEModel, df::DataFrame; cond_type::Symbol = :none)</code></pre><p>Save <code>df</code> to disk as CSV. File is located in <code>inpath(m, &quot;data&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L334-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.load_fred_data-Tuple{AbstractDSGEModel}" href="#DSGE.load_fred_data-Tuple{AbstractDSGEModel}"><code>DSGE.load_fred_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_fred_data(m::AbstractDSGEModel; start_date=&quot;1959-03-31&quot;, end_date=prev_quarter())</code></pre><p>Checks in <code>inpath(m, raw)</code> for a FRED dataset corresponding to <code>data_vintage(m)</code>. If a FRED vintage exists on disk, any required FRED series that is contained therein will be imported. All missing series will be downloaded directly from FRED using the <em>FredData</em> package. The full dataset is written to the appropriate data vintage file and returned.</p><p><strong>Arguments</strong></p><ul><li><code>m::AbstractDSGEModel</code>: the model object</li><li><code>start_date</code>: starting date.</li><li><code>end_date</code>: ending date.</li></ul><p><strong>Notes</strong></p><p>The FRED API reports observations according to the quarter-start date. <code>load_fred_data</code> returns data indexed by quarter-end date for compatibility with other datasets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/fred_data.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.transform_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}" href="#DSGE.transform_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}"><code>DSGE.transform_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform_data(m::AbstractDSGEModel, levels::DataFrame; cond_type::Symbol = :none,
    verbose::Symbol = :low)</code></pre><p>Transform data loaded in levels and order columns appropriately for the DSGE model. Returns DataFrame of transformed data.</p><p>The DataFrame <code>levels</code> is output from <code>load_data_levels</code>. The series in levels are transformed as specified in <code>m.observable_mappings</code>.</p><ul><li>To prepare for per-capita transformations, population data are filtered using <code>hpfilter</code>. The series in <code>levels</code> to use as the population series is given by the <code>population_mnemonic</code> setting. If <code>use_population_forecast(m)</code>, a population forecast is appended to the recorded population levels before the filtering. Both filtered and unfiltered population levels and growth rates are added to the <code>levels</code> data frame.</li><li>The transformations are applied for each series using the <code>levels</code> DataFrame as input.</li></ul><p>Conditional data (identified by <code>cond_type in [:semi, :full]</code>) are handled slightly differently: If <code>use_population_forecast(m)</code>, we drop the first period of the population forecast because we treat the first forecast period <code>date_forecast_start(m)</code> as if it were data. We also only apply transformations for the observables given in <code>cond_full_names(m)</code> or <code>cond_semi_names(m)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transform_data.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.annualtoquarter-Tuple{Any}" href="#DSGE.annualtoquarter-Tuple{Any}"><code>DSGE.annualtoquarter</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>annualtoquarter(v)</code></p><p>Convert from annual to quarter frequency... by dividing by 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.difflog-Tuple{AbstractArray{T,1} where T}" href="#DSGE.difflog-Tuple{AbstractArray{T,1} where T}"><code>DSGE.difflog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difflog(x::AbstractVector)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.difflog-Tuple{AbstractArray}" href="#DSGE.difflog-Tuple{AbstractArray}"><code>DSGE.difflog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difflog(x::AbstractArray{AbstractFloat})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.hpfilter-Tuple{AbstractArray{T,1} where T,Real}" href="#DSGE.hpfilter-Tuple{AbstractArray{T,1} where T,Real}"><code>DSGE.hpfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yt, yf = hpfilter(y, λ)</code></pre><p>Applies the Hodrick-Prescott filter (&quot;H-P filter&quot;). The smoothing parameter <code>λ</code> is applied to the columns of <code>y</code>, returning the trend component <code>yt</code> and the cyclical component <code>yf</code>. For quarterly data, one can use λ=1600.</p><p>Consecutive missing values at the beginning or end of the time series are excluded from the filtering. If there are missing values within the series, the filtered values are all missing.</p><p>See also:</p><pre><code class="language-none">Hodrick, Robert; Prescott, Edward C. (1997). &quot;Postwar U.S. Business Cycles: An Empirical
Investigation&quot;. Journal of Money, Credit, and Banking 29 (1): 1–16.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L92-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.loggrowthtopct-Tuple{AbstractArray}" href="#DSGE.loggrowthtopct-Tuple{AbstractArray}"><code>DSGE.loggrowthtopct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loggrowthtopct(y)</code></pre><p>Transform from annualized quarter-over-quarter log growth rates to annualized quarter-over-quarter percent change.</p><p><strong>Note</strong></p><p>This should only be used in Model 510, which has the core PCE inflation observable in annualized log growth rates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L196-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.loggrowthtopct_4q_approx" href="#DSGE.loggrowthtopct_4q_approx"><code>DSGE.loggrowthtopct_4q_approx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loggrowthtopct_4q_approx(y, data = fill(NaN, 3))</code></pre><p>Transform from log growth rates to <em>approximate</em> 4-quarter percent change.</p><p><strong>This method should only be used to transform scenarios forecasts, which are in   deviations from baseline.</strong></p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to aggregate 4-quarter percent change from log per-capita growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L736-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.loggrowthtopct_annualized-Tuple{AbstractArray}" href="#DSGE.loggrowthtopct_annualized-Tuple{AbstractArray}"><code>DSGE.loggrowthtopct_annualized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loggrowthtopct_annualized(y)</code></pre><p>Transform from log growth rates to annualized quarter-over-quarter percent change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L253-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.loggrowthtopct_annualized_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#DSGE.loggrowthtopct_annualized_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>DSGE.loggrowthtopct_annualized_percapita</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loggrowthtopct_annualized_percapita(y, pop_growth)</code></pre><p>Transform from log per-capita growth rates to annualized aggregate (not per-capita) quarter-over-quarter percent change.</p><p><strong>Note</strong></p><p>This should only be used for output, consumption, investment and GDP deflator (inflation).</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized percent change from quarter-over-quarter log growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L264-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.loggrowthtopct_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#DSGE.loggrowthtopct_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>DSGE.loggrowthtopct_percapita</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loggrowthtopct_percapita(y, pop_growth)</code></pre><p>Transform from annualized quarter-over-quarter log per-capita growth rates to annualized quarter-over-quarter aggregate percent change.</p><p><strong>Note</strong></p><p>This should only be used in Model 510, which has the output growth observable in annualized log per-capita growth rates.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized percent change from annualized log growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L213-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.logleveltopct_4q_approx" href="#DSGE.logleveltopct_4q_approx"><code>DSGE.logleveltopct_4q_approx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logleveltopct_4q_approx(y, data = fill(NaN, 4))</code></pre><p>Transform from log levels to <em>approximate</em> 4-quarter percent change.</p><p><strong>This method should only be used to transform scenarios forecasts, which are in   deviations from baseline.</strong></p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to 4-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-4}, y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L771-L790">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.logleveltopct_annualized" href="#DSGE.logleveltopct_annualized"><code>DSGE.logleveltopct_annualized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logleveltopct_annualized(y, y0 = NaN)</code></pre><p>Transform from log levels to annualized quarter-over-quarter percent change.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized quarter-over-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>y0</code>: the last data point in the history (of state or observable) corresponding to the <code>y</code> variable. This is required to compute a percent change for the first period.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L304-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.logleveltopct_annualized_approx" href="#DSGE.logleveltopct_annualized_approx"><code>DSGE.logleveltopct_annualized_approx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logleveltopct_annualized_approx(y, y0 = NaN)</code></pre><p>Transform from log levels to <em>approximate</em> annualized quarter-over-quarter percent change.</p><p><strong>This method should only be used to transform scenarios forecasts, which are in   deviations from baseline.</strong></p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized quarter-over-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>y0</code>: the last data point in the history (of state or observable) corresponding to the <code>y</code> variable. This is required to compute a percent change for the first period.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L699-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.logleveltopct_annualized_percapita" href="#DSGE.logleveltopct_annualized_percapita"><code>DSGE.logleveltopct_annualized_percapita</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logleveltopct_annualized_percapita(y, pop_growth, y0 = NaN)</code></pre><p>Transform from per-capita log levels to annualized aggregate (not per-capita) quarter-over-quarter percent change.</p><p><strong>Note</strong></p><p>This is usually applied to labor supply (hours worked per hour), and probably shouldn&#39;t be used for any other observables.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized aggregate quarter-over-quarter percent change from per-capita log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li><li><p><code>y0</code>: The last data point in the history (of state or observable) corresponding to the <code>y</code> variable. This is required to compute a percent change for the first period.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L337-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.nominal_to_real-Tuple{Symbol,DataFrames.DataFrame}" href="#DSGE.nominal_to_real-Tuple{Symbol,DataFrames.DataFrame}"><code>DSGE.nominal_to_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nominal_to_real(col, df; deflator_mnemonic = :GDPDEF)</code></p><p>Converts nominal to real values using the specified deflator.</p><p><strong>Arguments</strong></p><ul><li><code>col</code>: Symbol indicating which column of <code>df</code> to transform</li><li><code>df</code>: DataFrame containining series for proper population measure and <code>col</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>deflator_mnemonic</code>: indicates which deflator to use to calculate real values. Default value is the FRED GDP Deflator mnemonic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L29-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.oneqtrpctchange-Tuple{AbstractArray{T,1} where T}" href="#DSGE.oneqtrpctchange-Tuple{AbstractArray{T,1} where T}"><code>DSGE.oneqtrpctchange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">oneqtrpctchange(y)</code></pre><p>Calculates the quarter-to-quarter percentage change of a series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L182-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.percapita-Tuple{AbstractDSGEModel,Symbol,DataFrames.DataFrame}" href="#DSGE.percapita-Tuple{AbstractDSGEModel,Symbol,DataFrames.DataFrame}"><code>DSGE.percapita</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">percapita(m, col, df)
percapita(col, df, population_mnemonic)</code></pre><p>Converts data column <code>col</code> of DataFrame <code>df</code> to a per-capita value.</p><p>The first method checks <code>hpfilter_population(m)</code>. If true, then it divides by the filtered population series. Otherwise it divides by the result of <code>parse_population_mnemonic(m)[1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>col</code>: <code>Symbol</code> indicating which column of data to transform</li><li><code>df</code>: <code>DataFrame</code> containining series for proper population measure and <code>col</code></li><li><code>population_mnemonic</code>: a mnemonic found in <code>df</code> for some population measure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L48-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.quartertoannual-Tuple{Any}" href="#DSGE.quartertoannual-Tuple{Any}"><code>DSGE.quartertoannual</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>quartertoannual(v)</code></p><p>Convert from quarter to annual frequency... by multiplying by 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.quartertoannualpercent-Tuple{Any}" href="#DSGE.quartertoannualpercent-Tuple{Any}"><code>DSGE.quartertoannualpercent</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>quartertoannualpercent(v)</code></p><p>Convert from quarter to annual frequency in percent... by multiplying by 400.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_data_filename-Tuple{AbstractDSGEModel,Symbol}" href="#DSGE.get_data_filename-Tuple{AbstractDSGEModel,Symbol}"><code>DSGE.get_data_filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_data_filename(m, cond_type)</code></pre><p>Returns the data file for <code>m</code>, which depends on <code>data_vintage(m)</code>, and if <code>cond_type in [:semi, :full]</code>, also on <code>cond_vintage(m)</code> and <code>cond_id(m)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L228-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.iterate_quarters-Tuple{Dates.Date,Int64}" href="#DSGE.iterate_quarters-Tuple{Dates.Date,Int64}"><code>DSGE.iterate_quarters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iterate_quarters(start::Date, quarters::Int)</code></pre><p>Returns the date corresponding to <code>start</code> + <code>quarters</code> quarters.</p><p><strong>Inputs</strong></p><ul><li><code>start</code>: starting date</li><li><code>quarters</code>: number of quarters to iterate forward or backward</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L252-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.quartertodate-Tuple{String}" href="#DSGE.quartertodate-Tuple{String}"><code>DSGE.quartertodate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>quartertodate(string::String)</code></p><p>Convert <code>string</code> in the form &quot;YYqX&quot;, &quot;YYYYqX&quot;, or &quot;YYYY-qX&quot; to a Date of the end of the indicated quarter. &quot;X&quot; is in <code>{1,2,3,4}</code> and the case of &quot;q&quot; is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.subtract_quarters-Tuple{Dates.Date,Dates.Date}" href="#DSGE.subtract_quarters-Tuple{Dates.Date,Dates.Date}"><code>DSGE.subtract_quarters</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>subtract_quarters(t1::Date, t0::Date)</code></p><p>Compute the number of quarters between t1 and t0, including t0 and excluding t1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.data_to_df-Union{Tuple{T}, Tuple{AbstractDSGEModel,Array{T,2},Dates.Date}} where T&lt;:AbstractFloat" href="#DSGE.data_to_df-Union{Tuple{T}, Tuple{AbstractDSGEModel,Array{T,2},Dates.Date}} where T&lt;:AbstractFloat"><code>DSGE.data_to_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">data_to_df(m, data, start_date)</code></pre><p>Create a <code>DataFrame</code> out of the matrix <code>data</code>, including a <code>:date</code> column beginning in <code>start_date</code>.  Variable names and indices are obtained from <code>m.observables</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L492-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.has_saved_data-Tuple{AbstractDSGEModel}" href="#DSGE.has_saved_data-Tuple{AbstractDSGEModel}"><code>DSGE.has_saved_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_saved_data(m::AbstractDSGEModel; cond_type::Symbol = :none)</code></pre><p>Determine if there is a saved dataset on disk for the required vintage and conditional type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L346-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.isvalid_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}" href="#DSGE.isvalid_data-Tuple{AbstractDSGEModel,DataFrames.DataFrame}"><code>DSGE.isvalid_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isvalid_data(m::AbstractDSGEModel, df::DataFrame; cond_type::Symbol = :none,
    check_empty_columns::Bool = true)</code></pre><p>Return if dataset is valid for this model, ensuring that all observables are contained and that all quarters between the beginning of the presample and the end of the mainsample are contained. Also checks to make sure that expected interest rate data is available if <code>n_mon_anticipated_shocks(m) &gt; 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L378-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_data-Tuple{AbstractDSGEModel}" href="#DSGE.read_data-Tuple{AbstractDSGEModel}"><code>DSGE.read_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_data(m::AbstractDSGEModel; cond_type::Symbol = :none)</code></pre><p>Read CSV from disk as DataFrame. File is located in <code>inpath(m, &quot;data&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L359-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_population_data-Tuple{AbstractDSGEModel}" href="#DSGE.read_population_data-Tuple{AbstractDSGEModel}"><code>DSGE.read_population_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_population_data(m; verbose = :low)

read_population_data(filename; verbose = :low)</code></pre><p>Read in population data stored in levels, either from <code>inpath(m, &quot;raw&quot;, &quot;population_data_levels_[vint].csv&quot;</code>) or <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L551-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.read_population_forecast-Tuple{AbstractDSGEModel}" href="#DSGE.read_population_forecast-Tuple{AbstractDSGEModel}"><code>DSGE.read_population_forecast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_population_forecast(m; verbose = :low)

read_population_forecast(filename, population_mnemonic, last_recorded_date; verbose = :low)</code></pre><p>Read in population forecast in levels, either from <code>inpath(m, &quot;raw&quot;, &quot;population_forecast_[vint].csv&quot;)</code> or <code>filename</code>. If that file does not exist, return an empty <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/load_data.jl#L577-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.transform_population_data-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Symbol}" href="#DSGE.transform_population_data-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Symbol}"><code>DSGE.transform_population_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform_population_data(population_data, population_forecast,
    population_mnemonic; verbose = :low)</code></pre><p>Load, HP-filter, and compute growth rates from population data in levels. Optionally do the same for forecasts.</p><p><strong>Inputs</strong></p><ul><li><code>population_data</code>: pre-loaded DataFrame of historical population data containing the columns <code>:date</code> and <code>population_mnemonic</code>. Assumes this is sorted by date.</li><li><code>population_forecast</code>: pre-loaded <code>DataFrame</code> of population forecast containing the columns <code>:date</code> and <code>population_mnemonic</code></li><li><code>population_mnemonic</code>: column name for population series in <code>population_data</code> and <code>population_forecast</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbose</code>: one of <code>:none</code>, <code>:low</code>, or <code>:high</code></li><li><code>use_hpfilter</code>: whether to HP filter population data and forecast. See <code>Output</code> below.</li><li><code>pad_forecast_start::Bool</code>: Whether you want to re-size</li></ul><p>the population<em>forecast such that the first index is one quarter ahead of the last index of population</em>data. Only set to false if you have manually constructed population_forecast to artificially start a quarter earlier, so as to avoid having an unnecessary missing first entry.</p><p><strong>Output</strong></p><p>Two dictionaries containing the following keys:</p><ul><li><p><code>population_data_out</code>:</p><ul><li><code>:filtered_population_recorded</code>: HP-filtered historical population series (levels)</li><li><code>:dlfiltered_population_recorded</code>: HP-filtered historical population series (growth rates)</li><li><code>:dlpopulation_recorded</code>: Non-filtered historical population series (growth rates)</li></ul></li><li><p><code>population_forecast_out</code>:</p><ul><li><code>:filtered_population_forecast</code>: HP-filtered population forecast series (levels)</li><li><code>:dlfiltered_population_forecast</code>: HP-filtered population forecast series (growth rates)</li><li><code>:dlpopulation_forecast</code>: Non-filtered historical population series (growth rates)</li></ul></li></ul><p>If <code>population_forecast_file</code> is not provided, the r&quot;<em>forecast&quot; fields will be empty. If <code>use_hpfilter = false</code>, then the r&quot;</em>filtered*&quot; fields will be empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transform_data.jl#L86-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_irf_transform-Tuple{Function}" href="#DSGE.get_irf_transform-Tuple{Function}"><code>DSGE.get_irf_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_irf_transform(transform::Function)</code></pre><p>Returns the IRF-specific transformation, which doesn&#39;t add back population growth (since IRFs are given in deviations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L404-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_nopop_transform-Tuple{Function}" href="#DSGE.get_nopop_transform-Tuple{Function}"><code>DSGE.get_nopop_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_nopop_transform(transform::Function)</code></pre><p>Returns the corresponding transformation which doesn&#39;t add back population growth. Used for shock decompositions, deterministic trends, and IRFs, which are given in deviations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L386-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_scenario_transform-Tuple{Function}" href="#DSGE.get_scenario_transform-Tuple{Function}"><code>DSGE.get_scenario_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_transform(transform::Function)</code></pre><p>Given a transformation used for usual forecasting, return the transformation used for <em>scenarios</em>, which are forecasted in deviations from baseline.</p><p>The 1Q deviation from baseline should really be calculated by 1Q transforming the forecasts (in levels) under the baseline (call this <code>y_b</code>) and alternative scenario (<code>y_s</code>), then subtracting baseline from alternative scenario (since most of our 1Q transformations are nonlinear). Let <code>y_d = y_s - y_b</code>. Then, for example, the most correct <code>loggrowthtopct_annualized</code> transformation is:</p><pre><code class="language-none">y_b_1q = 100*(exp(y_b/100)^4 - 1)
y_s_1q = 100*(exp(y_s/100)^4 - 1)
y_d_1q = y_b_1q - y_s_1q</code></pre><p>Instead, we approximate this by transforming the deviation directly:</p><pre><code class="language-none">y_d_1q ≈ 4*(y_b - y_s)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L647-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_transform4q-Tuple{Function}" href="#DSGE.get_transform4q-Tuple{Function}"><code>DSGE.get_transform4q</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_transform4q(transform::Function)</code></pre><p>Returns the 4-quarter transformation associated with the annualizing transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L421-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.lag-Tuple{AbstractArray,Int64}" href="#DSGE.lag-Tuple{AbstractArray,Int64}"><code>DSGE.lag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">series_lag_n = lag(series, n)</code></pre><p>Returns a particular data series lagged by n periods</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.loggrowthtopct_4q" href="#DSGE.loggrowthtopct_4q"><code>DSGE.loggrowthtopct_4q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loggrowthtopct_4q(y, data = fill(NaN, 3))</code></pre><p>Transform from log growth rates to 4-quarter percent change.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to aggregate 4-quarter percent change from log per-capita growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L445-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.loggrowthtopct_4q_percapita" href="#DSGE.loggrowthtopct_4q_percapita"><code>DSGE.loggrowthtopct_4q_percapita</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loggrowthtopct_4q_percapita(y, pop_growth, data = fill(NaN, 3))</code></pre><p>Transform from log per-capita growth rates to aggregate 4-quarter percent change.</p><p><strong>Note</strong></p><p>This should only be used for output, consumption, investment, and GDP deflator (inflation).</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to aggregate 4-quarter percent change from log per-capita growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L479-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.logleveltopct_4q" href="#DSGE.logleveltopct_4q"><code>DSGE.logleveltopct_4q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logleveltopct_4q(y, data = fill(NaN, 4))</code></pre><p>Transform from log levels to 4-quarter percent change.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to 4-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-4}, y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L533-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.logleveltopct_4q_percapita" href="#DSGE.logleveltopct_4q_percapita"><code>DSGE.logleveltopct_4q_percapita</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logleveltopct_4q_percapita(y, pop_growth, data = fill(NaN, 4))</code></pre><p>Transform from per-capita log levels to 4-quarter aggregate percent change.</p><p><strong>Note</strong></p><p>This is usually applied to labor supply (hours worked), and probably shouldn&#39;t be used for any other observables.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to 4-quarter aggregate percent change from per-capita log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-4}, y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L569-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.prepend_data-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#DSGE.prepend_data-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>DSGE.prepend_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prepend_data(y, data)</code></pre><p>Prepends data necessary for running 4q transformations.</p><p><strong>Inputs:</strong></p><ul><li><code>y</code>: <code>ndraws x t</code> array representing a timeseries for variable <code>y</code></li><li><code>data</code>: vector representing a timeseries to prepend to <code>y</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/transformations.jl#L623-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.datetoquarter-Tuple{Dates.Date}" href="#DSGE.datetoquarter-Tuple{Dates.Date}"><code>DSGE.datetoquarter</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>datetoquarter(date::Date)</code></p><p>Convert <code>string</code> in the form &quot;YYqX&quot;, &quot;YYYYqX&quot;, or &quot;YYYY-qX&quot; to a Date of the end of the indicated quarter. &quot;X&quot; is in <code>{1,2,3,4}</code> and the case of &quot;q&quot; is ignored.</p><p>Return an integer from the set <code>{1,2,3,4}</code>, corresponding to one of the quarters in a year given a Date object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.datetoymdvec-Tuple{Dates.Date}" href="#DSGE.datetoymdvec-Tuple{Dates.Date}"><code>DSGE.datetoymdvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">datetoymdvec(dt)</code></pre><p>converts a Date to a vector/matrix holding the year, month, and date.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L303-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.format_dates!-Tuple{Symbol,DataFrames.DataFrame}" href="#DSGE.format_dates!-Tuple{Symbol,DataFrames.DataFrame}"><code>DSGE.format_dates!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>format_dates!(col, df)</code></p><p>Change column <code>col</code> of dates in <code>df</code> from String to Date, and map any dates given in the interior of a quarter to the last day of the quarter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.get_quarter_ends-Tuple{Dates.Date,Dates.Date}" href="#DSGE.get_quarter_ends-Tuple{Dates.Date,Dates.Date}"><code>DSGE.get_quarter_ends</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_quarter_ends(start_date::Date,end_date::Date)</code></p><p>Returns an Array of quarter end dates between <code>start_date</code> and <code>end_date</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.missing2nan-Tuple{Array}" href="#DSGE.missing2nan-Tuple{Array}"><code>DSGE.missing2nan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">missing2nan(a::Array)</code></pre><p>Convert all elements of Union{X, Missing.Missing} or Missing.Missing to type Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.missing_cond_vars!-Tuple{AbstractDSGEModel,DataFrames.DataFrame}" href="#DSGE.missing_cond_vars!-Tuple{AbstractDSGEModel,DataFrames.DataFrame}"><code>DSGE.missing_cond_vars!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">missing_cond_vars!(m, df; cond_type = :none, check_empty_columns = true)</code></pre><p>Make conditional period variables not in <code>cond_semi_names(m)</code> or <code>cond_full_names(m)</code> missing if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L180-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.na2nan!-Tuple{Array}" href="#DSGE.na2nan!-Tuple{Array}"><code>DSGE.na2nan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">na2nan!(df::Array)</code></pre><p>Convert all NAs in an Array to NaNs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L167-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.na2nan!-Tuple{DataFrames.DataFrame}" href="#DSGE.na2nan!-Tuple{DataFrames.DataFrame}"><code>DSGE.na2nan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">na2nan!(df::DataFrame)</code></pre><p>Convert all NAs in a DataFrame to NaNs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.next_quarter" href="#DSGE.next_quarter"><code>DSGE.next_quarter</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>next_quarter(q::TimeType = now())</code></p><p>Returns Date identifying last day of the next quarter</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.prev_quarter" href="#DSGE.prev_quarter"><code>DSGE.prev_quarter</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>prev_quarter(q::TimeType = now())</code></p><p>Returns Date identifying last day of the previous quarter</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.quartertofloats-Tuple{Dates.Date}" href="#DSGE.quartertofloats-Tuple{Dates.Date}"><code>DSGE.quartertofloats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quartertofloats(dt)</code></pre><p>converts a Date to a floating point number based on the quarter</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L320-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.reconcile_column_names-Tuple{DataFrames.DataFrame,DataFrames.DataFrame}" href="#DSGE.reconcile_column_names-Tuple{DataFrames.DataFrame,DataFrames.DataFrame}"><code>DSGE.reconcile_column_names</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reconcile_column_names(a::DataFrame, b::DataFrame)</code></pre><p>adds columns of missings to a and b so that both have the same set of column names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.vinttodate-Tuple{String}" href="#DSGE.vinttodate-Tuple{String}"><code>DSGE.vinttodate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function vinttodate(vint)</code></pre><p>Return the string given by data_vintage(m), which is in the format YYYYMMDD, to a Date object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/8883837852324288ed60a6f54a9dc9cc0935feb1/src/data/util.jl#L79-L85">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../running_existing_model/">« Running An Existing Model</a><a class="docs-footer-nextpage" href="../frbny_data/">FRBNY Model Input Data »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 30 August 2021 20:22">Monday 30 August 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
