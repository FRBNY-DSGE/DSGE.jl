<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MATLAB to Julia Transition: Estimation · DSGE.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DSGE.jl logo"/></a><h1>DSGE.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../model_design/">Model Design</a></li><li><a class="toctext" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="toctext" href="../advanced_usage/">Advanced Usage</a></li><li><a class="toctext" href="../input_data/">Input Data</a></li><li><a class="toctext" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="toctext" href="../implementation_details/">Implementation Details</a></li><li><a class="toctext" href="../solving/">Solving the Model</a></li><li><a class="toctext" href="../estimation/">Estimation</a></li><li><a class="toctext" href="../forecast/">Forecasting</a></li><li><a class="toctext" href="../irf/">Impulse Response Functions</a></li><li><a class="toctext" href="../means_bands/">Computing Means and Bands</a></li><li><a class="toctext" href="../altpolicy/">Alternative Policies</a></li><li><a class="toctext" href="../scenarios/">Alternative Scenarios</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li><li><a class="toctext" href="../algorithms/">Algorithms</a></li><li><a class="toctext" href="../contributing/">Contributing to DSGE.jl</a></li><li class="current"><a class="toctext" href>MATLAB to Julia Transition: Estimation</a><ul class="internal"><li><a class="toctext" href="#Code-Improvements-1">Code Improvements</a></li><li><a class="toctext" href="#Challenges-1">Challenges</a></li><li><a class="toctext" href="#Conclusion-1">Conclusion</a></li><li><a class="toctext" href="#Disclaimer-1">Disclaimer</a></li></ul></li><li><a class="toctext" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>MATLAB to Julia Transition: Estimation</a></li></ul><a class="edit-page" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/docs/src/MatlabToJuliaTransition.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MATLAB to Julia Transition: Estimation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-DSGE-MATLAB-to-Julia-Transition:-Improvements-and-Challenges-1" href="#The-DSGE-MATLAB-to-Julia-Transition:-Improvements-and-Challenges-1">The DSGE MATLAB to Julia Transition: Improvements and Challenges</a></h1><p><em>Zac Cranko, Pearl Li, Spencer Lyon, Erica Moszkowski, Micah Smith, Pablo Winant</em>  </p><p><em>December 3, 2015</em></p><p>The FRBNY DSGE model is a relatively large New Keynesian model augmented with financial frictions and a variety of innovations. Here at the Fed, we use it both for forecasting and policy analysis. Research using this model includes looking at the dynamics of <a href="https://www.newyorkfed.org/medialibrary/media/research/staff_reports/sr618.pdf">inflation during the great recession</a>, the effects of <a href="https://www.newyorkfed.org/medialibrary/media/research/staff_reports/sr574.pdf">forward guidance</a>, <a href="http://libertystreeteconomics.newyorkfed.org/2015/05/why-are-interest-rates-so-low.html">and</a> <a href="http://libertystreeteconomics.newyorkfed.org/2014/09/an-assessment-of-the-frbny-dsge-models-real-time-forecasts.html">much</a> <a href="https://www.newyorkfed.org/medialibrary/media/research/staff_reports/sr695.pdf">more</a>.</p><p>When we were approached by the folks at <a href="http://quantecon.org/">QuantEcon</a> about a possible collaboration, we jumped at the idea, as it would give us an opportunity to rework our code in an arguably faster language, redesign it from the ground up, and release it open source for the benefit of the community. A full-fledged package for the FRBNY DSGE model would also provide QuantEcon another opportunity to highlight its contribution to high-performance, quantitative economic modeling. Julia was the language of choice, recommended by the QuantEcon group for its high performance and suitability for this breed of technical computing.</p><p>In this post, we’ll discuss our experiences redesigning our code from the ground up, the resulting performance changes, and the challenges we faced working with such a young language.  We created a suite to assess the performance of our Julia code, relative to our MATLAB code. We focus on both the core functions used in solving and estimating the model, as well as on longer-running routines of greater scope. These tests were conducted on a single core on an Intel® Xeon® E5-2697 v2 2.70GHz CPU running GNU/Linux:</p><p>Benchmark times relative to MATLAB (smaller is better)</p><table><tr><th style="text-align: right">Test</th><th style="text-align: center">MATLAB (14a)</th><th style="text-align: center">Julia (0.4.0)</th></tr><tr><td style="text-align: right"><code>gensys</code></td><td style="text-align: center">1.00</td><td style="text-align: center">0.17</td></tr><tr><td style="text-align: right"><code>solve</code></td><td style="text-align: center">1.00</td><td style="text-align: center">0.09</td></tr><tr><td style="text-align: right"><code>kalman_filter</code></td><td style="text-align: center">1.00</td><td style="text-align: center">0.75</td></tr><tr><td style="text-align: right"><code>posterior</code></td><td style="text-align: center">1.00</td><td style="text-align: center">0.26</td></tr><tr><td style="text-align: right"><code>csminwel</code></td><td style="text-align: center">1.00</td><td style="text-align: center">0.33</td></tr><tr><td style="text-align: right"><code>hessian</code></td><td style="text-align: center">1.00</td><td style="text-align: center">0.23</td></tr><tr><td style="text-align: right"><code>metropolis_hastings</code></td><td style="text-align: center">1.00</td><td style="text-align: center">0.11</td></tr></table><p>We ultimately achieve an increase of speed that reduces running time to 1/10th to 3/4th that of the MATLAB code. The Metropolis-Hastings sampling step is the most time consuming, and hence the relevant one in terms of assessing speed improvement. On the basis of this step, we conclude that <em>DSGE.jl</em> is approximately ten times faster than the MATLAB code.</p><p>How much of this increase is due to native performance adventures of Julia, and how much is simply due to the improvements in design that came from rebuilding this project from the ground up? It is of course difficult to say, and it is important to emphasize that one cannot be sure what portion of the performance increase can be attributed to inherent language features as opposed to design differences. Indeed, our MATLAB code suffers from many inefficiencies due to its long, cumulative development, and support for a plethora of models and features. Meanwhile, these design issues have been largely addressed in our Julia package. To best isolate differences in the languages themselves, we can look at our code to compute the model solution with <code>gensys</code> and apply the Kalman filter with <code>kalman_filter</code>. These two functions have relatively little redesign and optimization as compared to the MATLAB code and provide the most comparable, though still imperfect, measurements of performance. The reduction of 1/5th to 3/4th in computing time, therefore, could be taken as a first estimate of Julia&#39;s advantage in this single arena of computation.</p><h2><a class="nav-anchor" id="Code-Improvements-1" href="#Code-Improvements-1">Code Improvements</a></h2><p>Julia provides versatile language features that allow us to improve our code&#39;s performance and clarity in several fundamental ways. First and foremost of these is the highly integrated, robust, and flexible type system that lends itself naturally to our DSGE model. At the center of the <em>DSGE.jl</em> package is the <em>model object</em>. Here, one can store all information associated with the model – including the numerous parameters, priors, states, equilibrium conditions, computational settings, and flags – in one place.  By simply passing the model object as an argument to any function, the function has access to all of the model&#39;s fields.  By comparison, our MATLAB code stored all variables directly in the global workspace – an approach that scaled poorly as model specifications become more and more complex. To illustrate just how unwieldy our MATLAB code was, many of our function calls required more than 20 positional arguments, a serious challenge for usage and human-readability:</p><pre><code class="language-matlab">[post_new,like_new,zend_new,ZZ_new,DD_new,QQ_new] = ...
    feval(&#39;objfcnmhdsge&#39;,para_new,bounds,YY,YY0,nobs,nlags,nvar,mspec,npara,...
    trspec,pmean,pstdd,pshape,TTT_new,RRR_new,CCC_new,valid_new,para_mask,...
    coint,cointadd,cointall,YYcoint0,args_nant_antlags{:});</code></pre><p>While several of these arguments (e.g., <code>coint</code>) relate to a feature not-implemented in Julia, one can still see the excesses of providing so much information about the model separately in function calls.</p><p>The same code in Julia:</p><pre><code class="language-julia">post_out = posterior!(m, para_new, data; mh=true)</code></pre><p>Certainly, one could approximate a &quot;model object&quot; in MATLAB by using its own object-oriented classes, or by &quot;bundling&quot; model attributes into a <code>struct</code> or other data structure.  However, MATLAB classes are both relatively complicated and slower than non-object implementations. And using <code>struct</code>s in this way results in copies of all model variables made on every function call.</p><p>Indeed, changes like this reduce the number of lines of code in <em>DSGE.jl</em>, a rough proxy for ease of maintenance. We find that the fixed cost of setting up the type system is offset by savings in core programs.</p><table><tr><th style="text-align: right">Language</th><th style="text-align: center">Lines of code (hundreds)</th></tr><tr><td style="text-align: right">Matlab</td><td style="text-align: center">63</td></tr><tr><td style="text-align: right">Julia</td><td style="text-align: center">37</td></tr></table><p>A type-based approach allows us to take advantage of method dispatch in Julia by defining different model types for different model specifications. As detailed in the <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/README.md">README file</a>, changes to the model&#39;s equilibrium conditions and measurement equation are referred to as changes in a model&#39;s &quot;specification.&quot;  In the Julia code, model specifications have a 1:1 correspondence with concrete types.  Where necessary, a single <em>function</em> can have multiple <em>methods</em> defined, that are customized for different model types. For example, the <code>augment_states</code> function augments the model&#39;s transition matrices after it has been solved.  We can pass any model object <code>m</code> to <code>augment_states</code>, and Julia ensures that the proper, model-specific <em>method</em> is <em>dispatched</em>:</p><pre><code class="language-julia">TTT, RRR, CCC = augment_states(m, TTT_gensys, RRR_gensys, CCC_gensys)</code></pre><p>In our MATLAB code, on the other hand, we would approximate this type of dispatch by using a <code>switch</code> statement over a model identifier variable. For the hundreds of models we have worked with in a development capacity, this led to bloat in our model solution code. In Julia, we encapsulate this behavior within the model definition itself.</p><p>It is easy to see that all model types constructed for use with <em>DSGE.jl</em> are closely related: they will have the same fields, and are passed to the same methods.  If it sounds to you like we have an implicit interface here, you’re right. Rather than implementing each object as a standalone type, we define an abstract type, <code>AbstractModel</code>, to serve as the parent for all model types. Because most of our routines are not model-specific, we need only define them once (with an argument of type <code>AbstractModel</code>) and Julia&#39;s dispatch system takes care of the rest. We similarly define model parameters as subtypes of a common abstract type <code>AbstractParameter</code>. This allows us to abstract to one notion of a model parameter, while implementing different kinds of parameters in different ways. We also use parameterized (generic) types to increase the flexibility of model parameters (as well as elsewhere in our codebase):</p><pre><code class="language-julia"># A parameter contains values of data type `T` and embeds a transformation of
# type `U`
abstract Parameter{T,U&lt;:Transform} &lt;: AbstractParameter{T}

# One transformation used is the identity
type UnscaledParameter{T,U} &lt;: Parameter{T,U}
    # ...
end</code></pre><p>These functions expect the model object to have certain fields, and for those fields to have certain types. (As an example of Julia&#39;s youthful status as a language, <a href="https://github.com/JuliaLang/julia/issues/6975">discussion continues</a>, as of this writing, on an appropriate manner to explicitly introduce interfaces.)</p><p>With a clear interface in place, running new model specifications using <em>DSGE.jl</em> is relatively straightforward. (See <a href="../advanced_usage/#editing-extending-model-1">here</a> for detailed instructions).</p><p>Julia&#39;s JIT compilation provides significant performance boosts in some areas. For example, we allow a variable number of anticipated monetary policy shocks, beginning in 2008Q4, that we use to treat the zero lower bound. In our MATLAB code, we suffer some dynamic code generation to implement this feature.</p><pre><code class="language-matlab">if exist(&#39;nant&#39;,&#39;var&#39;)
    for i=1:nant
        eval(strcat(&#39;rm_tl&#39;,num2str(i),&#39;  = &#39;,num2str(nstates+i)));
        eval(strcat(&#39;rm_tl&#39;,num2str(i),&#39;  = &#39;,num2str(nstates+i)));
    end
end</code></pre><p>Julia&#39;s faster evaluation of such statements reduces this performance hit, as these symbols can be associated with the model object.</p><pre><code class="language-julia">[symbol(&quot;rm_tl$i&quot;) for i = 1:n_anticipated_shocks(m)]
# ...
[symbol(&quot;rm_shl$i&quot;) for i = 1:n_anticipated_shocks(m)]</code></pre><p>Granted, there may be better solutions to our problem in both languages, but similar situations involving code generation are easily addressed in Julia.</p><p>We have found that a number of Julia features make working with <em>DSGE.jl</em> simply more pleasant and user-friendly than working with our old codebase. Julia&#39;s clearly integrated testing infrastructure has made our development workflow significantly more robust. Unicode support means that code can correspond more closely to actual model equations, reducing the headache associated with translating from &quot;math&quot; to &quot;code&quot;.  (Inline <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> documentation helps in a similar way.) Operator overloading and user-defined syntax make it easy to be much more expressive with our code.</p><pre><code class="language-julia">julia&gt; m[:α]                         # Access value of param α from model m
julia&gt; m &lt;= parameter(:ϵ_p, 10.000)  # Add parameter ϵ_p to model
julia&gt; Γ0, Γ1, C, Ψ, Π  = eqcond(m)  # Get equilibrium conditions</code></pre><p>We have found that Julia&#39;s highly integrated, Git-based package manager is an improvement over MATLAB&#39;s decentralized <a href="http://www.mathworks.com/matlabcentral/fileexchange/">FileExchange</a>. As Julia users, we can now pull in high-quality, fully tested, community-supported external packages that can each be installed or updated with a single command.</p><pre><code class="language-julia">julia&gt; Pkg.add(&quot;QuantEcon&quot;)          # That&#39;s it!</code></pre><p>This reduces the need for users to create their own, likely lower-quality functionality, increasing developer <em>and</em> code performance. (Or the need to fight for the toolbox licenses available to their department.)</p><p>We acknowledge that our package is far from perfect. Possible improvements to <em>DSGE.jl</em> are many and varied. We may experiment with alternative, modern, numerical routines to improve speed. Ultimately, powerful metaprogramming support would allow user to specify model equations more literally, in mathematical notation. We <a href="../contributing/#contributing-1">welcome</a> improvements to the existing code from the community.</p><h2><a class="nav-anchor" id="Challenges-1" href="#Challenges-1">Challenges</a></h2><p>Converting the FRBNY DSGE model from MATLAB, a mature and well-supported language, to an extremely young language like Julia involved no shortage of challenges. Significant changes to the Julia language itself are introduced in rapid succession, and using <em>DSGE.jl</em> with a new Julia version inevitably floods the user’s screen with deprecation warnings. There is significant difficulty in finding written resources on the language beyond the Julia Manual itself. Google searches frequently return discussions in GitHub <em>Issues</em>, which are unhelpful to elementary users and can be actively misleading at times.</p><p>Differences between the behavior of MATLAB and Julia’s core linear algebra libraries led to many roadblocks in the development of <em>DSGE.jl</em>. Julia uses multithreaded BLAS functions for some linear algebra functions.  Using a different number of threads can change the results of matrix decomposition when the matrix is singular. This indeterminacy caused significant problems for our testing suite, both in comparing output matrices to MATLAB results and in testing for reproducibility among Julia outputs.</p><p>We ran into similar numerical problems while porting the model solution algorithm, <code>gensys</code>. At one point, the generalized Schur (QZ) decomposition is computed, yielding the decompositions <code>A=QSZ&#39;</code> and <code>B=QTZ&#39;</code>. In MATLAB, upper triangular matrices <code>S</code> and <code>T</code> are returned. In Julia, meanwhile, the default behavior is to return a real decomposition with upper Hessenberg (blocked diagonal) matrices <code>S</code> and <code>T</code>. Differing behaviors like this in the two languages might expose a user without deep knowledge of the procedure to errors.</p><p>Finally, dealing with a recently introduced language can make it more difficult for new users to produce performant code.  A typical economist, especially one coming from a MATLAB background, may be unfamiliar with the nature and use of language concepts like type stability, parametric types, and preallocation. Julia&#39;s profiler and debugger lack the flexibility of those in MATLAB, and can make it difficult to identify the source of errors or performance bottlenecks. And Julia IDEs, like <a href="http://junolab.org/">Juno</a>, while admirable, are not as mature or featured as the MATLAB IDE.</p><p>It is important to note again that similar improvements could have been made to our MATLAB code directly. (As we would be the first ones to admit.) Regardless, the Julia paradigm results in code that is high-quality from the outset.</p><h2><a class="nav-anchor" id="Conclusion-1" href="#Conclusion-1">Conclusion</a></h2><p>After months of hard work, we are pleased to be able to increase the performance of our model and provide our project for the benefit of the community. For those considering similar projects, we find the benefits of a transition to Julia are significant. One should, however, be realistic about the challenges that will be faced transitioning to a young language.</p><h2><a class="nav-anchor" id="Disclaimer-1" href="#Disclaimer-1">Disclaimer</a></h2><p>This post reflects the experience of the authors with Julia and MATLAB and does not represent an endorsement by the Federal Reserve Bank of New York or the Federal Reserve System of any particular product or service. The views expressed in this post are those of the authors and do not necessarily reflect the position of the Federal Reserve Bank of New York or the Federal Reserve System. Any errors or omissions are the responsibility of the authors.</p><footer><hr/><a class="previous" href="../contributing/"><span class="direction">Previous</span><span class="title">Contributing to DSGE.jl</span></a><a class="next" href="../julia_forecasting/"><span class="direction">Next</span><span class="title">MATLAB to Julia Transition: Forecast</span></a></footer></article></body></html>
