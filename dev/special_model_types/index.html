<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Special Model Types · DSGE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DSGE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DSGE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../model_design/">Model Design</a></li><li class="is-active"><a class="tocitem" href>Special Model Types</a><ul class="internal"><li><a class="tocitem" href="#The-PoolModel-Type-1"><span>The <code>PoolModel</code> Type</span></a></li><li><a class="tocitem" href="#DSGE-VARs-and-the-DSGEVAR-Type-1"><span>DSGE-VARs and the <code>DSGEVAR</code> Type</span></a></li><li><a class="tocitem" href="#DSGE-VECMs-and-the-DSGEVECM-Type-1"><span>DSGE-VECMs and the <code>DSGEVECM</code> Type</span></a></li><li><a class="tocitem" href="#Auxiliary-Methods-for-DSGE-VARs-and-DSGE-VECMs-1"><span>Auxiliary Methods for DSGE-VARs and DSGE-VECMs</span></a></li></ul></li><li><a class="tocitem" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="tocitem" href="../input_data/">Input Data</a></li><li><a class="tocitem" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="tocitem" href="../implementation_details/">Implementation Details</a></li><li><a class="tocitem" href="../solving/">Solving the Model</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../forecast/">Forecasting</a></li><li><a class="tocitem" href="../irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../means_bands/">Computing Means and Bands</a></li><li><a class="tocitem" href="../altpolicy/">Alternative Policies</a></li><li><a class="tocitem" href="../scenarios/">Alternative Scenarios</a></li><li><a class="tocitem" href="../forecast_decomposition/">Forecast Decomposition</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="tocitem" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="tocitem" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Special Model Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Special Model Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/docs/src/special_model_types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Special-Model-Types-1"><a class="docs-heading-anchor" href="#Special-Model-Types-1">Special Model Types</a><a class="docs-heading-anchor-permalink" href="#Special-Model-Types-1" title="Permalink"></a></h1><p>In addition to the <code>AbstractDSGEModel</code> type, DSGE.jl has several special types that implement models which are designed to interface with DSGEs.</p><h2 id="The-PoolModel-Type-1"><a class="docs-heading-anchor" href="#The-PoolModel-Type-1">The <code>PoolModel</code> Type</a><a class="docs-heading-anchor-permalink" href="#The-PoolModel-Type-1" title="Permalink"></a></h2><p>Unlike the other models contained in DSGE, the <code>PoolModel</code> type is not a proper DSGE model. It is a wrapper object for different methods to perform model averaging for two different models, which do not have to be DSGE models. For example, a user could average two different vector auto-regressions. Generally, a user only needs to provide the predictive density scores of the two models that the user wants to average. The reason is that we treat the predictive density scores as non-FRED observables. This approach makes interfacing with the rest of the machinery provided by DSGE.jl very simple.</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.PoolModel" href="#DSGE.PoolModel"><code>DSGE.PoolModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PoolModel{T}</code></pre><p>Implements several model averaging methods to pool the predictions of different models. Currently, <code>PoolModel</code> only works for pooling two different models, although it can be extended to more models. Confer with the paper for details.</p><p>The available methods are</p><ul><li><p>dynamic: weights on pooled models evolve over time and are          treated as a stochastic process.</p></li><li><p>static:  weights on pooled models are assumed time-invariant.</p></li><li><p>equal:   weights are set to 1/2.</p></li><li><p>bma:     weights are updated according to Bayesian model averaging.</p></li></ul><p>The default method is dynamic, which implements the Dynamic Pools method developed by Del Negro et al. (2016). To choose another method, use the keyword <code>weight_type::Symbol</code>, e.g.</p><pre><code class="language-none">pm = PoolModel(weight_type = :static) # creates a static PoolModel</code></pre><p>The <code>weight_type</code> is stored as a setting, so users can retrieve at any point by using <code>get_setting</code>.</p><p><strong>Fields</strong></p><p><strong>Parameters</strong></p><ul><li><p><code>parameters::Vector{AbstractParameter}</code>: Vector of all time-invariant hyperparameters   for the chosen method of model averaging.</p></li><li><p><code>keys::OrderedDict{Symbol,Int}</code>: Maps human-readable names for predictive densities   of pooled models.</p></li></ul><p><strong>Inputs to Measurement and Equilibrium Condition Equations</strong></p><ul><li><code>model::OrderedDict{Symbol,AbstractDSGEModel}</code>: Maps name to its underlying model object.</li></ul><p><strong>Model Specifications and Settings</strong></p><ul><li><p><code>spec::String</code>: The model specification identifier, &quot;an_schorfheide&quot;, cached here for filepath computation.</p></li><li><p><code>subspec::String</code>: The model subspecification number, indicating that some parameters from the original model spec (&quot;ss0&quot;) are initialized differently. Cached here for filepath computation.</p></li><li><p><code>settings::Dict{Symbol,Setting}</code>: Settings/flags that affect computation without changing the economic or mathematical setup of the model.</p></li><li><p><code>test_settings::Dict{Symbol,Setting}</code>: Settings/flags for testing mode</p></li></ul><p><strong>Other Fields</strong></p><ul><li><p><code>rng::MersenneTwister</code>: Random number generator. Can be is seeded to ensure reproducibility in algorithms that involve randomness (such as Metropolis-Hastings).</p></li><li><p><code>testing::Bool</code>: Indicates whether the model is in testing mode. If <code>true</code>, settings from <code>m.test_settings</code> are used in place of those in <code>m.settings</code>.</p></li><li><p><code>observable_mappings::OrderedDict{Symbol,Observable}</code>: A dictionary that stores data sources, series mnemonics, and transformations to/from model units. DSGE.jl will fetch data from the Federal Reserve Bank of St. Louis&#39;s FRED database; all other data must be downloaded by the user. See <code>load_data</code> and <code>Observable</code> for further details.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/models/poolmodel/poolmodel.jl#L1-L75">source</a></section></article><p>See <a href="https://www.sciencedirect.com/science/article/pii/S0304407616300094#f000005">Del Negro et al. (2016)</a> for theoretical details on the model averaging methods listed in the documentation.</p><p>To facilitate analysis with the <code>PoolModel</code> type, we also provide the following functions.</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.estimate_bma" href="#DSGE.estimate_bma"><code>DSGE.estimate_bma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_bma(m, data, prior; return_output = false, filestring_addl = [])</code></pre><p>Estimate a Bayesian Model Average.</p><p><strong>Arguments:</strong></p><ul><li><code>m::PoolModel</code>: PoolModel object</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>data</code>: well-formed data as <code>Matrix</code> or <code>DataFrame</code>. If this is not provided, the <code>load_data</code> routine will be executed.</li><li><code>prior::Float64</code>: prior probability between the two models</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>return_output::Bool</code>: option to return output. If false, <code>nothing</code> is returned.</li><li><code>filestring_addl::Vector{String}</code>: Additional strings to append to output files.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/estimate/estimate_bma.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.sample_λ" href="#DSGE.sample_λ"><code>DSGE.sample_λ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_λ(m, pred_dens, θs, T = -1; parallel = true) where S&lt;:AbstractFloat
sample_λ(m, pred_dens, T = -1; parallel = true) where S&lt;:AbstractFloat</code></pre><p>Computes and samples from the conditional density p(λ<em>t|θ, I</em>t, P) for particle in <code>θs</code>, which represents the posterior distribution. The sampled λ particles represent the posterior distribution p(λ<em>{t|t} | I</em>t, P).</p><p>If no posterior distribution is passed in, then the function computes the distribution of λ_{t|t} for a static pool.</p><p><strong>Inputs</strong></p><ul><li><code>m::PoolModel{S}</code>: <code>PoolModel</code> object</li><li><code>pred_dens::Matrix{S}</code>: matrix of predictive densities</li><li><code>θs::Matrix{S}</code>: matrix of particles representing posterior distribution of θ</li><li><code>T::Int64</code>: final period for tempered particle filter</li></ul><p>where <code>S&lt;:AbstractFloat</code>.</p><p><strong>Keyword Argument</strong></p><ul><li><code>parallel::Bool</code>: use parallel computing to compute and sample draws of λ</li></ul><p><strong>Outputs</strong></p><ul><li><code>λ_sample::Vector{Float64}</code>: sample of draws of λs; together with (θ,λ) represents a joint density</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/analysis/moments.jl#L845-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.propagate_λ" href="#DSGE.propagate_λ"><code>DSGE.propagate_λ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propgate_λ(λvec, h, m, θvec) where T&lt;:AbstractFloat</code></pre><p>Propagates a λ particle h periods forward.</p><p><strong>Inputs</strong></p><ul><li><code>λ::T</code>: λ sample from (θ,λ) joint distribution</li><li><code>h::Int64</code>: forecast horizon</li><li><code>m::PoolModel</code>: PoolModel object</li><li><code>θvec::Vector{T}</code>: optional vector of parameters to update PoolModel</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/analysis/moments.jl#L1043-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.compute_Eλ" href="#DSGE.compute_Eλ"><code>DSGE.compute_Eλ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_Eλ(m, h, λvec, θmat = [], weights = [];
    current_period = true, parallel = true) where T&lt;:AbstractFloat</code></pre><p>Computes and samples from the conditional density p(λ<em>t|θ, I</em>t, P) for particle in <code>θs</code>, which represents the posterior distribution.</p><p><strong>Inputs</strong></p><ul><li><code>m::PoolModel{T}</code>: <code>PoolModel</code> object</li><li><code>h::Int64</code>: forecast horizon</li><li><code>λvec::Vector{T}</code>: vector of particles of λ samples from (θ,λ) joint distribution</li><li>`θmat::Matrix{T}&#39;: matrix of posterior parameter samples</li><li><code>weights::Vector{T}</code>: weights of λ particles, defaults to equal weights</li></ul><p><strong>Keyword Argument</strong></p><ul><li><code>current_period::Bool</code>: compute Eλ for current period t</li><li><code>parallel::Bool</code>: use parallel computing to compute and sample λ</li><li><code>get_dpp_pred_dens::Bool</code>: compute predictive densities according to dynamic prediction pools</li></ul><p><strong>Outputs</strong></p><ul><li><code>λhat_tplush::Float64</code>: E[λ<em>{t+h|t} | I</em>t^P, P]</li><li><code>λhat_t::Float64</code>: E[λ<em>{t|t} | I</em>t^P, P]</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/analysis/moments.jl#L961-L989">source</a></section></article><h2 id="DSGE-VARs-and-the-DSGEVAR-Type-1"><a class="docs-heading-anchor" href="#DSGE-VARs-and-the-DSGEVAR-Type-1">DSGE-VARs and the <code>DSGEVAR</code> Type</a><a class="docs-heading-anchor-permalink" href="#DSGE-VARs-and-the-DSGEVAR-Type-1" title="Permalink"></a></h2><p>We can approximate the dynamics of a linearized DSGE with a VAR(<span>$p$</span>), where <span>$p$</span> is the number of lags. This approximation gives a mapping from the parameters of a DSGE to the parameters of a VAR (the coefficients and innovations variance-covariance matrix). Since the number of parameters in a VAR are generally larger than the number of parameters in a DSGE, this mapping can be interpreted as cross-restrictions imposed by a DSGE on the parameters of a VAR. A DSGE-VAR combines a DSGE with a VAR to, among other reasons, evaluate the mis-specification of the DSGE and improve the DSGE&#39;s forecasting performance.</p><p>For more details on the theory and performance, see <a href="https://onlinelibrary.wiley.com/doi/full/10.1111/j.1468-2354.2004.00139.x">Del Negro and Schorfheide (2004)</a>, <a href="https://www.newyorkfed.org/medialibrary/media/research/economists/delnegro/erq206_delnegro.pdf">Del Negro and Schorfheide (2006)</a>, [Del Negro, Schorfheide, Smets, and Wouters (2007)][https://www.jstor.org/stable/27638915], and <a href="https://www.aeaweb.org/articles?id=10.1257/aer.99.4.1415">Del Negro and Schorfheide (2009)</a>.</p><p>We implement DSGE-VARs with the <code>DSGEVAR</code> concrete type so that it is easy to interface them with DSGE models. A <code>DSGEVAR</code> type holds information about the VAR with which we want to combine a given DSGE model and can be easily constructed, given a DSGE object. Once we have constructed a <code>DSGEVAR</code> object, then it is straightforward to estimate the object and compute impulse responses.</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.DSGEVAR" href="#DSGE.DSGEVAR"><code>DSGE.DSGEVAR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DSGEVAR{T} &lt;: AbstractDSGEVARModel{T}</code></pre><p>implements a simple interface for combining a given DSGE model with a VAR to create a DSGE-VAR. Confer with Del Negro and Schorfheide (2004), Del Negro and Schorfheide (2006), Del Negro, Schorfheide, Smets, and Wouters (2007), and/or Del Negro and Schorfheide (2009) for details about DSGE-VARs. We recommend the first two papers as initial introductions to DSGE-VARs.</p><p>The recommended constructor requires the user to provide (1) an <code>AbstractDSGEModel</code> object, (2) which structural shocks from the DSGE to use, and (3) the subspec (optional, defaults to &quot;ss0&quot;). If the subspec &quot;ss0&quot; is used, then the result is a <code>DSGEVAR</code> whose VAR component is &quot;empty&quot; in that the observables, lags, and λ weight are not specified. The reason why this constructor requires the user to specify which structural shocks of DSGE to use is that this information is DSGE-specific rather than information about the VAR.</p><p>However, we can also construct a <code>DSGEVAR</code> without having to specify the structural shocks when calling the constructor, although we still need to give an instance of an <code>AbstractDSGEModel</code>.</p><p><strong>Example</strong></p><p>The code below instantiates an empty <code>DSGEVAR</code> with <code>AnSchorfheide</code> as the underlying DSGE and then calls <code>update!</code> on the empty DSGE-VAR to add information about the desired DSGE-VAR spec.</p><pre><code class="language-julia">dsgevar = DSGEVAR(AnSchorfheide())
DSGE.update!(dsgevar, shocks = [:rm_sh, :z_sh, :g_sh],
    observables = [:obs_gdp, :obs_cpi, :obs_nominalrate],
    λ = 1., lags = 4)</code></pre><p><strong>Fields</strong></p><p><strong>DSGE object</strong></p><ul><li><code>dsge::AbstractDSGEModel{T}</code>: underlying DSGE model object</li></ul><p><strong>DSGE-VAR Information</strong></p><ul><li><code>observables::OrderedDict{Symbol,Int}</code>: dictionary mapping observables   of the VAR to their index in the matrices representing the DSGE-VAR</li><li><code>shocks::OrderedDict{Symbol,Int}</code>: dictionary mapping structural   shocks in the DSGE to their index in the matrices representing the DSGE-VAR</li><li><code>lags::Int</code>: number of lags in the VAR</li><li><code>λ::T</code>: weight on the DSGE prior</li></ul><p><strong>Auxiliary Information</strong></p><ul><li><code>spec::String</code>: concatenates <code>dsgevar</code> with the spec of the DSGE, e.g.   for <code>AnSchorfheide</code>, we have <code>dsgevar_an_schorfheide</code>.</li><li><code>subspec::String</code>: specifies the model subspecification.   Cached here for filepath computation.</li><li><code>testing::Bool</code>: indicates whether the model is in testing mode.   Currently, this setting has no uses in practice</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/models/var/dsgevar/dsgevar.jl#L1-L66">source</a></section></article><h3 id="tips-dsgevar-1"><a class="docs-heading-anchor" href="#tips-dsgevar-1">Tips for Using <code>DSGEVAR</code></a><a class="docs-heading-anchor-permalink" href="#tips-dsgevar-1" title="Permalink"></a></h3><ul><li><p>When extensively using DSGE-VARs, we recommend defining your own subspecs in <code>subspecs.jl</code> because it simplifies the process of saving, reading, and analyzing output from estimating and calculating impulse responses for DSGE-VARs. See <a href="../advanced_usage/#advanced-usage-1">Advanced Usage</a> for a more detailed explanation on changing subspecs.</p></li><li><p>The names of the observables must exist as either observables or pseudo-observables in the DSGE because for most <code>DSGEVAR</code> methods, we need to construct the state space representation of the <code>DSGEVAR</code> using information from the underlying DSGE.</p></li><li><p>It is important to be careful about the order of the observables when constructing a <code>DSGEVAR</code>. Whether you define the names of the observables by calling <code>update!</code> or by creating a subspec, we assume that the order of the observables corresponds to the observable&#39;s index in the data and in the state space representation of the <code>DSGEVAR</code>. In the example provided above, if we estimate the <code>DSGEVAR</code> on data or construct the state space representation of the <code>DSGEVAR</code>, we assume that the order of observables in the data array, which has dimensions <code>nobs x nperiods</code>, is <code>:obs_gdp</code> in the first row, <code>:obs_cpi</code> in the second row, and <code>:obs_nominalrate</code> in the third row.</p></li><li><p>When using functions that use the DSGE as a prior for a VAR (as opposed to a VAR approximation of the DSGE), then an intercept term is assumed and cannot be turned off. For example, the following two functions computes the VAR coefficients and innovations variance-covariance matrix for a <code>DSGEVAR</code> object <code>m</code>. The first one is for a VAR approximation of the DSGE in <code>m</code>, and it allows the user to specify whether or not they want an intercept term using the keyword <code>use_intercept</code>. The second function is for using the DSGE as a prior for a VAR estimated on <code>data</code>. This function does not have the <code>use_intercept</code> keyword because we require an intercept term when using the DSGE as a prior for a VAR.</p></li></ul><h2 id="DSGE-VECMs-and-the-DSGEVECM-Type-1"><a class="docs-heading-anchor" href="#DSGE-VECMs-and-the-DSGEVECM-Type-1">DSGE-VECMs and the <code>DSGEVECM</code> Type</a><a class="docs-heading-anchor-permalink" href="#DSGE-VECMs-and-the-DSGEVECM-Type-1" title="Permalink"></a></h2><p>We can extend DSGE-VARs to permit cointegrating relationships between observables using DSGE-VECMs. A VECM is a <a href="https://en.wikipedia.org/wiki/Error_correction_model">vector error-correction model</a>, which extend VARs to account for long-run stochastic trends, i.e. cointegration..</p><p>For more details on the theory and performance, see <a href="https://onlinelibrary.wiley.com/doi/full/10.1111/j.1468-2354.2004.00139.x">Del Negro and Schorfheide (2004)</a>, <a href="https://www.newyorkfed.org/medialibrary/media/research/economists/delnegro/erq206_delnegro.pdf">Del Negro and Schorfheide (2006)</a>, and [Del Negro, Schorfheide, Smets, and Wouters (2007)][https://www.jstor.org/stable/27638915].</p><p>We implement DSGE-VECMs with the <code>DSGEVECM</code> concrete type so that it is easy to interface them with DSGE models. The <code>DSGEVECM</code> has very similar behavior to the <code>DSGEVAR</code> type, with extensions as needed. For example, the <code>DSGEVECM</code> type includes additional fields to hold information about cointegrating relationships.</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.DSGEVECM" href="#DSGE.DSGEVECM"><code>DSGE.DSGEVECM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DSGEVECM{T} &lt;: AbstractDSGEVECMModel{T}</code></pre><p>implements a simple interface for combining a given DSGE model with a VECM (a VAR with cointegrating terms) to create a DSGE-VECM. Confer with Del Negro and Schorfheide (2006) and/or Del Negro, Schorfheide, Smets, and Wouters (2007) for details about DSGE-VECMs. We recommend the first paper as an initial introduction to DSGE-VECMs.</p><p>The recommended constructor requires the user to provide (1) an <code>AbstractDSGEModel</code> object, (2) which structural shocks from the DSGE to use, and (3) the subspec (optional, defaults to &quot;ss0&quot;). If the subspec &quot;ss0&quot; is used, then the result is a <code>DSGEVECM</code> whose VECM component is &quot;empty&quot; in that the observables, cointegrating relationships, lags, and λ weight are not specified. The reason why this constructor requires the user to specify which structural shocks of DSGE to use is that this information is DSGE-specific rather than information about the VECM.</p><p>However, we can also construct a <code>DSGEVECM</code> without having to specify the structural shocks when calling the constructor, although we still need to give an instance of an <code>AbstractDSGEModel</code>.</p><p><strong>Example</strong></p><p>The code below instantiates an empty <code>DSGEVECM</code> with <code>AnSchorfheide</code> as the underlying DSGE and then calls <code>update!</code> on the empty DSGE-VECM to add information about the desired DSGE-VECM spec.</p><pre><code class="language-julia">dsgevecm = DSGEVECM(AnSchorfheide())
DSGE.update!(dsgevecm, shocks = [:rm_sh, :z_sh, :g_sh],
    observables = [:obs_gdp, :obs_cpi, :obs_nominalrate],
    λ = 1., lags = 4)</code></pre><p><strong>Fields</strong></p><p><strong>DSGE object</strong></p><ul><li><code>dsge::AbstractDSGEModel{T}</code>: underlying DSGE model object</li></ul><p><strong>DSGE-VECM Information</strong></p><ul><li><code>observables::OrderedDict{Symbol,Int}</code>: dictionary mapping observables   of the VECM to their index in the matrices representing the DSGE-VECM.</li><li><code>cointegrating::OrderedDict{Symbol,Int}</code>: dictionary mapping cointegrating relationships   of the VECM to their index in the matrices representing the DSGE-VECM.   When creating the state space representation of a DSGE-VECM, the   cointegrating relationships will come after the observables. Accordingly,   the first <code>cointegrating</code> index will be after the last observable.</li><li><code>cointegrating_add::OrderedDict{Symbol,Int}</code>: dictionary mapping   additional cointegrating relationships of the VECM to their index   in the matrices representing the DSGE-VECM. These relationships are   intended to be ones that only add to the <code>DD</code> matrix in DSGE.jl&#39;s   representation of a state space model. Importantly, these relationships   do not require changing the <code>ZZ</code> matrix. As a result, the indices for   these relationships start at 1.</li><li><code>shocks::OrderedDict{Symbol,Int}</code>: dictionary mapping structural   shocks in the DSGE to their index in the matrices representing the DSGE-VECM</li><li><code>lags::Int</code>: number of lags in the VECM</li><li><code>λ::T</code>: weight on the DSGE prior</li></ul><p><strong>Auxiliary Information</strong></p><ul><li><code>spec::String</code>: concatenates <code>dsgevar</code> with the spec of the DSGE, e.g.   for <code>AnSchorfheide</code>, we have <code>dsgevar_an_schorfheide</code>.</li><li><code>subspec::String</code>: specifies the model subspecification.   Cached here for filepath computation.</li><li><code>testing::Bool</code>: indicates whether the model is in testing mode.   Currently, this setting has no uses in practice</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/models/var/dsgevecm/dsgevecm.jl#L1-L78">source</a></section></article><h3 id="Tips-for-Using-DSGEVECM-1"><a class="docs-heading-anchor" href="#Tips-for-Using-DSGEVECM-1">Tips for Using <code>DSGEVECM</code></a><a class="docs-heading-anchor-permalink" href="#Tips-for-Using-DSGEVECM-1" title="Permalink"></a></h3><ul><li><p>The same <a href="#tips-dsgevar-1">tips for <code>DSGEVAR</code> models</a> generally apply for <code>DSGEVECM</code> models.</p></li><li><p>The names of cointegrating relationships in the field <code>cointegrating</code> must exist as either observables or pseudo-observables in the DSGE. The reason is the same as the reason for why observables must be held.</p></li><li><p>In the state space representation of the underlying DSGE corresponding to a <code>DSGE-VECM</code>, cointegrating relationships are ordered after observables. For example, consider the measurement matrix <code>ZZ</code>. The first <code>n_observables</code> rows correspond to the <code>observables</code> in <code>DSGE-VECM</code>, and the next <code>n_observables + 1:n_cointegrating + n_observables</code> rows correspond to <code>cointegrating</code> in <code>DSGE-VECM</code>.</p></li><li><p>When calculating the <code>VECM</code> coefficients of a DSGE-VECM, the coefficients are ordered with cointegrating relationships first, followed by the intercept term, and concluding with lags of past differences. See the docstring of <code>vecm_approx_state_space</code>.</p></li><li><p>Some cointegrating relationships do not need to be added to the measurement matrix in the state space representation of a DSGE model. These relationships are considered &quot;additional&quot; ones and are added to the field <code>cointegrating_add</code>. To compute the constant vector which specify these additional relationships, we use <code>compute_DD_coint_add</code>. See its docstring for notes on usage.</p></li></ul><h2 id="Auxiliary-Methods-for-DSGE-VARs-and-DSGE-VECMs-1"><a class="docs-heading-anchor" href="#Auxiliary-Methods-for-DSGE-VARs-and-DSGE-VECMs-1">Auxiliary Methods for DSGE-VARs and DSGE-VECMs</a><a class="docs-heading-anchor-permalink" href="#Auxiliary-Methods-for-DSGE-VARs-and-DSGE-VECMs-1" title="Permalink"></a></h2><p>Listed below are some methods used internally in but not exported by DSGE.jl that users may also find useful. We also recommend looking at the various utility functions in <code>abstractvarmodel.jl</code>. Many of these functions are wrappers for similarly named functions defined on <code>AbstractDSGEModel</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.draw_VECM-Union{Tuple{S}, Tuple{Array{S,2},Array{S,2},Array{S,2},Int64,Int64,Int64,Int64}} where S&lt;:Real" href="#DSGE.draw_VECM-Union{Tuple{S}, Tuple{Array{S,2},Array{S,2},Array{S,2},Int64,Int64,Int64,Int64}} where S&lt;:Real"><code>DSGE.draw_VECM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">draw_VECM(YYYYC, XXYYC, XXXXC, T̄, n_obs, lags, n_coint; standard_orientation = true)</code></pre><p>draws β and Σ from the distribution p(β, Σ | Y, θ) implied by the population moments (or covariances) YYYYC, XXYYC, and XXXXC for a VECM with parameters θ.</p><p>For example, if these population moments are generated by a DSGE-VECM, then θ are the structural parameters of the DSGE and the weight λ placed on the cross-restrictions implied by the DSGE. The population moments would represent the moments of the sample data and dummy observables generated to implement the DSGE prior.</p><p>Given these moments, we compute the maximum-likelihood estimates of β and Σ using OLS. Denote these estimates by Β and S. Then we generate draws from p(β, Σ | Y, θ) using the fact that</p><pre><code class="language-none">Σ | Y, θ ∼ ℐ𝒲 (T̄ × S, T̄ - (1 + lags * n_obs), n_obs),
β | Y, Σ,θ ∼ 𝒩 (B, Σ ⊗ XXXXC⁻¹).</code></pre><p><strong>Inputs</strong></p><ul><li><code>YYYYC::Matrix{&lt;:Real}</code>: covariance of observables</li><li><code>XXYYC::Matrix{&lt;:Real}</code>: covariance of observables with their lags</li><li><code>XXXXC::Matrix{&lt;:Real}</code>: covariance of the lags of the observables</li><li><code>T̄::Int</code>: total number of time periods of observations, including sample observables   from actual data and any dummy observables generated to implement priors.</li><li><code>n_obs::Int</code>: number of distinct observables</li><li><code>lags::Int</code>: number of lags in the VECM</li><li><code>n_coint::Int</code>: number of distinct cointegrating relationships</li></ul><p><strong>Keywords</strong></p><ul><li><code>standard_orientation::Bool</code>: if true, the draw of <code>β</code> has   dimensions <code>(n_obs * lags) x n_obs</code>. Otherwise, it has the transposed dimensions.</li><li>All other keywords are used for testing purposes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/models/var/util.jl#L166-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.draw_stationary_VAR-Union{Tuple{S}, Tuple{Array{S,2},Array{S,2},Array{S,2},Int64,Int64,Int64}} where S&lt;:Real" href="#DSGE.draw_stationary_VAR-Union{Tuple{S}, Tuple{Array{S,2},Array{S,2},Array{S,2},Int64,Int64,Int64}} where S&lt;:Real"><code>DSGE.draw_stationary_VAR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">draw_stationary_VAR(YYYYC, XXYYC, XXXXC, T̄, n_obs, lags; standard_orientation = true)
draw_stationary_VAR(YYYYC, XXYYC, XXXXC, T̄; standard_orientation = true)</code></pre><p>draws β and Σ from the distribution p(β, Σ | Y, θ) implied by the population moments (or covariances) YYYYC, XXYYC, and XXXXC for a VAR with parameters θ.</p><p>For example, if these population moments are generated by a DSGE-VAR, then θ are the structural parameters of the DSGE and the weight λ placed on the cross-restrictions implied by the DSGE. The population moments would represent the moments of the sample data and dummy observables generated to implement the DSGE prior.</p><p>Given these moments, we compute the maximum-likelihood estimates of β and Σ using OLS. Denote these estimates by Β and S. Then we generate draws from p(β, Σ | Y, θ) using the fact that</p><pre><code class="language-none">Σ | Y, θ ∼ ℐ𝒲 (T̄ × S, T̄ - (1 + lags * n_obs), n_obs),
β | Y, Σ,θ ∼ 𝒩 (B, Σ ⊗ XXXXC⁻¹).</code></pre><p>Finally, we check that these draws generate a stationary state space system. If they do not, then we keep drawing until we obtain a pair of draws (β, Σ) that are stationary.</p><p><strong>Inputs</strong></p><ul><li><code>YYYYC::Matrix{&lt;:Real}</code>: covariance of observables</li><li><code>XXYYC::Matrix{&lt;:Real}</code>: covariance of observables with their lags</li><li><code>XXXXC::Matrix{&lt;:Real}</code>: covariance of the lags of the observables</li><li><code>T̄::Int</code>: total number of time periods of observations, including sample observables   from actual data and any dummy observables generated to implement priors.</li><li><code>n_obs::Int</code>: number of distinct observables</li><li><code>lags::Int</code>: number of lags in the VAR</li></ul><p><strong>Keywords</strong></p><ul><li><code>standard_orientation::Bool</code>: if true, the draw of <code>β</code> has   dimensions <code>(n_obs * lags) x n_obs</code>. Otherwise, it has the transposed dimensions.</li><li>All other keywords are used for testing purposes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/models/var/util.jl#L57-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.var_approx_state_space" href="#DSGE.var_approx_state_space"><code>DSGE.var_approx_state_space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">var_approx_state_space(TTT, RRR, QQQ, DD, ZZ, EE, MM, p; get_population_moments = false,
use_intercept = false) where {S&lt;:Real}</code></pre><p>computes the VAR(p) approximation of the linear state space system</p><pre><code class="language-none">sₜ = TTT * sₜ₋₁ + RRR * ϵₜ,
yₜ = ZZ * sₜ + DD + uₜ,</code></pre><p>where the disturbances are assumed to follow</p><pre><code class="language-none">ϵₜ ∼ 𝒩 (0, QQ),
uₜ = ηₜ + MM * ϵₜ,
ηₜ ∼ 𝒩 (0, EE).</code></pre><p>The <code>MM</code> matrix implies</p><pre><code class="language-none">cov(ϵₜ, uₜ) = QQ * MM&#39;.</code></pre><p><strong>Outputs</strong></p><p>If <code>get_population_moments = false</code>:</p><ul><li><code>β</code>: VAR(p) coefficients</li><li><code>Σ</code>: innovations variance-covariance matrix for the VAR(p) representation</li></ul><pre><code class="language-none">yₜ = Xₜβ + μₜ</code></pre><p>where <code>Xₜ</code> appropriately stacks the constants and <code>p</code> lags of <code>yₜ</code>, and <code>μₜ ∼ 𝒩 (0, Σ)</code>.</p><p>If <code>get_population_moments = true</code>: we return the limit cross product matrices.</p><ul><li><code>yyyyd</code>: 𝔼[y,y]</li><li><code>XXXXd</code>: 𝔼[y,X(lag rr)]</li><li><code>XXyyd</code>: 𝔼[X(lag rr),X(lag ll)]</li></ul><p>Using these matrices, the VAR(p) representation is given by</p><pre><code class="language-none">β = XXXXd \ XXyyd
Σ = yyyyd - XXyyd&#39; * β</code></pre><p>The keyword <code>use_intercept</code> specifies whether or not to use an intercept term in the VAR approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/statespace_functions.jl#L904-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.vecm_approx_state_space" href="#DSGE.vecm_approx_state_space"><code>DSGE.vecm_approx_state_space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vecm_approx_state_space(TTT, RRR, QQQ, DD, ZZ, EE, MM, n_obs, p, n_coint,
n_coint, n_coint_add, DD_coint_add; get_population_moments = false,
use_intercept = false) where {S&lt;:Real}</code></pre><p>computes the VECM(p) approximation of the linear state space system</p><pre><code class="language-none">sₜ = TTT * sₜ₋₁ + RRR * ϵₜ,
yₜ = ZZ * sₜ + DD + uₜ,</code></pre><p>where the disturbances are assumed to follow</p><pre><code class="language-none">ϵₜ ∼ 𝒩 (0, QQ),
uₜ = ηₜ + MM * ϵₜ,
ηₜ ∼ 𝒩 (0, EE).</code></pre><p>The <code>MM</code> matrix implies</p><pre><code class="language-none">cov(ϵₜ, uₜ) = QQ * MM&#39;.</code></pre><p><strong>Outputs</strong></p><p>If <code>get_population_moments = false</code>:</p><ul><li><code>β</code>: VECM(p) coefficients. The first <code>n_coint + n_coint_add</code></li></ul><p>coefficients for each observable comprise the error correction terms, while the following <code>1 + p * n_obs</code> terms are the VAR terms.</p><ul><li><code>Σ</code>: innovations variance-covariance matrix for the VECM(p) representation</li></ul><pre><code class="language-none">Δyₜ = eₜβₑ + Xₜβᵥ + μₜ</code></pre><p>where <code>βₑ</code> are the coefficients for the error correction terms; <code>eₜ</code> are the error correction terms specifying the cointegrating relationships; <code>βᵥ</code> are the coefficients for the VAR terms; <code>Xₜ</code> appropriately stacks the constants and <code>p</code> lags of <code>Δyₜ</code>; and <code>μₜ ∼ 𝒩 (0, Σ)</code>.</p><p>Note that the error correction terms satisfy the mapping <code>eₜ&#39; = C * yₜ₋₁</code>, where <code>C</code> is a matrix.</p><p>If <code>get_population_moments = true</code>: we return the limit cross product matrices.</p><ul><li><code>yyyyd</code>: 𝔼[y,y]</li><li><code>XXXXd</code>: 𝔼[y,X(lag rr)]</li><li><code>XXyyd</code>: 𝔼[X(lag rr),X(lag ll)]</li></ul><p>Note that in the rows of <code>XXyyd</code> and the rows and columns of <code>XXXXd</code>, the cointegrating relationships are stacked above the constants and lagged <code>Δyₜ</code>.</p><p>Using these matrices, the VAR(p) representation is given by</p><pre><code class="language-none">β = XXXXd \ XXyyd
Σ = yyyyd - XXyyd&#39; * β,</code></pre><p>where <code>β</code> has dimensions <code>n_obs × (n_coint + n_coint_add + 1 + p * n_obs)</code>, and <code>Σ</code> has dimensions <code>n_obs × n_obs</code>.</p><p>The keyword <code>use_intercept</code> specifies whether or not to use an intercept term in the VECM approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/statespace_functions.jl#L1021-L1080">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.compute_DD_coint_add" href="#DSGE.compute_DD_coint_add"><code>DSGE.compute_DD_coint_add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function compute_DD_coint_add(m::AbstractDSGEVECMModel{S}, system::System,
cointegrating_add::Vector{Symbol}) where {S &lt;: Real}</code></pre><p>computes <code>DD_coint_add</code> for a <code>DSGEVECM</code> model. This vector holds additional cointegrating relationships that do not require changes to the <code>ZZ</code> matrix.</p><p><strong>Note</strong></p><p>We recommend overloading this function if there are cointegrating relationships which a user does not want to add to the underlying DSGE. The function <code>compute_system</code> first checks for a method <code>compute_DD_coint_add</code> that takes a Type tuple of <code>(model_type, Vector{Symbol})</code> and then <code>(model_type, )</code> before calling this method.</p><p>This function is generally intended to be internal. As an example of other such functions, <code>eqcond</code> must be user-defined but is primarily used internally and not directly called by the user in a script.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/statespace_functions.jl#L800-L820">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>measurement_error</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DSGE.dsgevar_likelihood" href="#DSGE.dsgevar_likelihood"><code>DSGE.dsgevar_likelihood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dsgevar_likelihood(YYYY::Matrix{S}, XXYY::Matrix{S},
    XXXX::Matrix{S}, YYYYD::Matrix{S}, XXYYD::Matrix{S},
    XXXXD::Matrix{S}, T::Int, λ::S,
    lags::Int, n_obs::Int) where {S&lt;:Real}</code></pre><p>evaluates the likelihood of a DSGE-VAR given the population moments of the raw data (<code>YYYY</code>, <code>XXYY</code>, <code>XXXX</code>) and the population moments implied by the DSGE prior (<code>YYYYD</code>, <code>XXYYD</code>, <code>XXXXD</code>).</p><p><strong>Other Inputs</strong></p><ul><li><code>T</code>: number of time periods in data</li><li><code>λ</code>: weight placed on the DSGE prior</li><li><code>lags</code>: number of lags in the VAR</li><li><code>n_obs</code>: number of observables (e.g. number of time series).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/estimate/var/dsgevar_likelihood.jl#L47-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.dsgevecm_likelihood" href="#DSGE.dsgevecm_likelihood"><code>DSGE.dsgevecm_likelihood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dsgevecm_likelihood(m::AbstractDSGEVECMModel{S}, data::Matrix{S};
    apply_altpolicy::Bool = false) where {S&lt;:Real}</code></pre><p>evaluates the likelihood of a DSGE-VECM. It is assumed that <code>get_λ(m)</code> retrieves the prior weight <code>λ</code> on the DSGE.</p><p>The matrix <code>data</code> is assumed an nobs x T+lags matrix, where the lags indicate we cut off the data for presampling.</p><p>In the future, this function may be combined with <code>dsgevar_likelihood</code> because the two functions are almost exactly the same. We currently have them implemented separately so that the naming convention does not create any confusion. One can think of DSGE-VECMs as DSGE-VARs with an additional regressor that corrects for errors to account for cointegration, hence it would not be &quot;wrong&quot; per se to add a couple <code>if-else</code> conditions inside <code>dsgevar_likelihood</code> and let this function cover both DSGE-VARs and DSGE-VECMS. But the current decision to have separate functions makes it clear that the <code>dsgevar_likelihood</code> specifically operates on DSGE-VARs without an error correction term, and <code>dsgevecm_likelihood</code> operates on DSGE-VECMs specifically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/estimate/var/dsgevecm_likelihood.jl#L1-L24">source</a></section><section><div><pre><code class="language-none">dsgevecm_likelihood(YYYY::Matrix{S}, XXYY::Matrix{S},
    XXXX::Matrix{S}, YYYYD::Matrix{S}, XXYYD::Matrix{S},
    XXXXD::Matrix{S}, T::Int, λ::S,
    lags::Int, n_obs::Int,
    coint_inds::Union{Vector{Int}, UnitRange{Int}}) where {S&lt;:Real}</code></pre><p>evaluates the likelihood of a DSGE-VECM given the population moments of the raw data (<code>YYYY</code>, <code>XXYY</code>, <code>XXXX</code>) and the population moments implied by the DSGE prior (<code>YYYYD</code>, <code>XXYYD</code>, <code>XXXXD</code>).</p><p><strong>Other Inputs</strong></p><ul><li><code>T</code>: number of time periods in data</li><li><code>λ</code>: weight placed on the DSGE prior</li><li><code>lags</code>: number of lags in the VECM</li><li><code>n_obs</code>: number of observables (e.g. number of time series).</li><li><code>coint_inds</code>: indices of the cointegrated observables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/6c42284c3b49a50434c15279f54a11aa8cd49cf8/src/estimate/var/dsgevecm_likelihood.jl#L63-L81">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model_design/">« Model Design</a><a class="docs-footer-nextpage" href="../running_existing_model/">Running An Existing Model »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 26 January 2021 22:34">Tuesday 26 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
