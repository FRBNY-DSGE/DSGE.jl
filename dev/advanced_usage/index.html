<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Usage · DSGE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DSGE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DSGE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../learning_how_to_use_dsgejl/">Learning How to Use DSGE.jl</a></li><li><a class="tocitem" href="../model_design/">Model Design</a></li><li><a class="tocitem" href="../special_model_types/">Special Model Types</a></li><li><a class="tocitem" href="../model_implementation_details/">Model Implementation Details</a></li><li><a class="tocitem" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="tocitem" href="../input_data/">Input Data</a></li><li><a class="tocitem" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="tocitem" href="../solving/">Solving the Model</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../forecast/">Forecasting</a></li><li><a class="tocitem" href="../irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../means_bands/">Computing Means and Bands</a></li><li><a class="tocitem" href="../altpolicy/">Alternative Policies</a></li><li><a class="tocitem" href="../scenarios/">Alternative Scenarios</a></li><li><a class="tocitem" href="../forecast_decomposition/">Forecast Decomposition</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li class="is-active"><a class="tocitem" href>Advanced Usage</a><ul class="internal"><li><a class="tocitem" href="#Package-Directory-Structure-1"><span>Package Directory Structure</span></a></li><li><a class="tocitem" href="#working-with-settings-1"><span>Working with Settings</span></a></li><li><a class="tocitem" href="#accel-regime-switch-statespace-comp-1"><span>Accelerating Computation of Regime-Switching System</span></a></li><li><a class="tocitem" href="#regime-switch-forecast-1"><span>Regime-Switching Forecasts</span></a></li><li><a class="tocitem" href="#uncertainaltpol-1"><span>Alternative Policy Uncertainty and Imperfect Awareness</span></a></li><li><a class="tocitem" href="#Automatically-Generating-Anticipated-Shocks-1"><span>Automatically Generating Anticipated Shocks</span></a></li><li><a class="tocitem" href="#auto-endo-zlb-1"><span>Automatic Endogenous ZLB Enforcement as Temporary Rule</span></a></li><li><a class="tocitem" href="#editing-extending-model-1"><span>Editing or Extending a Model</span></a></li><li><a class="tocitem" href="#Additional-Tips-1"><span>Additional Tips</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="tocitem" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="tocitem" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Advanced Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/master/docs/src/advanced_usage.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="advanced-usage-1"><a class="docs-heading-anchor" href="#advanced-usage-1">Advanced Usage</a><a class="docs-heading-anchor-permalink" href="#advanced-usage-1" title="Permalink"></a></h1><h2 id="Package-Directory-Structure-1"><a class="docs-heading-anchor" href="#Package-Directory-Structure-1">Package Directory Structure</a><a class="docs-heading-anchor-permalink" href="#Package-Directory-Structure-1" title="Permalink"></a></h2><p>The package directory structure follows Julia module conventions. Directories in square brackets indicate future additions. <em>Note that this directory tree is not linked, although it appears to be.</em></p><ul><li><a href="../pkg_structure/#[DSGE.jl](https://github.com/FRBNY-DSGE/DSGE.jl)-1"><code>DSGE.jl</code></a></li><ul><li><a href="../pkg_structure/#doc/:-Code-and-model-documentation.-1"><code>doc/</code>: Code and model documentation.</a></li><ul><li><a href="../pkg_structure/#examples/:-example-scripts-1"><code>examples/</code>: example scripts</a></li></ul><li><a href="../pkg_structure/#save/:-Sample-input-files;-default-input/output-directories.-1"><code>save/</code>: Sample input files; default input/output directories.</a></li><li><a href="../pkg_structure/#src/-1"><code>src/</code></a></li><ul><li><a href="../pkg_structure/#DSGE.jl:-The-main-module-file.-1"><code>DSGE.jl</code>: The main module file.</a></li><li><a href="../pkg_structure/#abstractdsgemodel.jl:-Defines-the-AbstractModel-type.-1"><code>abstractdsgemodel.jl</code>: Defines the <code>AbstractModel</code> type.</a></li><li><a href="../pkg_structure/#abstractvarmodel.jl:-Defines-the-AbstractVARModel,-AbstractDSGEVARModel,-and-AbstractDSGEVECMModel-types.-1"><code>abstractvarmodel.jl</code>: Defines the <code>AbstractVARModel</code>, <code>AbstractDSGEVARModel</code>, and <code>AbstractDSGEVECMModel</code> types.</a></li><li><a href="../pkg_structure/#defaults.jl:-Default-settings-for-models.-1"><code>defaults.jl</code>: Default settings for models.</a></li><li><a href="../pkg_structure/#statespace_types.jl:-Defines-types-for-computing-the-state-space-representation-of-models.-1"><code>statespace_types.jl</code>: Defines types for computing the state-space representation of models.</a></li><li><a href="../pkg_structure/#statespace_functions.jl:-Defines-functions-for-computing-the-state-space-representation-of-models.-1"><code>statespace_functions.jl</code>: Defines functions for computing the state-space representation of models.</a></li><li><a href="../pkg_structure/#data/:-Manipulating-and-updating-input-dataset.-1"><code>data/</code>: Manipulating and updating input dataset.</a></li><li><a href="../pkg_structure/#solve/:-Solving-the-model;-includes-gensys.jl-code.-1"><code>solve/</code>: Solving the model; includes <code>gensys.jl</code> code.</a></li><li><a href="../pkg_structure/#estimate/:-Optimization,-posterior-sampling,-and-other-functionality.-1"><code>estimate/</code>: Optimization, posterior sampling, and other functionality.</a></li><li><a href="../pkg_structure/#forecast/:-Forecasts,-smoothing,-shock-decompositions,-and-impulse-response-functions.-1"><code>forecast/</code>: Forecasts, smoothing, shock decompositions, and impulse response functions.</a></li><li><a href="../pkg_structure/#decomp/:-Decompose-changes-in-forecasts-into-three-reasons:-new-data,-data-revisions,-and-changes-in-the-calibration.-1"><code>decomp/</code>: Decompose changes in forecasts into three reasons: new data, data revisions, and changes in the calibration.</a></li><li><a href="../pkg_structure/#analysis/:-Moment-tables-of-estimated-parameters,-computation-of-forecast-means-and-bands.-1"><code>analysis/</code>: Moment tables of estimated parameters, computation of forecast means and bands.</a></li><li><a href="../pkg_structure/#altpolicy/:-Infrastructure-for-forecasting-under-alternative-monetary-policy-rules.-1"><code>altpolicy/</code>: Infrastructure for forecasting under alternative monetary policy rules.</a></li><li><a href="../pkg_structure/#scenarios/:-Forecasting-alternative-scenarios.-1"><code>scenarios/</code>: Forecasting alternative scenarios.</a></li><li><a href="../pkg_structure/#plot/:-Plot-estimation-results,-forecasts,-etc.-1"><code>plot/</code>: Plot estimation results, forecasts, etc.</a></li><li><a href="../pkg_structure/#packet/:-Automatically-generate-documents-with-results-from-forecasts-and-estimations.-1"><code>packet/</code>: Automatically generate documents with results from forecasts and estimations.</a></li><li><a href="../pkg_structure/#models/-1"><code>models/</code></a></li><ul><li><a href="../pkg_structure/#representative/:-Representative-agent-models.-1"><code>representative/</code>: Representative agent models.</a></li><ul><li><a href="../pkg_structure/#m990/:-Contains-code-to-define-and-initialize-version-990-of-the-New-York-Fed-DSGE-model.-1"><code>m990/</code>: Contains code to define and initialize version 990 of the New York Fed DSGE model.</a></li><li><a href="../pkg_structure/#[[m991/]]:-Code-for-new-models-should-be-kept-in-directories-at-this-level-in-the-directory-tree-1">[<code>[m991/]</code>]: Code for new models should be kept in directories at this level in the directory tree</a></li></ul><li><a href="../pkg_structure/#heterogeneous/:-Heterogeneous-agent-models-1"><code>heterogeneous/</code>: Heterogeneous agent models</a></li><li><a href="../pkg_structure/#poolmodel/:-PoolModel-type-for-model-averaging.-1"><code>poolmodel/</code>: PoolModel type for model averaging.</a></li><li><a href="../pkg_structure/#var/:-DSGE-VAR-and-DSGE-VECM-models.-1"><code>var/</code>: DSGE-VAR and DSGE-VECM models.</a></li></ul></ul><li><a href="../pkg_structure/#test/:-Module-test-suite.-1"><code>test/</code>: Module test suite.</a></li></ul></ul><h2 id="working-with-settings-1"><a class="docs-heading-anchor" href="#working-with-settings-1">Working with Settings</a><a class="docs-heading-anchor-permalink" href="#working-with-settings-1" title="Permalink"></a></h2><p>There are many computational settings that affect how the code runs without affecting the mathematical definition of the model. While the default settings loaded are intended to be comprehensive rather than the minimal number of settings, users will generally want to check that these three settings are properly chosen:</p><ul><li><code>saveroot::String</code>: The root directory for model output.</li><li><code>dataroot::String</code>: The root directory for model input data.</li><li><code>data_vintage::String</code>: Data vintage, formatted <code>yymmdd</code>. By default, <code>data_vintage</code> is set to today&#39;s date. It is (currently) the only setting printed to output filenames by default.</li><li><code>cond_vintage::String</code>: Conditional data vintage, formatted <code>yymmdd</code>. By default, <code>cond_vintage</code> is set to today&#39;s date.</li><li><code>data_id::Int64</code>: ID number to append to a created data set&#39;s name and to identify which saved data set to load</li><li><code>cond_id::Int64</code>: ID number to identify which conditional data set should be loaded</li></ul><p>Many functions in DSGE.jl will either require input data or create output data, so it is important to check that the saveroot and dataroot are set as the user intends. Setting the data vintage is also useful for reproducibility. Economic data like GDP are frequently revised, which can pose issues for reproducing results. Setting the data vintage allows users to guarantee the correct vintage of data is used when generating results. By default, the data vintage is set to the current date, so a user will need to manually set the data vintage to the desired date.</p><p>Below, we describe several important settings for package usage.</p><p>For more details on implementation and usage of settings, see <a href="https://github.com/FRBNY-DSGE/ModelConstructors.jl">ModelConstructors.jl</a>.</p><p>See <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/src/defaults.jl">defaults.jl</a> for the complete description of default settings.</p><h4 id="General-1"><a class="docs-heading-anchor" href="#General-1">General</a><a class="docs-heading-anchor-permalink" href="#General-1" title="Permalink"></a></h4><ul><li><code>saveroot::String</code>: The root directory for model output.</li><li><code>use_parallel_workers::Bool</code>: Use available parallel workers in computations.</li><li><code>nominal_rate_observable</code>: Name (as a <code>Symbol</code>) of the observable used to measure the nominal interest rate used to implement monetary policy.</li><li><code>monetary_policy_shock</code>: Name (as a <code>Symbol</code>) of the exogenous monetary policy shock in a concrete subtype of <code>AbstractDSGEModel</code>.</li><li><code>n_mon_anticipated_shocks::Int</code>: Number of anticipated policy shocks.</li><li><code>antshocks::Dict{Symbol, Int}</code>: a dictionary mapping the name of an anticipated shock to the number of periods of anticipation, e.g. <code>:b =&gt; 2</code> adds anticipated <code>b</code> shocks up to two periods ahead.</li><li><code>ant_eq_mapping::Dict{Symbol, Symbol}</code>: a dictionary mapping the name of an anticipated shock to the name of the state variable in the equation defining the shock&#39;s exogenous process, e.g. <code>:b =&gt; :b</code> maps an anticipated <code>b</code> shock to the equation <code>eq_b</code>.</li><li><code>ant_eq_E_mapping::Dict{Symbol, Symbol}</code>: a dictionary mapping the name of an anticipated shock to the name of the state variable in the equation defining the shock&#39;s one-period ahead expectation e.g. <code>:b =&gt; :Eb</code>  maps an anticipated <code>b</code> shock to the equation <code>eq_Eb</code>, where <code>Eb</code> is <span>$E_t[b_{t + 1}]$</span>.</li><li><code>proportional_antshocks::Vector{Symbol}</code>: a vector of the names of one-period ahead anticipated shocks which are specified as directly proportional to the realizations of the current period&#39;s unanticipated shocks. For a shock <code>b</code>, the automatically generated parameter <code>σ_b_prop</code> defines the proportionality to the current period shock, e.g. a value of 1 indicates an anticipated shock in the next period of the same size as the current period&#39;s unanticipated shock.</li></ul><h4 id="Data-and-I/O-1"><a class="docs-heading-anchor" href="#Data-and-I/O-1">Data and I/O</a><a class="docs-heading-anchor-permalink" href="#Data-and-I/O-1" title="Permalink"></a></h4><ul><li><code>dataroot::String</code>: The root directory for model input data.</li><li><code>data_vintage::String</code>: Data vintage, formatted <code>yymmdd</code>. By default, <code>data_vintage</code> is set to today&#39;s date. It is (currently) the only setting printed to output filenames by default.</li><li><code>dataset_id::Int</code>: Dataset identifier. There should be a unique dataset ID for each set of observables.</li><li><code>cond_vintage::String</code>: Conditional data vintage, formatted <code>yymmdd</code>.</li><li><code>cond_id::Int</code>: Conditional dataset identifier. There should be a unique conditional dataset ID for each set of input, raw data mnemonics (not observables!).</li><li><code>cond_semi_names::Vector{Symbol}</code> and <code>cond_full_names::Vector{Symbol}</code>: names of observables for which we want to use semi- and full conditional data. All other observables are <code>NaN</code>ed out in the conditional data periods.</li><li><code>population_mnemonic::Nullable{Symbol}</code>: population series mnemonic in form <code>Nullable(:&lt;mnemonic&gt;__&lt;source&gt;)</code> (for example, <code>Nullable(:CNP16OV__FRED)</code>), or <code>Nullable{Symbol}()</code> if the model doesn&#39;t use population data</li></ul><h4 id="Dates-1"><a class="docs-heading-anchor" href="#Dates-1">Dates</a><a class="docs-heading-anchor-permalink" href="#Dates-1" title="Permalink"></a></h4><ul><li><code>date_presample_start::Date</code>: Start date of pre-sample.</li><li><code>date_mainsample_start::Date</code>: Start date of main sample.</li><li><code>date_zlb_start::Date</code>: Start date of zero lower bound regime.</li><li><code>date_zlb_end::Date</code>: End date of zero lower bound regime.</li><li><code>date_forecast_start::Date</code>: Start date of forecast period (or the period after the last period for which we have GDP data).</li><li><code>date_forecast_end::Date</code>: End date of forecast, i.e. how far into the future to forecast.</li><li><code>date_conditional_end::Date</code>: Last date for which we have conditional data. This is typically the same as <code>date_forecast_start</code> when we condition on nowcasts and current quarter financial data.</li></ul><h4 id="Estimation-1"><a class="docs-heading-anchor" href="#Estimation-1">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-1" title="Permalink"></a></h4><h5 id="Metropolis-Hastings-Settings-1"><a class="docs-heading-anchor" href="#Metropolis-Hastings-Settings-1">Metropolis-Hastings Settings</a><a class="docs-heading-anchor-permalink" href="#Metropolis-Hastings-Settings-1" title="Permalink"></a></h5><ul><li><code>reoptimize::Bool</code>: Whether to reoptimize the posterior mode. If <code>true</code> (the   default), <code>estimate</code> begins reoptimizing from the model object&#39;s parameter   vector.  See <a href="../estimation/#estimation-reoptimizing-1">Optimizing or Reoptimizing</a> for   more details.</li><li><code>calculate_hessian::Bool</code>: Whether to compute the Hessian. If <code>true</code> (the   default), <code>estimate</code> calculates the Hessian at the posterior mode.</li><li><code>n_mh_simulations::Int</code>: Number of draws from the posterior distribution per block.</li><li><code>n_mh_blocks::Int</code>: Number of blocks to run Metropolis-Hastings.</li><li><code>n_mh_burn::Int</code>: Number of blocks to discard as burn-in for Metropolis-Hastings.</li><li><code>mh_thin::Int</code>: Metropolis-Hastings thinning step.</li><li><code>parallel::Bool</code>: Flag for running algorithm in parallel.</li><li><code>mh_adaptive_accept::Bool</code>: if true, then the proposal distribution is adapted to achieve a target accept rate.</li><li><code>mh_target_accept::Bool</code>: target accept rate when adaptively adjusting acceptance probability.</li><li><code>mh_c::S = 0.5</code>: Initial scaling factor for covariance of the particles when using an adaptive proposal distribution. Controls size of steps in mutation step.</li><li><code>mh_α::S = 1.0</code>: The mixture proportion for the mutation step&#39;s proposal distribution when using an adaptive proposal distribution. See <code>?mvnormal_mixture_draw</code> for details. Note that a value of 0.9 has commonly been used in applications to DSGE models (see citations below).</li></ul><h5 id="Sequential-Monte-Carlo-Settings-1"><a class="docs-heading-anchor" href="#Sequential-Monte-Carlo-Settings-1">Sequential Monte Carlo Settings</a><a class="docs-heading-anchor-permalink" href="#Sequential-Monte-Carlo-Settings-1" title="Permalink"></a></h5><ul><li><code>n_particles::Int</code>: Number of particles.</li><li><code>n_smc_blocks::Int</code>: Number of parameter blocks in mutation step.</li><li><code>n_mh_steps_smc::Int</code>: Number of Metropolis Hastings steps to attempt during the mutation step.</li><li><code>λ::S</code>: The &#39;bending coefficient&#39; λ in Φ(n) = (n/N(Φ))^λ</li><li><code>n_Φ::Int</code>: Number of stages in the tempering schedule.</li><li><code>resampling_method::Symbol</code>: Which resampling method to use.<ul><li><code>:systematic</code>: Will use sytematic resampling.</li><li><code>:multinomial</code>: Will use multinomial resampling.</li><li><code>:polyalgo</code>: Samples using a polyalgorithm.</li></ul></li><li><code>threshold_ratio::S</code>: Threshold s.t. particles will be resampled when the population   drops below threshold * N</li><li><code>step_size_smc::S</code>: Scaling factor for covariance of the particles. Controls size of steps in mutation step.</li><li><code>mixture_proportion::S</code>: The mixture proportion for the mutation step&#39;s proposal distribution.</li><li><code>target_accept::S</code>: The initial target acceptance rate for new particles during mutation.</li><li><code>use_fixed_schedule::Bool</code>: Flag for whether or not to use a fixed tempering (ϕ) schedule.</li><li><code>adaptive_tempering_target_smc::S</code>: Coefficient of the sample size metric to be targeted when solving   for an endogenous ϕ or 0.0 if using a fixed schedule.</li><li><code>tempered_update_prior_weight::S</code>: when bridging from old estimation, i.e. a tempered update, the user   can create a bridge distribution as a convex combination of the prior and a   previously ran estimation. This setting is the relative weight on the prior   in the convex combination.</li><li><code>smc_iteration::Int</code>: The iteration index for the number of times SMC has been run on the    same data vintage. Primarily for numerical accuracy/testing purposes.</li><li><code>previous_data_vintage::String</code>: the old data vintage from which to start SMC when using a tempered update</li><li><code>debug_assertion::Bool</code>: print output (if applicable) when encountering an assertion error during SMC to help with debugging.</li></ul><h5 id="Miscellaneous-1"><a class="docs-heading-anchor" href="#Miscellaneous-1">Miscellaneous</a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-1" title="Permalink"></a></h5><ul><li><code>use_chand_recursion::Bool</code>: Flag for using Chandrasekhar Recursions in Kalman filter.</li></ul><h4 id="Forecasting-1"><a class="docs-heading-anchor" href="#Forecasting-1">Forecasting</a><a class="docs-heading-anchor-permalink" href="#Forecasting-1" title="Permalink"></a></h4><ul><li><code>forecast_jstep::Int</code>: Forecast thinning step.</li><li><code>forecast_block_size::Int</code>: Number of draws in each forecast block <em>before</em> thinning by <code>forecast_jstep</code>.</li><li><code>forecast_input_file_overrides::Dict{Symbol, String}</code>: Maps <code>input_type</code>(s) to the file name containing input draws for that type of forecast. See <a href="@ref">Forecasting</a>.</li><li><code>forecast_horizons::Int</code>: Number of periods to forecast.</li><li><code>impulse_response_horizons::Int</code>: Number of periods for which to calculate IRFs.</li><li><code>n_periods_no_shocks::Int</code>: Number of periods for which no shocks are drawn (e.g. a full-distribution forecast draws shocks, but if <code>n_periods_no_shocks = 3</code>, then for 3 periods in the forecast horizon, no shocks will be drawn)</li></ul><h4 id="Alternative-Policy-1"><a class="docs-heading-anchor" href="#Alternative-Policy-1">Alternative Policy</a><a class="docs-heading-anchor-permalink" href="#Alternative-Policy-1" title="Permalink"></a></h4><ul><li><code>alternative_policy::AltPolicy</code>: See <a href="@ref">Alternative Policies</a>.</li></ul><h3 id="Accessing-Settings-1"><a class="docs-heading-anchor" href="#Accessing-Settings-1">Accessing Settings</a><a class="docs-heading-anchor-permalink" href="#Accessing-Settings-1" title="Permalink"></a></h3><p>The function <code>get_setting(m::AbstractModel, s::Symbol)</code> returns the value of the setting <code>s</code> in <code>m.settings</code>. Some settings also have explicit getter methods that take only the model object <code>m</code> as an argument. Note that not all are exported.</p><h3 id="Overwriting-Default-Settings-1"><a class="docs-heading-anchor" href="#Overwriting-Default-Settings-1">Overwriting Default Settings</a><a class="docs-heading-anchor-permalink" href="#Overwriting-Default-Settings-1" title="Permalink"></a></h3><p>To overwrite default settings added during model construction, a user must create a <code>Dict{Symbol, Setting}</code> and pass that into the model constructor as the keyword argument <code>custom_settings</code>. If the <code>print</code>, <code>code</code>, and <code>description</code> fields of the new <code>Setting</code> object are not provided, the fields of the existing setting will be maintained. If new values for <code>print</code>, <code>code</code>, and <code>description</code> are specified, and if these new values are distinct from the defaults for those fields, the fields of the existing setting will be updated.</p><p>For example, overwriting <code>use_parallel_workers</code> should look like this:</p><pre><code class="language-julia">custom_settings = Dict{Symbol, Setting}(
    :use_parallel_workers =&gt; Setting(:use_parallel_workers, true))
m = Model990(custom_settings = custom_settings)</code></pre><p>Or like this:</p><pre><code class="language-julia">m = Model990()
m &lt;= Setting(:use_parallel_workers, true)</code></pre><p>Note that using this second method will not work for all settings, e.g. <code>n_anticipated_shocks</code> is a setting that must be passed into the model during construction, as in the first example.</p><p>By default, passing in <code>custom_settings</code> overwrites the entries in the model object&#39;s <code>settings</code> field. However, with the additional keyword argument <code>testing = true</code>, it will overwrite the entries in <code>test_settings</code>:</p><pre><code class="language-julia">m = Model990(custom_settings = custom_settings, testing = true)</code></pre><h2 id="accel-regime-switch-statespace-comp-1"><a class="docs-heading-anchor" href="#accel-regime-switch-statespace-comp-1">Accelerating Computation of Regime-Switching System</a><a class="docs-heading-anchor-permalink" href="#accel-regime-switch-statespace-comp-1" title="Permalink"></a></h2><p>Regime-switching state space systems take more time to compute, which can severely slow down estimation and forecasting time. The interface for computing regime-switching systems is written to be easy to use and generic, but, as a result, its default behavior ignores information that could be used to accelerate computation time. We provide some settings that allow the user to specify such information about the state space system.</p><ul><li><code>perfect_credibility_identical_transitions::Dict{Int, Int}</code>: different regimes may have the same transition equations (<code>TTT</code>, <code>RRR</code>, and <code>CCC</code> matrices, also see <a href="@ef solving-dsge-doc">Solving the Model</a>). This setting tells the code to use another regime&#39;s transition equation rather than recalculate the equation. The keys of this <code>Dict</code> are regime numbers, and the values specify the regime to which the keys&#39; regimes are identical. For example, if the setting was <code>Dict(2 =&gt; 1, 3 =&gt; 1)</code>, then we are saying that regimes 2 and 3 have the same transition equations as regime 1. Note that if you are using <code>gensys2</code>, then you cannot say that <code>gensys</code> regimes have the same transition equations as any regime on which <code>gensys2</code> is called, including the terminal period of <code>gensys2</code>, even though the transition equations may indeed be the same. The reason is that the <code>gensys</code> regimes are computed before the <code>gensys2</code> regimes, and to avoid extra calculations, the terminal period is computed during the <code>gensys2</code> step. Therefore, trying to copy a <code>gensys2</code> regime for a <code>gensys</code> regime will cause an error (an attempt to access an undefined reference).</li></ul><ul><li><p><code>identical_eqcond_regimes::Dict{Int, Int}</code>: different regimes may have the same equilibrium conditions (see <a href="@ef solving-dsge-doc">Solving the Model</a>). This setting tells the code to copy another regime&#39;s equilibrium conditions rather than recompute the gensys matrices. The keys of this <code>Dict</code> are regime numbers, and the values specify the regime to which the keys&#39; regimes are identical. For example, if the setting was <code>Dict(2 =&gt; 1, 3 =&gt; 1)</code>, then we are saying that regimes 2 and 3 have the same equilibrium conditions as regime 1.</p></li><li><p><code>empty_measurement_equation::Vector{Bool}</code>: when using time-varying information sets and forward-looking observables, you may need to calculate the transition equations beyond the last period of available data. By default, <code>compute_system</code> will also compute the measurement equation for these regimes in the future, which is unnecessary if you are trying to estimate the model. This setting specifies which regimes can have an empty measurement equation (set to be a <code>Measurement</code> type with undefined matrices for its fields). A <code>false</code> element in the vector means that the measurement equation is nonempty, while a <code>true</code> element means an empty measurement equation. The length of the vector should be the same length as the number of regimes, and the indices of the vector corresponding to the regime number.</p></li><li><p><code>empty_pseudo_measurement_equation::Vector{Bool}</code>: same as <code>empty_measurement_equation</code> but for the pseudo-measurement equation. For estimations, you can omit all the pseudo-measurement equations since they are unnecessary.</p></li></ul><h2 id="regime-switch-forecast-1"><a class="docs-heading-anchor" href="#regime-switch-forecast-1">Regime-Switching Forecasts</a><a class="docs-heading-anchor-permalink" href="#regime-switch-forecast-1" title="Permalink"></a></h2><p>Forecasts can involve state-space systems with exogenous and unanticipated regime-switching in the history periods and forecast horizon. Anticipated temporary alternative policies can also occur in both the history and the forecast horizon. Historical regime switching may occur to reflect structural breaks or to allow a DSGE to handle special circumstances, such as the COVID-19 pandemic. Regime switches in the forecast horizon may occur because agents expect a ZLB until some date in the future. In a rational expectations equilibrium, agents will behave differently if they know a forecasted policy is temporary rather than permanent. Using exogenous regime-switching along with a modified <code>gensys</code> solution algorithm is one way of implementing this expectation. See <a href="../solving/#solveregswitch-1">Regime-Switching</a> for more details on the solution algorithm.</p><p>In this section, we will go over the interface for running regime-switching forecasts and discuss some details of the implementation. It is useful to also look at the posted <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/examples/regime_switching.jl">example script</a> for regime-switching. To understand how to implement your own regime-switching model, we recommend examining the implementation of <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/src/models/representative/m1002/eqcond.jl">regime-switching equilibrium conditions</a> for <code>Model1002</code> and how it is integrated with our <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/src/solve/solve.jl">solvers</a>. For a guide to running permanent and/or temporary alternative policies, please see <a href="@ref">Alternative Policies</a>.</p><h3 id="Preparing-a-Model&#39;s-Settings-for-Regime-Switching-1"><a class="docs-heading-anchor" href="#Preparing-a-Model&#39;s-Settings-for-Regime-Switching-1">Preparing a Model&#39;s Settings for Regime-Switching</a><a class="docs-heading-anchor-permalink" href="#Preparing-a-Model&#39;s-Settings-for-Regime-Switching-1" title="Permalink"></a></h3><p>Suppose we wanted to run a regime-switching forecast, where where the regimes are 1959:Q3-1989:Q4, 1990:Q1-2019:Q3, and 2019:Q4 to the end of the forecast horizon. The following lines are required:</p><pre><code class="language-none">m &lt;= Setting(:regime_switching, true)
m &lt;= Setting(:regime_dates, Dict{Int, Date}(1 =&gt; Date(1959, 9, 30), 2 =&gt; Date(1990, 3, 31),
                                            3 =&gt; Date(2019, 12, 31))</code></pre><p>The first setting turns on regime switching. Internally, functions like <code>forecast_one</code> will decide whether to use regime switching or not depending on whether <code>get_setting(m, :regime_switching)</code> is true and whether there are actually multiple regimes specified by <code>:regime_dates</code>. The second setting is a <code>Dict</code> mapping the regime number to the first date (inclusive) of that regime.</p><p>Before running a forecast, we must also run</p><pre><code class="language-none">setup_regime_switching_inds!(m; cond_type = cond_type)</code></pre><p>which will automatically compute the (required) settings</p><ul><li><code>:reg_forecast_start</code>: Regime of the first forecast start period</li><li><code>:reg_post_conditional_end</code>: Regime of the period after the last conditional forecast period</li><li><code>:n_regimes</code>: Number of total regimes. If this is 1, then regime switching will not occur.</li><li><code>:n_hist_regimes</code>: Number of regimes in the history</li><li><code>:n_fcast_regimes</code>: Number of regimes in the forecast horizon (including the conditional forecast)</li><li><code>:n_cond_regimes</code>: Number of regimes in the conditional forecast</li></ul><p>These settings will generally depend on whether the forecast is conditional or not, so the user needs to pass in <code>cond_type = :full</code> or <code>cond_type = :semi</code> to <code>setup_regime_switching_inds!</code> if the user wants a forecast with correct regime-switching.</p><p>Finally, to run a full-distribution forecast with regime-switching using <code>forecast_one</code> or <code>usual_model_forecast</code>, it is necessary to manually construct the matrix of parameter draws and pass them as an input with the keyword <code>params</code>. Currently, we have not fully implemented loading parameters from a saved estimation file. For an example about how to do this, see this <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/examples/regime_switching.jl">example script</a>.</p><h3 id="tvis-1"><a class="docs-heading-anchor" href="#tvis-1">Time-Varying Information Sets</a><a class="docs-heading-anchor-permalink" href="#tvis-1" title="Permalink"></a></h3><p>In many applications with regime-switching, changes in information sets may occur. For example, say in 1959:Q1 - 2007:Q3, people expected the Federal Reserve to always use a Taylor-style monetary policy rule. But in 2007:Q4, people realize that the Federal Reserve will implement a zero lower bound for <code>N</code> periods before switching back to the Taylor-style rule. The measurement equation used in 2007:Q4 and subsequent periods need to account for this change in the information set. In particular, quantities like anticipated nominal rates and 10Y inflation rates involve forecasting the expected state of the economy. If the transition matrices (e.g. <code>TTT</code>) are time-varying, and agents&#39; information set includes knowledge that the matrices are time-varying, then the measurement equation should account for it. Explicitly, assume the state space evolves according to</p><div>\[\begin{aligned}
s_t = T_t s_{t - 1} + R_t \varepsilon_t + C_t.
\end{aligned}\]</div><p>If in period <code>t</code>, the measurement equation includes the anticipated nominal rate in <span>$k$</span> periods, and agents know that the transition equations are time-varying over some horizon <span>$H$</span>, then we need to calculate that expectation taking into account that agents know about the time variation in the matrices, e.g. <span>$T_{t + 1}, \dots, T_{t + H}$</span>. This approach allows for varying degrees of myopia, e.g. <span>$H = 0$</span> implies that agents do not know about any time variation while <span>$H &lt; k$</span> captures the case that agents only know about the time variation up to a certain horizon forward.</p><p>To help the user write the correct measurement equation with time-varying transition equations, we have implemented the following two functions:</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.k_periods_ahead_expectations" href="#DSGE.k_periods_ahead_expectations"><code>DSGE.k_periods_ahead_expectations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">k_periods_ahead_expectations(TTT, CCC, TTTs, CCCs, t, k; permanent_t = length(TTTs),
                             integ_series = false, memo = nothing)</code></pre><p>calculates the matrices associated with the expected state <code>k</code> periods ahead from <code>t</code>. This function should NOT be used with linear state space system matrices with any unit roots.</p><p>The <code>TTT</code> and <code>CCC</code> inputs are the transition matrix and constant vector associated with the current period <code>t</code>, while the <code>TTTs</code> and <code>CCCs</code> are vectors containing the time-varying transition matrices and constant vectors, such that <code>TTTs[t]</code> retrieves the time-varying transition matrix associated with period <code>t</code> and <code>TTTs[t + k]</code> retrieves the time-varying transition matrix associated with period <code>t + k</code>. The optional argument <code>permanent_t</code> indicates the period for which the matrices/vectors are no longer time-varying, i.e. if <code>t &gt;= permanent_t</code>, then <code>TTTs[permanent_t]</code> is the transition matrix.</p><p>The formula implemented by this function is</p><pre><code class="language-none">𝔼ₜ[sₜ₊ₖ] = (∏ⱼ=₁ᵏ Tₜ₊ⱼ) sₜ + (∑ₘ₌₁ᵏ⁻¹ (∏ⱼ₌ₘ₊₁ᵏ Tₜ₊ⱼ) Cₜ₊ₘ) + Cₜ₊ₖ.</code></pre><p>Additional simplifications are made if it is known that <code>t + k &gt; permanent_t</code> since this implies some matrices are the same. This recognition reduces unnecessary computations.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>integ_series::Bool</code>: set to true if there are some transition matries in <code>TTT</code>   that result in integrated series, in which case we cannot speed up   computations by using left-divides.</p></li><li><p><code>memo::Union{ForwardExpectationsMemo, Nothing}</code>: pass a properly formed   <code>ForwardExpectationsMemo</code> to avoid calculating unnecessary products and powers of   the matrices in <code>TTTs</code>. Typically, the memo you want to compute is</p></li></ul><pre><code class="language-none"># min_t is minimum t you will use, maximum_t is maximum t you will use, and
# max_k is the maximum window for forward expectations.
memo = ForwardExpectationsMemo(TTTs, min_t, length(TTTs), length(TTTs), min_t + max_k - length(TTTs),
                               max_t + max_k + 1 - length(TTTs))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/991c7b341764de3fbaa9d21705d92c70935fb219/src/statespace/util.jl#L287-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.k_periods_ahead_expected_sums" href="#DSGE.k_periods_ahead_expected_sums"><code>DSGE.k_periods_ahead_expected_sums</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">k_periods_ahead_expected_sums(TTT, CCC, TTTs, CCCs, t, k; permanent_t = length(TTTs),
                              integ_series = false, memo = nothing)</code></pre><p>calculates the matrices associated with the sum of the expected states between periods <code>t + 1</code> and  <code>t + k</code>. This function should NOT be used with linear state space system matrices with any unit roots.</p><p>The <code>TTT</code> and <code>CCC</code> inputs are the transition matrix and constant vector associated with the current period <code>t</code>, while the <code>TTTs</code> and <code>CCCs</code> are vectors containing the time-varying transition matrices and constant vectors, such that <code>TTTs[t]</code> retrieves the time-varying transition matrix associated with period <code>t</code> and <code>TTTs[t + k]</code> retrieves the time-varying transition matrix associated with period <code>t + k</code>. The optional argument <code>permanent_t</code> indicates the period for which the matrices/vectors are no longer time-varying, i.e. if <code>t &gt;= permanent_t</code>, then <code>TTTs[permanent_t]</code> is the transition matrix.</p><p>The formula implemented by this function is</p><pre><code class="language-none">∑ⱼ₌₁ᵏ 𝔼ₜ[sₜ₊ⱼ] = ∑ⱼ₌₁ᵏ(∏ⱼ=₁ᵏ Tₜ₊ⱼ) sₜ + ∑ᵣ₌₁ᵏ⁻¹(I + ∑ⱼ₌ᵣ₊₁ᵏ (∏ₘ₌ᵣ₊₁ʲ Tₜ₊ₘ))Cₜ₊ᵣ + Cₜ₊ₖ.</code></pre><p>Additional simplifications are made if it is known that <code>t + k &gt; permanent_t</code> since this implies some matrices are the same. This recognition reduces unnecessary computations.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>integ_series::Bool</code>: set to true if there are some transition matries in <code>TTT</code>   that result in integrated series, in which case we cannot speed up   computations by using left-divides.</p></li><li><p><code>memo::Union{ForwardMultipleExpectationsMemo, Nothing}</code>: pass a properly formed   <code>ForwardExpectationsMemo</code> to avoid calculating unnecessary products and powers of   the matrices in <code>TTTs</code>. Typically, the memo you want to compute is</p></li></ul><pre><code class="language-none"># min_t is minimum t you will use, maximum_t is maximum t you will use, and
# max_k is the maximum window for forward expectations.
memo = ForwardMultipleExpectationsMemo(TTTs, min_t, length(TTTs), length(TTTs), min_t + max_k - length(TTTs),
                               max_t + max_k + 1 - length(TTTs))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/991c7b341764de3fbaa9d21705d92c70935fb219/src/statespace/util.jl#L480-L521">source</a></section></article><p>See the <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/src/model/representative/m1002/measurement.jl">measurement equation for Model 1002</a> for an example of how these functions are used.</p><p>To accelerate the computation time for these functions, we have also implemented types that create memos of the products and powers of the <span>$\{T_{t + k}\}_{t = 1}^k$</span> matrices which are needed. See</p><article class="docstring"><header><a class="docstring-binding" id="DSGE.ForwardExpectationsMemo" href="#DSGE.ForwardExpectationsMemo"><code>DSGE.ForwardExpectationsMemo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ForwardExpectationsMemo(TTTs::Vector{&lt;: AbstractMatrix{S}},
                        current_regime::Int64, last_tv_period::Int64,
                        first_perm_period::Int64, min_perm_power::Int64 = 0,
                        max_perm_power::Int64 = 0) where {S &lt;: Real}</code></pre><p>computes the memo dictionaries of the necessary products/powers of TTTs for computing forward expectations of states and sums of states.</p><p><strong>Inputs</strong></p><ul><li><code>TTTs</code>: complete sequence of time-varying transition matrices from regime 1 to the final regime</li><li><code>current_regime</code>: the current period&#39;s regime</li><li><code>last_tv_period</code>: the last period in which the transition matrix is believed to have changed relative to the previous period.</li><li><code>first_perm_period</code>: the first period in which the transition matrix in <code>TTTs</code> is permanently imposed. This period   should be from the perspective of an omniscient econometrician rather than the agents&#39; perspective.</li><li><code>min_perm_power</code>: minimum power of the permanent matrix to be calculated, i.e. we calculate at least <code>TTTs[first_perm_period] ^ min_perm_power</code></li><li><code>max_perm_power</code>: maximum power of the permanent matrix to be calculated, i.e. we calculate at most <code>TTTs[first_perm_period] ^ max_perm_power</code></li></ul><p><strong>Notes</strong></p><ul><li>To clarify what <code>last_tv_period</code> should be, note that</li></ul><p>if every matrix in <code>TTTs</code> is time-varying, AND agents believe every matrix is time-varying, then <code>last_tv_period = length(TTTs)</code>. However, if agents are myopic and believe that the last time-varying matrix is the second to last one, then <code>last_tv_period = length(TTTs) - 1</code>. This flexibility allows the user to specify different degrees of awareness about <code>TTTs</code>.</p><ul><li>Note that when <code>last_tv_period == first_perm_period</code>, we do not calculate</li></ul><pre><code class="language-none">time_varying_memo[last_tv_period] = TTTs[first_perm_period] * TTTs[first_perm_period - 1] * ... TTTs[t + 1]</code></pre><p>Instead, we calculate</p><pre><code class="language-none">time_varying_memo[last_tv_period] = TTTs[first_perm_period - 1] * ... TTTs[t + 1]</code></pre><p>The reason is that it is more efficient to include that first <code>TTTs[first_perm_period]</code> in the powers of <code>TTT[first_perm_period]</code> computed for <code>permanent_memo</code>. So if <code>length(TTTs) == 7</code>, to get the correct <code>k</code>-periods ahead forward expectations from some period <code>t &lt; 7</code>, you need to run</p><pre><code class="language-none">memo = ForwardExpectationsMemo(TTTs, t, 7, 7, 1, t + k + 1 - 7)
# or equivalently . . .
# memo = ForwardExpectationsMemo(TTTs, t, length(TTTs), length(TTTs), 1, t + k + 1 - length(TTTs))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/991c7b341764de3fbaa9d21705d92c70935fb219/src/statespace/util.jl#L110-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSGE.ForwardMultipleExpectationsMemo" href="#DSGE.ForwardMultipleExpectationsMemo"><code>DSGE.ForwardMultipleExpectationsMemo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ForwardMultipleExpectationsMemo(TTTs::Vector{&lt;: AbstractMatrix{S}},
                                current_regime::Int64, min_last_tv_period::Int64, max_last_tv_period::Int64,
                                first_perm_period::Int64, min_perm_power::Int64 = 0,
                                max_perm_power::Int64 = 0) where {S &lt;: Real}</code></pre><p>computes the memo dictionaries of the necessary products/powers of TTTs for computing forward expectations of states and sums of states for multiple different horizon lengths for the &quot;forward-looking&quot; window, i.e. variation in how many periods ahead for which expectations are taken. This approach avoids repeating computations that would be incurred if the user instead repeatedly created <code>ForwardExpectationsMemo</code> for each horizon length.</p><p><strong>Inputs</strong></p><ul><li><code>TTTs</code>: complete sequence of time-varying transition matrices from regime 1 to the final regime</li><li><code>current_regime</code>: the current period&#39;s regime</li><li><code>min_last_tv_period</code>: the minimum last period in which the transition matrix is believed to have changed relative to the previous period.</li><li><code>max_last_tv_period</code>: the maximum last period in which the transition matrix is believed to have changed relative to the previous period.</li><li><code>first_perm_period</code>: the first period in which the transition matrix in <code>TTTs</code> is permanently imposed. This period   should be from the perspective of an omniscient econometrician rather than the agents&#39; perspective.</li><li><code>min_perm_power</code>: minimum power of the permanent matrix to be calculated, i.e. we calculate at least <code>TTTs[first_perm_period] ^ min_perm_power</code></li><li><code>max_perm_power</code>: maximum power of the permanent matrix to be calculated, i.e. we calculate at most <code>TTTs[first_perm_period] ^ max_perm_power</code></li></ul><p><strong>Notes</strong></p><ul><li>To clarify what <code>min_last_tv_period</code> and <code>max_last_tv_period</code> should be, first consider the meaning of input argument</li></ul><p><code>last_tv_period</code> for <code>ForwardExpectationsMemo</code>. If every matrix in <code>TTTs</code> is time-varying, AND agents believe every matrix is time-varying, then <code>last_tv_period = length(TTTs)</code>. However, if agents are myopic and believe that the last time-varying matrix is the second to last one, then <code>last_tv_period = length(TTTs) - 1</code>. This flexibility allows the user to specify different degrees of awareness about <code>TTTs</code>.</p><p>The argument <code>min_last_tv_period</code> and <code>max_last_tv_period</code> allow the user to construct one memo object for computing varying lengths of forward expectations. For example, suppose we want expectations of the nominal rate from 1 to 6 periods ahead in the measurement equation in the regime <code>t</code>. Then you should run</p><pre><code class="language-none">ForwardExpectationsMemo(TTTs, t, t + 1, t + 6, ...) # ellipsis omits the remaining input args</code></pre><ul><li>Note that when <code>max_last_tv_period == first_perm_period</code>,</li></ul><pre><code class="language-none">time_varying_memo[max_last_tv_period] = TTTs[first_perm_period] * TTTs[first_perm_period - 1] * ... TTTs[t + 1]</code></pre><p>Instead, we calculate</p><pre><code class="language-none">time_varying_memo[max_last_tv_period] = TTTs[first_perm_period - 1] * ... TTTs[t + 1]</code></pre><p>The reason is that it is more efficient to include that first <code>TTTs[first_perm_period]</code> in the powers of <code>TTT[first_perm_period]</code> computed for <code>permanent_memo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/991c7b341764de3fbaa9d21705d92c70935fb219/src/statespace/util.jl#L197-L250">source</a></section></article><p>The first type is mainly an &quot;under the hood&quot; type for <code>k_periods_ahead_expectations</code>. The second type is a wrapper type that constructs all the memos needed to implement forward expectations of levels and sums in an efficient manner. We have automated the construction of memos with the Boolean <code>Setting</code>s <code>use_forward_expectations_memo</code> and <code>use_forward_expected_sum_memo</code>. The first <code>Setting</code> indicates that a memo type will be used for calls to <code>k_periods_ahead_expectations</code> and the second indicates a memo type will be used for calls to <code>k_periods_ahead_expected_sums</code>. It is assumed by default that the last matrix in the sequence <code>TTTs</code> in a <code>RegimeSwitchingSystem</code> is the first period in which a <code>TTT</code> matrix permanently applies (hence we may assume that in all future periods the <code>TTT</code> is the same), but if this is not the case, then the user needs to specify the correct regime with the <code>Setting</code> <code>memo_permanent_policy_regime::Int</code>.</p><p>For details on how we implement a state space system with time-varying information sets, see <a href="../solving/#tvistype-1">The <code>TimeVaryingInformationSetSystem</code> Type</a>. For guidance on how to use this type, e.g. calculating forecats, see this <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/examples/tvis_system.jl">example script</a>.</p><h3 id="Available-Types-of-Regime-Switching-1"><a class="docs-heading-anchor" href="#Available-Types-of-Regime-Switching-1">Available Types of Regime Switching</a><a class="docs-heading-anchor-permalink" href="#Available-Types-of-Regime-Switching-1" title="Permalink"></a></h3><p>There are three cases involving regime switching that are implemented in DSGE.jl</p><ul><li>Exogenous and unanticipated regime switching (e.g. unanticipated regime-switching parameters)</li><li>Alternative policies (temporary and permanent)</li><li>Time-varying information sets</li></ul><p>To implement regime-switching parameters or use temporary alternative policies, see this <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/examples/regime_switching.jl">example script</a> on regime-switching forecasts. This <a href="../altpolicy/#tempaltpol-procedure-1">documentation on temporary alternative policies</a> will also be helpful. For further details on regime-switching parameters, see the <a href="https://github.com/FRBNY-DSGE/ModelConstructors.jl">documentation for ModelConstructors.jl</a>. To implement time-varying information sets, see this <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/examples/tvis_system.jl">example script</a>.</p><p>If the user wants to combine exogenous regime switching in both parameters and policies, then the user may find it useful to distinguish between <em>model</em> and <em>parameter</em> regimes. For example, when implementing a temporary alternative policy, we typically treat each period of the temporary policy as a distinct regime, but the parameters of the model may remain constant across these regimes of the temporary policy. To distinguish the two, we implement in ModelConstructors.jl a second interface for changing parameter regimes. Aside from</p><pre><code class="language-none">toggle_regime!(p::Parameter, regime::Int)</code></pre><p>for example, we also have the syntax</p><pre><code class="language-none">toggle_regime!(p::Parameter, model_regime::Int, d::AbstractDict{Int, Int})</code></pre><p>The latter syntax uses a dictionary to map a model regime to the correct parameter regime. As an example, suppose across 2020:Q1-Q4, I implement a temporary ZLB, and I assume that some parameters also regime switching during this period. Then I may want to write</p><pre><code class="language-none">d = Dict(1 =&gt; 1, # First model and parameter regime coincide (history until 2019:Q4).
         2 =&gt; 2, # Regimes 2-5 represent 2020:Q1-Q4 andmap to the second regime
         3 =&gt; 2,
         4 =&gt; 2,
         5 =&gt; 2,
         6 =&gt; 1) # Starting in regime 6 (2021:Q1), the parameters switch back to the same values from before 2020.</code></pre><p>For more details, see the regime toggling in <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/src/models/representative/m1002/eqcond.jl">Model 1002&#39;s <code>eqcond</code></a> and the <a href="https://github.com/FRBNY-DSGE/ModelConstructors.jl">documentation for ModelConstructors.jl</a>.</p><p>Once the regime-switching settings are properly created, the syntax for running a forecast is the same as when there is no regime-switching. See <a href="@ref">Forecasting</a>.</p><h3 id="Handling-of-the-Zero-Lower-Bound-(ZLB)-1"><a class="docs-heading-anchor" href="#Handling-of-the-Zero-Lower-Bound-(ZLB)-1">Handling of the Zero Lower Bound (ZLB)</a><a class="docs-heading-anchor-permalink" href="#Handling-of-the-Zero-Lower-Bound-(ZLB)-1" title="Permalink"></a></h3><p>The New York Fed DSGE model can handle the ZLB in two ways.</p><p>In the first way, the New York Fed DSGE model treats the ZLB as a temporary alternative policy over a pre-specified horizon. In the second way, the New York Fed DSGE model treats the ZLB as a separate regime in which anticipated monetary policy shocks become &quot;alive&quot; and have positive standard deviations. However, this second form of the ZLB is not implemented as a separate regime. The reason is the only difference in the &quot;pre-ZLB&quot; and &quot;post-ZLB&quot; regimes is whether or not anticipated monetary policy shocks are non-zero. For an example, see the <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/src/forecast/smooth.jl">smoothing code</a> as well as the auxiliary functions <code>zlb_regime_matrices</code> and <code>zlb_regime_indices</code> in this <a href="https://github.com/FRBNY-DSGE/DSGE.jl/blob/main/src/estimate/kalman.jl">file</a>.</p><p>This approach saves computational time. Rather than creating redundant matrices, we directly zero/un-zero the appropriate entries in the pre- and post-ZLB <code>QQ</code> matrices. This approach also economizes on unnecessary switching, For instance, during the calculation of shock decompositions and trends, it is unnecessary to distinguish between the pre- and post-ZLB regimes.</p><h2 id="uncertainaltpol-1"><a class="docs-heading-anchor" href="#uncertainaltpol-1">Alternative Policy Uncertainty and Imperfect Awareness</a><a class="docs-heading-anchor-permalink" href="#uncertainaltpol-1" title="Permalink"></a></h2><p>The standard alternative policy code assumes that people completely believe the change in policy. However, in many cases, the more realistic modeling choice is assuming some uncertainty or imperfect awareness/credibility about the policy change. This approach can also partially address the concern that expectations have counterfactually strong effects in standard DSGEs (e.g. the forward guidance puzzle).</p><h3 id="Theory-1"><a class="docs-heading-anchor" href="#Theory-1">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-1" title="Permalink"></a></h3><p>We model imperfect awareness by assuming there are <span>$n$</span> possible alternative policies that may occur tomorrow and <span>$n$</span> probability weights assigned to each policy. Further, it is believed that the alternative policy which occurs tomorrow will be permanent. One of the policies is the alternative policy which is actually implemented. The function <a href="https://github.com/FRBNY-DSGE/DSGE.jl/tree/main/src/solve/gensys_uncertain_altpol.jl"><code>gensys_uncertain_altpol</code></a> calculates the state space transition equation implied by these beliefs. A typical application is assuming that with probability <span>$p$</span> some alternative policy occurs tomorrow and with probability <span>$1-p$</span> the historical policy occurs tomorrow.</p><p>Imperfect awareness can occur in multiple periods and feature time-varying credibility by assuming myopia. For example, say agents in period <span>$t$</span> believe the central bank will implement AIT in <span>$t + 1$</span> and all subsequent periods with probability <span>$p_t$</span> and the historical rule otherwise. After period <span>$t + 1$</span> occurs and the central bank actually implements AIT, agents again believe that in period <span>$t + 2$</span> and all subsequent periods, the central bank will implement AIT with probability <span>$p_{t + 1}$</span> and the historical rule otherwise.</p><p>Imperfect awareness is robust to temporary alternative policies but requires the algorithm to account for time variation in the transition equation. In particular, we need to first compute the entire sequence of transition equations under the temporary alternative policy with perfect credibility. Once this sequence is available, we can then treat the temporary alternative policy as the alternative policy which is actually implemented and apply the same calculations described in the previous paragraph to each period of the temporary alternative policy.</p><h3 id="Implementation-1"><a class="docs-heading-anchor" href="#Implementation-1">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-1" title="Permalink"></a></h3><p>To apply imperfect awareness, the user needs to specify the possible alternative policies and the probability weights on these policies.</p><p>The alternative policy which is actually implemented should be added to the <code>:regime_eqcond_info</code> dictionary as an <code>EqcondEntry</code>, e.g.</p><pre><code class="language-none">get_setting(m, :regime_eqcond_info)[2] = DSGE.EqcondEntry(DSGE.ngdp())</code></pre><p>The other alternative policies that agents believe may occur are then added as follows:</p><pre><code class="language-none">m &lt;= Setting(:alternative_policies, [altpolicy1, altpolicy2]) # altpolicy1 and altpolicy2 are AltPolicy instances</code></pre><p>The user specifies the probability weights when creating the <code>EqcondEntry</code> instance for the <code>:regime_eqcond_info</code> dictionary, e.g.</p><pre><code class="language-none">DSGE.EqcondEntry(DSGE.ngdp(), [p_t, 1 - p_t])</code></pre><p>This approach permits time-variation in the probability weight because the user can use different <code>p_t</code> for each regime, e.g.</p><pre><code class="language-none">get_setting(m, :regime_eqcond_info)[2] = DSGE.EqcondEntry(DSGE.ngdp(), [.5, .5])
get_setting(m, :regime_eqcond_info)[3] = DSGE.EqcondEntry(DSGE.ngdp(), [1., 0.])</code></pre><p>Finally, before solving for the state space system or running forecasts, the user needs to add the line</p><pre><code class="language-none">m &lt;= Seting(:uncertain_altpolicy, true)</code></pre><p>To use imperfect awareness with a temporary altpolicy (eg. ZLB), the user needs to also add the following lines to the model&#39;s setup:</p><pre><code class="language-none">m &lt;= Setting(:uncertain_temporary_altpolicy, true)
m &lt;= Setting(:temporary_altpolicy_names, keys_of_temp_altpols) # e.g. keys_of_temp_altpols = [:zlb_rule] or [:zero_rate]
m &lt;= Setting(:temporary_altpolicy_length, n_zlb_regs)</code></pre><p>The first line tells that a temporary altpolicy with imperfect awareness should apply. The second line tells which alternative policies (based on their keys) should be recognized as temporary policies and is used to infer on which regimes <code>gensys2</code> should be called. The third line indicates the number of regimes for which the temporary altpolicy occurs. If the third line is not specified, then it is assumed that all regimes in <code>get_setting(m, :regime_eqcond_info)</code> except the last one are temporary altpolicy regimes. This assumption can be wrong, for example, if credibility changes after the temporary altpolicy ends.</p><p>For further guidance on adding imperfect awareness, please see the script <a href="https://github.com/FRBNY-DSGE/DSGE.jl/tree/main/examples/uncertain_altpolicy_zlb.jl">uncertain<em>altpolicy</em>zlb.jl</a>.</p><h3 id="Forward-Looking-Variables-in-the-Measurement-and-Pseudo-Measurement-Equations-1"><a class="docs-heading-anchor" href="#Forward-Looking-Variables-in-the-Measurement-and-Pseudo-Measurement-Equations-1">Forward-Looking Variables in the Measurement and Pseudo-Measurement Equations</a><a class="docs-heading-anchor-permalink" href="#Forward-Looking-Variables-in-the-Measurement-and-Pseudo-Measurement-Equations-1" title="Permalink"></a></h3><p>The measurement and pseudo-measurement equations often include &quot;forward-looking&quot; observables, such as the anticipated nominal interest rate and the expected average inflation rate over the next ten years. The measurement equations for these observables are therefore affected when imperfect awareness is assumed. Say <span>$ZZ_1$</span> and <span>$ZZ_2$</span> are the measurement equation matrices mapping states to observables under two different monetary policy rules which may occur and that all the observables are forward-looking. For simplicity, additionally assume that the associated <span>$DD_1$</span> and <span>$DD_2$</span> are both zero. Because agents at the end of period <span>$t$</span> believe that either policy 1 or policy 2 occurs permanently in period <span>$t + 1$</span>, the measurement equation agents use to map states to data is just the weighted average of the measurement matrices, i.e.</p><div>\[\begin{aligned}
ZZ = p ZZ_1 + (1 - p) ZZ_2
\end{aligned}\]</div><p>The reason is that, conditional on alternative policy 1 occurring, the observables in <span>$t + 1$</span> should be</p><div>\[\begin{aligned}
\mathbb{E}_t[y_{t + 1} \mid \text{policy 1}] &amp; = ZZ_1 \mathbb{E}_t[s_{t + 1} \mid \text{policy 1}].
\end{aligned}\]</div><p>Similarly, if policy 2 occurs, then</p><div>\[\begin{aligned}
\mathbb{E}_t[y_{t + 1} \mid \text{policy 2}] &amp; = ZZ_2 \mathbb{E}_t[s_{t + 1} \mid \text{policy 2}].
\end{aligned}\]</div><p>The law of iterated expectations gives us the desired result.</p><p>The user does not need to worry about coding their measurement equations to account for this, as long as the measurement equation will properly compute <span>$ZZ_i$</span>, given the policies specified in the settings <code>:regime_eqcond_info</code> and <code>:alternative_policies</code>. DSGE.jl will handle the calculation of the convex combinations under the hood. The only setting which users are advised to add is one that indicates which rows of <span>$ZZ$</span> are associated with forward-looking observables, e.g.</p><pre><code class="language-none">m &lt;= Setting(:forward_looking_observables, [:obs_longinflation, :obs_nominalrate1])
m &lt;= Setting(:forward_looking_pseudo_observables, [:Expected10YearNaturalRate])</code></pre><p>If such a setting exists, then DSGE.jl will only calculate the weighted average for the rows associated with these observables/pseudo-observables. Otherwise, we compute the weighted average of the different measurement matrices. This latter approach will always work, but it comes at the cost of unnecessary operations.</p><h3 id="[Imperfect-Awareness-with-Temporary-Policies-as-Alternative-Policies]-1"><a class="docs-heading-anchor" href="#[Imperfect-Awareness-with-Temporary-Policies-as-Alternative-Policies]-1">[Imperfect Awareness with Temporary Policies as Alternative Policies]</a><a class="docs-heading-anchor-permalink" href="#[Imperfect-Awareness-with-Temporary-Policies-as-Alternative-Policies]-1" title="Permalink"></a></h3><p>The previous documentation generally assumes that the alternative policies which people believe may occur are one-regime and permanent policies. However, it is possible that agents are imperfectly aware over alternative policies that involve temporary policies and thus require the use of <code>gensys2</code>. The only difference the user needs to do is use a <code>MultiPeriodAltPolicy</code> type rather than an <code>AltPolicy</code> type when populating the <code>Setting</code> <code>alternative_policies</code>. See <a href="../altpolicy/#altpol-types-1">Types</a> for documentation on the fields of a <code>MultiPeriodAltPolicy</code>. As an example, the code snippet below implements a temporary ZLB as the alternative policy, assuming the existence of a regime-switching model instance <code>m</code>.</p><pre><code class="language-none"># Alternative Policy 1: default/historical rule
altpol1 = default_policy()

# Alernative Policy 2: ZLB starting in regime 3 and ending in regime 5, and flexible AIT starting in regime 6
new_reg_eqcond_info = Dict(3 =&gt; EqcondEntry(zlb_rule(), reg3_weights), # reg3_weights specifies whatever weights
                           4 =&gt; EqcondEntry(zlb_rule(), reg4_weights), # the user wants in regime 3, etc.
                           5 =&gt; EqcondEntry(zlb_rule(), reg5_weights),
                           6 =&gt; EqcondEntry(flexible_ait(), reg6_weights))
new_infoset         = [1:1, 2:2, [i:6 for i in 3:6]..., [i:i for i in 7:get_setting(m, :n_regimes)]...]

delete!(m.settings, :alternative_policies) # if :alternative_policies already exists, then a type error may occur

altpol2 = MultiPeriodAltPolicy(:temporary_zlb, get_setting(m, :n_regimes),
                               reg_eqcond_info, gensys2 = true,
                               temporary_altpolicy_names = [:zlb_rule],
                               temporary_altpolicy_length = 3,
                               infoset = new_infoset)

# Both AltPolicy and MultiPeriodAltPolicy are subtypes of AbstractAltPolicy
m &lt;= Setting(:alternative_policies, DSGE.AbstractAltPolicy[altpol1, altpol2])</code></pre><h2 id="Automatically-Generating-Anticipated-Shocks-1"><a class="docs-heading-anchor" href="#Automatically-Generating-Anticipated-Shocks-1">Automatically Generating Anticipated Shocks</a><a class="docs-heading-anchor-permalink" href="#Automatically-Generating-Anticipated-Shocks-1" title="Permalink"></a></h2><p>We have implemented some functionality for automatically adding anticipated shocks for <code>Model1002</code>. To add these shocks, the user must pass custom settings into the constructor using the <code>custom_settings</code> keyword. The available settings for defining these shocks are:</p><ul><li><code>antshocks::Dict{Symbol, Int}</code>: a dictionary mapping the name of an anticipated shock to the number of periods of anticipation, e.g. <code>:b =&gt; 2</code> adds anticipated <code>b</code> shocks up to two periods ahead.</li><li><code>ant_eq_mapping::Dict{Symbol, Symbol}</code>: a dictionary mapping the name of an anticipated shock to the name of the state variable in the equation defining the shock&#39;s exogenous process, e.g. <code>:b =&gt; :b</code> maps an anticipated <code>b</code> shock to the equation <code>eq_b</code>.</li><li><code>ant_eq_E_mapping::Dict{Symbol, Symbol}</code>: a dictionary mapping the name of an anticipated shock to the name of the state variable in the equation defining the shock&#39;s one-period ahead expectation e.g. <code>:b =&gt; :Eb</code>  maps an anticipated <code>b</code> shock to the equation <code>eq_Eb</code>, where <code>Eb</code> is <span>$E_t[b_{t + 1}]$</span>.</li><li><code>proportional_antshocks::Vector{Symbol}</code>: a vector of the names of one-period ahead anticipated shocks which are specified as directly proportional to the realizations of the current period&#39;s unanticipated shocks. For a shock <code>b</code>, the automatically generated parameter <code>σ_b_prop</code> defines the proportionality to the current period shock, e.g. a value of 1 indicates an anticipated shock in the next period of the same size as the current period&#39;s unanticipated shock.</li></ul><p>As an example, the following code creates an instance of <code>Model1002</code> with anticipation of <code>b</code> shocks up to two periods ahead.</p><pre><code class="language-none">custom_settings = Dict{Symbol, Setting}(:antshocks =&gt; Setting(:antshocks, Dict{Symbol, Int}(:b =&gt; 2)),
                :ant_eq_mapping =&gt; Setting(:ant_eq_mapping, Dict{Symbol, Symbol}(:b =&gt; :b)))
m = Model1002(&quot;ss10&quot;; custom_settings = custom_settings)</code></pre><h2 id="auto-endo-zlb-1"><a class="docs-heading-anchor" href="#auto-endo-zlb-1">Automatic Endogenous ZLB Enforcement as Temporary Rule</a><a class="docs-heading-anchor-permalink" href="#auto-endo-zlb-1" title="Permalink"></a></h2><p>The user can enforce the ZLB during the forecast horizon in two ways. The default approach uses unanticipated monetary policy shocks. Instead, the user can also use the temporary ZLB machinery to enforce the ZLB. This enforcement is endogenous in the sense that, conditional on a draw of shocks, we want to figure out the required length of a temporary ZLB that will deliver non-negative interest rates throughout the horizon.</p><p>The enforcement is automated by trading off two objectives. First, we want the length of the ZLB to be minimal so that the ZLB is not unnecessarily accommodative, unless it is specifically desired for the ZLB to extend to at least some date. Second, we want to maintain a reasonable computational time. Finding a minimal ZLB length when there are multiple disconnected periods of negative interest rates would be prohibitively expensive because expecting more periods of temporary ZLB in the future affects agents&#39; expectations today, and changing the number of periods of temporary ZLB in the past affects the future evolution of states.</p><p>Instead, we endogenously enforce the ZLB only for the first connected sequence of periods with negative interest rates and use unanticipated monetary policy shocks for future sequences of periods with negative rates. Our algorithm proceeds as follows.</p><ol><li>Forecast without any periods of temporary ZLBs (unless a minimum length is specified) and find the first connected sequence of periods with negative interest rates.</li><li>Guess a sequence of temporary ZLB regimes that cover this first sequence of periods with negative interest rates.</li><li>If the forecast under the temporary policy from 2 successfully enforces the ZLB over that first sequence and does not introduce negative rates after liftoff from the ZLB, then test whether shorter ZLBs will also enforce it. Otherwise, extend the sequence of temporary ZLBs using the same approch as 2.</li><li>Once we have successfully found a minimum length that guarantees non-negative rates for the first sequence of periods, re-run the forecast using unanticipated monetary policy shocks to enforce any other sequences of periods with negative rates.</li></ol><p>Note that sometimes extending the sequence of temporary ZLB regimes will cause two disjoint sequences of periods with negative rates to become contiguous, in which case we treat the two disjoint sequences as one connected sequences therafter.</p><p>To use this method, the user runs a forecast as follows</p><pre><code class="language-none"># (optional) maximum permitted length for temporary ZLB regimes in the forecast
m &lt;= Setting(:max_temporary_altpol_length, max_zlb_length)

# (optional) minimum permitted length for temporary ZLB regimes and the
# ZLB regimes are assumed to start in the first period of the forecast
m &lt;= Setting(:min_temporary_altpol_length, min_zlb_length)

# (optional) length of the contiguous ZLB prior to the first period of the
# forecast, ending in the regime prior to the start of the forecast
m &lt;= Setting(:historical_temporary_altpolicy_lengh, hist_zlb_length)

forecast_one(m, input_type, cond_type, output_vars; rerun_smoother = true,
             zlb_method = :temporary_altpolicy,
             set_regime_vals_altpolicy = my_set_regime_vals_altpolicy_fnct,
             set_info_sets_altpolicy = my_set_info_sets_altpolicy_fnct,
             update_regime_eqcond_info! = my_update_regime_econd_info_fnct!,
             nan_endozlb_failures = false)</code></pre><p>The keyword arguments are briefly described below. For more details, see the docstring for <code>forecast_one</code>.</p><ul><li><p><code>rerun_smoother::Bool</code>: needs to be true if the current sequence of temporary ZLB regimes start during the history or conditional horizon because changing the length of the temporary ZLB affects the smoothed estimate of the state at the start of the forecast.</p></li><li><p><code>zlb_method::Symbol</code>: set to <code>:temporary_altpolicy</code> to enforce the ZLB as a temporary policy. Otherwise, unanticipated monetary policy shocks will be used.</p></li><li><p><code>set_regime_vals_altpolicy::Function</code>: if there are regime-switching parameters, this function is needed to figure out what parameters should be assigned to the new model regimes added when extending the temporary ZLB length.</p></li><li><p><code>set_info_sets_altpolicy::Function</code>: if the <code>Setting</code> <code>tvis_information_set</code> is used, then we need to specify how to update <code>tvis_information_set</code> as new model regimes are added to extend the temporary ZLB length.</p></li><li><p><code>update_regime_eqcond_info!::Function</code>: specifies how to update <code>regime_eqcond_info</code> to include more or fewer regimes of temporary ZLB.</p></li><li><p><code>nan_endozlb_failures::Bool</code>: sometimes the ZLB cannot be enforced because rates are negative even when the ZLB extends throughout the entire forecast horizon or because the max ZLB length is reached. By default, we enforce the remainder of the forecast horizon with unanticipated monetary policy shocks. If this kwarg is true, we return <code>NaN</code>s rather than use unanticipated shocks.</p></li></ul><p>For further guidance on forecasting with an endogenously enforced ZLB, please see the script <a href="https://github.com/FRBNY-DSGE/DSGE.jl/tree/main/examples/imperfect_awareness_tempzlb_ait.jl">imperfect<em>awareness</em>tempzlb_ait.jl</a> with the keyword endozlb set to true.</p><h2 id="editing-extending-model-1"><a class="docs-heading-anchor" href="#editing-extending-model-1">Editing or Extending a Model</a><a class="docs-heading-anchor-permalink" href="#editing-extending-model-1" title="Permalink"></a></h2><p>Users may want to extend or edit <code>Model990</code> in a number of different ways.  The most common changes are listed below, in decreasing order of complexity:</p><ol><li>Add new parameters</li><li>Modify equilibrium conditions or measurement equations</li><li>Change the values of various parameter fields (i.e. initial <code>value</code>, <code>prior</code>, <code>transform</code>, etc.)</li><li>Change the values of various computational settings (i.e. <code>reoptimize</code>, <code>n_mh_blocks</code>)</li></ol><p>Points 1 and 2 often go together (adding a new parameter guarantees a change in equilibrium conditions), and are such fundamental changes that they increment the model specification number and require the definition of a new subtype of <code>AbstractModel</code> (for instance, <code>Model991</code>).  See <a href="#model-specification-mspec-1">Model specification</a> for more details.</p><p>Any changes to the initialization of preexisting parameters are defined as a new model <em>sub-specification</em>, or <em>subspec</em>. While less significant than a change to the model&#39;s equilibrium conditions, changing the values of some parameter fields (especially priors) can have economic significance over and above settings we use for computational purposes. <strong>Parameter definitions should not be modified in the model object&#39;s constructor.</strong> First, incrementing the model&#39;s sub-specification number when parameters are changed improves model-level (as opposed to code-level) version control. Second, it avoids potential output filename collisions, preventing the user from overwriting output from previous estimations with the original parameters. The protocol for defining new sub-specifications is described in <a href="#model-sub-specifications-msubspec-1">Model sub-specifications</a>.</p><h3 id="model-specification-mspec-1"><a class="docs-heading-anchor" href="#model-specification-mspec-1">Model specification (<code>m.spec</code>)</a><a class="docs-heading-anchor-permalink" href="#model-specification-mspec-1" title="Permalink"></a></h3><p>A particular model, which corresponds to a subtype of <code>AbstractModel</code>, is defined as a set of parameters, equilibrium conditions (defined by the <code>eqcond</code> function) and measurement equations (defined by the <code>measurement</code> function).  Therefore, the addition of new parameters, states, or observables, or any changes to the equilibrium conditions or measurement equations necessitate the creation of a new subtype of <code>AbstractModel.</code></p><p>To create a new model object, we recommend doing the following:</p><ol><li>Duplicate the <code>m990</code> directory within the <a href="https://github.com/FRBNY-DSGE/DSGE.jl/tree/main/src/models">models</a> directory. Name the new directory <code>mXXX.jl</code>, where <code>XXX</code> is your chosen model specification number or string. Rename <code>m990.jl</code> in this directory to <code>mXXX.jl</code>.</li><li>In the <code>mXXX/</code> directory, change all references to <code>Model990</code> to <code>ModelXXX</code>.</li><li>Edit the <code>m990.jl</code>, <code>eqcond.jl</code>, and <code>measurement.jl</code> files as you see fit.  If adding new states, equilibrium conditions, shocks, or observables, be sure to add them to the appropriate list in <code>init_model_indices</code>.</li><li>Open the module file, <code>src/DSGE.jl</code>. Add <code>ModelXXX</code> to the list of functions to export, and include each of the files in <code>src/model/mXXX</code>.</li></ol><p><strong>It is very important that you include the default settings by adding the line <code>default_settings!(m)</code> inside the function that creates a new instance of your model.</strong> Otherwise, many methods in DSGE.jl will fail because they assume many settings have default values that are set by <code>default_settings!</code>.</p><h3 id="model-sub-specifications-msubspec-1"><a class="docs-heading-anchor" href="#model-sub-specifications-msubspec-1">Model sub-specifications (<code>m.subspec</code>)</a><a class="docs-heading-anchor-permalink" href="#model-sub-specifications-msubspec-1" title="Permalink"></a></h3><p><code>Model990</code> sub-specifications are initialized by overwriting initial parameter definitions before the model object is fully constructed. This happens via a call to <code>init_subspec</code> in the <code>Model990</code> constructor. (Clearly, an identical protocol should be followed for new model types as well.)</p><p>To create a new sub-specification (e.g., subspec 1) of <code>Model990</code>, edit the file <code>src/models/subspecs.jl</code> as follows (note that this example is not actually sub-specification <code>1</code> of <code>Model990</code>. In the source code, our sub-specification <code>5</code> is provided as additional example.):</p><p><strong>Step 1.</strong> Define a new function, <code>ss1</code>, that takes an object of type <code>Model990</code> (not    <code>AbstractModel</code>!) as an argument. In this function, construct new parameter objects and    overwrite existing model parameters using the <code>&lt;=</code> syntax. For example,</p><pre><code class="language-julia">function ss1(m::Model990)
    m &lt;= parameter(:ι_w, 0.000, (0.0, .9999), (0.0,0.9999), DSGE.Untransformed(), Normal(0.0,1.0), fixed=false,
                   description=&quot;ι_w: Some description.&quot;,
                   tex_label=&quot;\\iota_w&quot;)
    m &lt;= parameter(:ι_p, 0.0, fixed=true,
                   description= &quot;ι_p: Some description&quot;
                   tex_label=&quot;\\iota_p&quot;)
end</code></pre><p><strong>Step 2.</strong> Add an <code>elseif</code> condition to <code>init_subspec</code>:</p><pre><code class="language-julia">    ...
    elseif subspec(m) == &quot;ss1&quot;
        return ss1(m)
    ...</code></pre><p>To construct an instance of <code>Model990</code>, <code>ss1</code>, call the constructor for <code>Model990</code> with <code>ss1</code> as an argument. For example,</p><pre><code class="language-julia">m = Model990(&quot;ss1&quot;)</code></pre><h2 id="Additional-Tips-1"><a class="docs-heading-anchor" href="#Additional-Tips-1">Additional Tips</a><a class="docs-heading-anchor-permalink" href="#Additional-Tips-1" title="Permalink"></a></h2><ul><li>The file <code>abstractdsgemodel.jl</code> defines numerous auxiliary functions, which allow the user to more easily call standard settings or count the number of dimensions for important variables. For example, <code>data_vintage(m)</code> returns the vintage of the data specified by the model object <code>m</code>. Additionally see <code>abstractmodel.jl</code> in <a href="https://github.com/FRBNY-DSGE/ModelConstructors.jl">ModelConstructors.jl</a> for more functions like <code>n_observables(m)</code>, which returns the number of observables in <code>m</code>.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algorithms/">« Algorithms</a><a class="docs-footer-nextpage" href="../contributing/">Contributing to DSGE.jl »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 2 September 2021 02:33">Thursday 2 September 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
